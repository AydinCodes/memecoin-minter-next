// ===== next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// ===== next.config.ts =====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


// ===== src/middleware.ts =====

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// This middleware ensures CORS headers are properly set for API routes
export function middleware(request: NextRequest) {
  // Only apply to /api routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    // Handle OPTIONS requests for CORS preflight
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        },
      });
    }

    // Add CORS headers to all responses
    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return response;
  }

  return NextResponse.next();
}

// Configure which routes the middleware applies to
export const config = {
  matcher: '/api/:path*',
};

// ===== src/types/token.ts =====

// Update or create this in a shared location like src/types/token.ts

export interface FormDataType {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
    socialLinks: boolean;
    creatorInfo: boolean;
    creatorName: string; // Added for Creator's Info
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  }
  
  export interface TokenResult {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  }

// ===== src/app/guides/page.tsx =====

export default function Guides() {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          <h1 className="text-4xl font-bold text-center mb-10">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Guides & Resources
            </span>
          </h1>
          
          <div className="space-y-12">
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">How to Create a Solana Token</h2>
              <div className="prose prose-invert max-w-none">
                <ol className="list-decimal pl-5 space-y-4">
                  <li>
                    <strong>Connect Your Wallet</strong>
                    <p className="text-gray-400">
                      Click the "Connect Wallet" button in the top right corner and connect your Phantom, Solflare, or other compatible Solana wallet.
                    </p>
                  </li>
                  <li>
                    <strong>Fill in Token Details</strong>
                    <p className="text-gray-400">
                      Enter your token's name, symbol, supply, and other details. Upload a logo image (1000x1000px recommended).
                    </p>
                  </li>
                  <li>
                    <strong>Configure Token Options</strong>
                    <p className="text-gray-400">
                      Choose whether to include social links and creator information. Select which authorities to revoke (recommended for investor trust).
                    </p>
                  </li>
                  <li>
                    <strong>Launch Your Token</strong>
                    <p className="text-gray-400">
                      Click "Launch Token" and approve the transaction in your wallet. Your token will be created on the Solana blockchain.
                    </p>
                  </li>
                  <li>
                    <strong>Create Liquidity</strong>
                    <p className="text-gray-400">
                      After creating your token, consider setting up a liquidity pool on Raydium or another Solana DEX to make your token tradable.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">Token Authorities Explained</h2>
              <div className="prose prose-invert max-w-none">
                <p className="text-gray-400">
                  Solana tokens have three types of authorities that control different aspects of the token:
                </p>
                <ul className="list-disc pl-5 space-y-3 mt-4">
                  <li>
                    <strong>Mint Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to create (mint) new tokens. Revoking this authority creates a fixed supply token that cannot be inflated.
                    </p>
                  </li>
                  <li>
                    <strong>Freeze Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to freeze token accounts, preventing transfers. Revoking this ensures no one can freeze holders' tokens.
                    </p>
                  </li>
                  <li>
                    <strong>Update Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to modify token metadata (name, symbol, image, etc.). Revoking makes the token's metadata immutable.
                    </p>
                  </li>
                </ul>
                <p className="text-gray-400 mt-4">
                  For maximum credibility with your community, we recommend revoking all authorities.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

// ===== src/app/create-token/page.tsx =====

import TokenForm from '@/components/token/token-form';

export default function CreateToken() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <TokenForm />
    </div>
  );
}

// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Navbar from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SolMinter - Create Solana Tokens Easily",
  description: "Create, launch, and manage Solana tokens with ease. Your one-stop solution for Solana meme coin creation.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link 
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" 
          rel="stylesheet"
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0a0a0a] text-white`}
      >
        <Providers>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            <main className="flex-grow">{children}</main>
            <Footer />
          </div>
        </Providers>
      </body>
    </html>
  );
}

// ===== src/app/api/upload-metadata/route.ts =====

// src/app/api/upload-metadata/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the metadata from the request body
    const metadata = await request.json();
    
    console.log("Received metadata:", metadata);
    
    // Here you would typically upload to Pinata or another IPFS service
    // For now, we'll simulate a successful upload with a fake CID
    // In a real implementation, replace this with actual Pinata API call
    
    // Simulate IPFS upload with a random CID
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    
    // Simulate a slight delay like a real API call would have
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid
    });
  } catch (error) {
    console.error('Error uploading metadata:', error);
    return NextResponse.json(
      { error: 'Failed to upload metadata' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upload-image/route.ts =====

// src/app/api/upload-image/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    console.log("Received file:", file.name, "Size:", file.size);
    
    // Here you would typically upload to Pinata or another IPFS service
    // For now, we'll simulate a successful upload with a fake CID
    // In a real implementation, replace this with actual Pinata API call
    
    // Simulate IPFS upload with a random CID
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    
    // Simulate a slight delay like a real API call would have
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid 
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// ===== src/app/page.tsx =====

import Link from 'next/link';

export default function Home() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20">
        <div className="text-center">
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              SolMinter
            </span>
          </h1>
          <p className="text-xl md:text-2xl text-gray-400 mb-8 max-w-3xl mx-auto">
            Create, launch, and manage Solana tokens with ease. 
            Your one-stop solution for Solana meme coin creation.
          </p>
          
          <div className="flex flex-col sm:flex-row justify-center gap-4 mb-12">
            <Link href="/create-token" className="bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all">
              Create Token
            </Link>
            <Link href="/guides" className="bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all">
              Learn More
            </Link>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-purple-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Easy Token Creation</h2>
              <p className="text-gray-400">Create your Solana token with just a few clicks. No coding required.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-blue-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Secure & Trusted</h2>
              <p className="text-gray-400">Built on Solana for fast transactions and high security standards.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Lightning Fast</h2>
              <p className="text-gray-400">Launch your token in seconds with minimal fees on the Solana blockchain.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};  

// ===== src/app/providers.tsx =====

'use client';

import { ReactNode, useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Create a client-only wrapper component
const WalletConnectionProvider = ({ children }: { children: ReactNode }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return <>{children}</>;
};

// Dynamically import the wallet components with ssr: false
const ClientWalletProvider = dynamic(
  () => import('../components/wallet/wallet-provider-client').then(module => module.ClientWalletProvider),
  {
    ssr: false,
    loading: () => <WalletConnectionProvider><div>{/* Loading placeholder */}</div></WalletConnectionProvider>
  }
);

export function Providers({ children }: { children: ReactNode }) {
  return (
    <ClientWalletProvider>
      {children}
    </ClientWalletProvider>
  );
}

// ===== src/config/index.ts =====

// src/config/index.ts

// Solana network configuration
export const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

// Fee recipient wallet - address that will receive token creation fees
export const FEE_RECIPIENT_WALLET = process.env.NEXT_PUBLIC_FEE_WALLET || '8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt';

// IPFS/Pinata configuration
export const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
export const PINATA_API_KEY = process.env.NEXT_PUBLIC_PINATA_API_KEY;
export const PINATA_SECRET_KEY = process.env.NEXT_PUBLIC_PINATA_SECRET_KEY;

// Token creation fees (in SOL)
export const TOKEN_FEES = {
  BASE_FEE: 0.2,  // Base fee for token creation
  AUTHORITY_FEE: 0.1, // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MAX_FEE: 0.3 // Maximum fee (capped for discount)
};

// Default token configuration
export const DEFAULT_TOKEN_CONFIG = {
  decimals: 9,
  supply: 1000000000, // 1 billion
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true
};

// Explorer URL generator
export const getExplorerUrl = (address: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK;
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${address}${network === 'devnet' ? '?cluster=devnet' : ''}`;
};

// Metaplex Token Metadata Program ID (constant across all Solana networks)
// UPDATED: This is the correct Metaplex Token Metadata Program ID
export const TOKEN_METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Program ID for the SPL Token Program
export const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';

// ===== src/utils/wallet-debug.ts =====

// src/utils/wallet-debug.ts

/**
 * Helper function to debug wallet connection status
 */
export function debugWallet(wallet: any) {
    const connection = {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      publicKeyValue: wallet && wallet.publicKey ? wallet.publicKey.toString() : 'none',
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false,
      walletName: wallet?.adapter?.name || 'unknown'
    };
    
    console.log("===== WALLET DEBUG INFO =====");
    console.table(connection);
    console.log("=============================");
    
    return connection;
  }
  
  /**
   * Helper function to debug wallet adapter capabilities
   */
  export function debugWalletCapabilities(wallet: any) {
    if (!wallet || !wallet.adapter) {
      console.log("No wallet adapter found");
      return;
    }
    
    const adapter = wallet.adapter;
    
    const capabilities = {
      name: adapter.name,
      icon: !!adapter.icon,
      connected: !!adapter.connected,
      publicKey: !!adapter.publicKey,
      connecting: !!adapter.connecting,
      ready: !!adapter.ready,
      supportedTransactionVersions: adapter.supportedTransactionVersions ? 
        Array.from(adapter.supportedTransactionVersions) : [],
      hasConnect: typeof adapter.connect === 'function',
      hasDisconnect: typeof adapter.disconnect === 'function',
      hasSignTransaction: typeof adapter.signTransaction === 'function',
      hasSignAllTransactions: typeof adapter.signAllTransactions === 'function',
      hasSignMessage: typeof adapter.signMessage === 'function',
      hasSendTransaction: typeof adapter.sendTransaction === 'function',
    };
    
    console.log("===== WALLET CAPABILITIES =====");
    console.table(capabilities);
    console.log("===============================");
    
    return capabilities;
  }

// ===== src/utils/error-utils.ts =====

// src/utils/error-utils.ts

/**
 * Formats Solana errors into user-friendly messages
 */
export function formatSolanaError(error: any): string {
    // If it's already a string, just return it
    if (typeof error === 'string') return error;
    
    // Extract error message from Error object
    const errorMessage = error.message || 'Unknown error occurred';
    
    // Handle specific Solana error messages
    if (errorMessage.includes('0x1')) {
      return 'Insufficient funds for transaction. Please make sure you have enough SOL to cover the fees.';
    }
    
    if (errorMessage.includes('Blockhash not found')) {
      return 'Network congestion detected. Please try again in a few moments.';
    }
    
    if (errorMessage.includes('Transaction simulation failed')) {
      return 'Transaction simulation failed. This could be due to network congestion or insufficient SOL.';
    }
    
    if (errorMessage.includes('User rejected')) {
      return 'Transaction was rejected by wallet. You must approve the transaction to continue.';
    }
    
      // Handle wallet connection errors
    if (errorMessage.includes('wallet disconnected') || errorMessage.includes('wallet not connected')) {
      return 'Wallet disconnected. Please reconnect your wallet and try again.';
    }
    
    if (errorMessage.includes('timeout')) {
      return 'Transaction timed out. The Solana network might be congested, please try again.';
    }
    
    // Handle metadata errors
    if (errorMessage.includes('metadata')) {
      return 'Error with token metadata. Please ensure your token information is valid.';
    }
    
    // Handle Pinata/IPFS errors
    if (errorMessage.includes('Pinata') || errorMessage.includes('IPFS')) {
      return 'Error uploading to IPFS. Please try again or check if your image file is valid.';
    }
  
    // Fall back to the original error message
    return errorMessage;
  }
  
  /**
   * Logs detailed error information
   */
  export function logError(error: any, context: string): void {
    console.error(`Error in ${context}:`, error);
    
    // Log additional information if available
    if (error.code) {
      console.error(`Error code: ${error.code}`);
    }
    
    if (error.stack) {
      console.error(`Stack trace: ${error.stack}`);
    }
    
    // For Solana-specific errors
    if (error.logs) {
      console.error('Solana logs:', error.logs);
    }
  }
  
  /**
   * Creates a user-friendly error message for validation errors
   */
  export function getValidationErrorMessage(field: string, message: string): string {
    return `${field}: ${message}`;
  }
  
  /**
   * Checks common token validation rules
   */
  export function validateTokenData(data: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
  }): string | null {
    if (!data.name || data.name.trim() === '') {
      return 'Token name is required';
    }
    
    if (data.name.length > 32) {
      return 'Token name must be 32 characters or less';
    }
    
    if (!data.symbol || data.symbol.trim() === '') {
      return 'Token symbol is required';
    }
    
    if (data.symbol.length > 10) {
      return 'Token symbol must be 10 characters or less';
    }
    
    if (data.decimals < 0 || data.decimals > 18) {
      return 'Decimals must be between 0 and 18';
    }
    
    if (data.supply <= 0) {
      return 'Supply must be greater than 0';
    }
    
    if (data.supply > Number.MAX_SAFE_INTEGER) {
      return 'Supply is too large';
    }
    
    return null;
  }

// ===== src/utils/token-utils.ts =====

// src/utils/token-utils.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length < 2 || symbol.length > 10) {
      return false;
    }
    
    // Most token symbols are uppercase alphanumeric
    const validSymbolRegex = /^[A-Z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Formats a wallet address for display 
   */
  export function formatWalletAddress(address: string): string {
    if (!address || address.length < 10) return address;
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  }
  
  /**
   * Generates a token explorer URL
   */
  export function getTokenExplorerUrl(tokenAddress: string, network: string = 'devnet'): string {
    return `https://explorer.solana.com/address/${tokenAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`;
  }

// ===== src/utils/token-validation.ts =====

// src/utils/token-validation.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters - allow more flexibility than the original
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length > 10) {
      return false;
    }
    
    // Allow more flexibility in symbol format
    const validSymbolRegex = /^[A-Za-z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token description
   */
  export function isValidTokenDescription(description: string): boolean {
    // Description should exist
    if (!description || description.trim() === '') {
      return false;
    }
    
    // Reasonable length limit
    if (description.length > 1000) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits - allow bigger supply than original
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates token decimals
   */
  export function isValidTokenDecimals(decimals: number): boolean {
    // Decimals must be in the valid range for Solana tokens
    return Number.isInteger(decimals) && decimals >= 0 && decimals <= 9;
  }
  
  /**
   * Validates an image file for token logo
   */
  export function isValidTokenImage(file: File | null): boolean {
    if (!file) {
      return false;
    }
    
    // Check file type
    const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!validTypes.includes(file.type)) {
      return false;
    }
    
    // Check file size (max 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Validates the entire token form data
   * @returns string error message or null if valid
   */
  export function validateTokenForm(formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  }): string | null {
    if (!isValidTokenName(formData.name)) {
      return "Token name is required and must be up to 32 alphanumeric characters";
    }
    
    if (!isValidTokenSymbol(formData.symbol)) {
      return "Token symbol is required and must be 2-10 alphanumeric characters";
    }
    
    if (!isValidTokenDescription(formData.description)) {
      return "Description is required and must be less than 1000 characters";
    }
    
    if (!isValidTokenDecimals(formData.decimals)) {
      return "Decimals must be a whole number between 0 and 9";
    }
    
    if (!isValidTokenSupply(formData.supply)) {
      return "Supply must be a positive whole number";
    }
    
    if (!isValidTokenImage(formData.logo)) {
      return "Logo image is required (PNG or JPG, max 5MB)";
    }
    
    return null;
  }

// ===== src/components/token/token-form-options.tsx =====

'use client';

import React from 'react';
import SocialLinksForm from './social-links-form';

interface TokenFormOptionsProps {
  formData: {
    socialLinks: boolean;
    creatorInfo: boolean;
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
}

export default function TokenFormOptions({
  formData,
  setFormData,
  handleInputChange
}: TokenFormOptionsProps) {
  // Toggle function that also updates the input checkbox
  const toggleOption = (option: 'socialLinks' | 'creatorInfo') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev, 
      [option]: !prev[option]
    }));
    
    // Also simulate changing the checkbox by dispatching an event
    const checkbox = document.getElementById(option) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[option];
      const event = new Event('change', { bubbles: true });
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="creatorInfo" 
                type="checkbox" 
                name="creatorInfo"
                checked={formData.creatorInfo}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.creatorInfo ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('creatorInfo')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.creatorInfo ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Creator's Info (Optional)</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Change the information of the creator in the metadata. By default, it is SolMinter.
        </div>
      </div>

      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="socialLinks" 
                type="checkbox" 
                name="socialLinks"
                checked={formData.socialLinks}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.socialLinks ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('socialLinks')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.socialLinks ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Add Social Links & Tags</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Add links to your token metadata.
        </div>
      </div>
      
      {formData.socialLinks && (
        <SocialLinksForm formData={formData} handleInputChange={handleInputChange} />
      )}
    </div>
  );
}

// ===== src/components/token/token-form.tsx =====

"use client"

import { useState, useCallback, useEffect } from "react"
import { useWallet, useConnection } from "@solana/wallet-adapter-react"
import {
  createTokenWithMetadata,
  FormDataType,
  TokenResult,
} from "@/services/token-service"
import { calculateFee, formatFee } from "@/services/fee-service"
import TokenCreationSuccess from "./token-creation-success"
import Loading from "../ui/loading"
import TokenFormBasic from "./token-form-basic"
import TokenFormOptions from "./token-form-options"
import TokenFormAuthorities from "./token-form-authorities"
import TokenFormCreator from "./token-form-creator"

const STEPS = [
  "Uploading token image…",
  "Creating token metadata…",
  "Processing transaction…",
  "Creating mint & token account…",
  "Adding on‐chain metadata…",
  "Configuring token authorities…",
]

export default function TokenForm() {
  const walletAdapter = useWallet()
  const { connection } = useConnection()

  const [formData, setFormData] = useState<FormDataType>({
    name: "",
    symbol: "",
    decimals: 9,
    supply: 1_000_000_000,
    description: "",
    logo: null,
    revokeMint: true,
    revokeFreeze: true,
    revokeUpdate: true,
    socialLinks: false,
    creatorInfo: false,
    creatorName: "SolMinter", // Default creator name
    website: "",
    twitter: "",
    telegram: "",
    discord: "",
  })

  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [progressStep, setProgressStep] = useState(0)
  const [tokenResult, setTokenResult] = useState<TokenResult | null>(null)
  const [totalFee, setTotalFee] = useState<number>(0.4) // Initial fee calculation with all defaults (0.1 base + 0.3 for all authorities)

  // Calculate fee whenever relevant form options change
  useEffect(() => {
    const fee = calculateFee({
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    console.log("Calculated fee:", fee, "with options:", {
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    setTotalFee(fee)
  }, [
    formData.revokeMint,
    formData.revokeFreeze,
    formData.revokeUpdate,
    formData.socialLinks,
    formData.creatorInfo,
  ])

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target as HTMLInputElement
    const checked = type === 'checkbox' ? (e.target as HTMLInputElement).checked : undefined
    
    console.log(`Input changed: ${name} = ${type === 'checkbox' ? checked : value}`)
    
    setFormData((prev) => ({
      ...prev,
      [name]:
        type === "checkbox"
          ? checked
          : type === "number"
          ? parseInt(value)
          : value,
    }))
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFormData((prev) => ({ ...prev, logo: e.target.files![0] }))
    }
  }

  // Function to validate form data before submission
  const validateForm = (): string | null => {
    if (!walletAdapter.connected) {
      return "Please connect your wallet first";
    }
    if (!formData.logo) {
      return "Please upload a logo image";
    }
    if (!formData.name || formData.name.trim() === '') {
      return "Token name is required";
    }
    if (!formData.symbol || formData.symbol.trim() === '') {
      return "Token symbol is required";
    }
    if (!formData.description || formData.description.trim() === '') {
      return "Token description is required";
    }
    return null;
  };

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      
      // Clear previous errors
      setError(null)
      
      // Validate form
      const validationError = validateForm();
      if (validationError) {
        setError(validationError);
        return;
      }

      try {
        setIsSubmitting(true)
        setProgressStep(0)

        const result = await createTokenWithMetadata(
          walletAdapter,
          formData,
          totalFee, // Pass the calculated total fee
          (step) => setProgressStep(step)
        )
        setTokenResult(result)
      } catch (err: any) {
        console.error("Token creation error:", err)
        setError(err.message || "Unknown error occurred during token creation")
      } finally {
        setIsSubmitting(false)
      }
    },
    [walletAdapter, formData, totalFee]
  )

  const buttonDisabled = !walletAdapter.connected || isSubmitting;

  if (tokenResult) {
    return <TokenCreationSuccess result={tokenResult} />
  }

  if (isSubmitting) {
    return (
      <Loading
        message="Creating your token..."
        steps={STEPS}
        currentStepIndex={progressStep}
      />
    )
  }

  return (
    <form
      onSubmit={handleSubmit}
      className="max-w-3xl mx-auto space-y-6 p-6 bg-[#171717] rounded-xl"
    >
      {error && (
        <div className="text-red-400 bg-red-800/30 p-3 rounded mb-4">{error}</div>
      )}

      <TokenFormBasic
        formData={formData}
        handleInputChange={handleInputChange}
        handleFileChange={handleFileChange}
      />

      <TokenFormOptions
        formData={formData}
        setFormData={setFormData}
        handleInputChange={handleInputChange}
      />

      {formData.creatorInfo && (
        <TokenFormCreator
          formData={formData}
          handleInputChange={handleInputChange}
        />
      )}

      <TokenFormAuthorities
        formData={formData}
        setFormData={setFormData}
      />

      {/* Display dynamic feature‐fee total */}
      <div className="flex justify-between items-center text-gray-300">
        <span>Total fee:</span>
        <span className="text-purple-500 font-semibold">
          {formatFee(totalFee)}
        </span>
      </div>
      <div className="text-xs text-gray-500">
        (Single transaction includes all network fees)
      </div>

      <button
        type="submit"
        disabled={buttonDisabled}
        className={`w-full py-3 rounded-full text-white font-medium transition cursor-pointer ${
          !buttonDisabled
            ? "bg-gradient-to-r from-purple-600 to-blue-500 hover:opacity-90"
            : "bg-gray-600 cursor-not-allowed"
        }`}
      >
        {walletAdapter.connected ? "Launch Token" : "Connect Wallet"}
      </button>
    </form>
  )
}

// ===== src/components/token/token-creation-success.tsx =====

'use client';

import Link from 'next/link';
import React from 'react';

interface TokenCreationSuccessProps {
  result: {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  };
}

export default function TokenCreationSuccess({ result }: TokenCreationSuccessProps) {
  return (
    <div className="max-w-3xl mx-auto py-12 px-4">
      <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-green-500 border-opacity-30">
        <div className="text-center mb-6">
          <div className="w-20 h-20 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-10 h-10 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </div>
          
          <h1 className="text-3xl font-bold text-white mb-2">Token Created Successfully!</h1>
          <p className="text-gray-400 text-lg">Your Solana token has been created and is ready to use.</p>
        </div>
        
        <div className="token-info bg-[#222] rounded-lg p-5 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="token-image flex items-center justify-center">
              <img 
                src={result.imageUrl} 
                alt="Token Logo" 
                className="w-32 h-32 rounded-full border-4 border-gray-700"
              />
            </div>
            
            <div className="token-details">
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Token Address</div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.mintAddress}
                </div>
              </div>
              
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Metadata URL</div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.metadataUrl}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div className="next-steps space-y-4 mb-8">
          <h2 className="text-xl font-semibold text-white">Next Steps</h2>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">Create Liquidity</h3>
            <p className="text-gray-400 mb-2">Create a liquidity pool on a DEX like Raydium to make your token tradable.</p>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to Raydium
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">View on Explorer</h3>
            <p className="text-gray-400 mb-2">Check your token on the Solana blockchain explorer.</p>
            <a 
              href={result.explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              View on Explorer
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
        </div>
        
        <div className="buttons flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4">
          <Link 
            href="/"
            className="btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all text-center"
          >
            Back to Home
          </Link>
          
          <Link 
            href="/create-token"
            className="btn bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Create Another Token
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-creator.tsx =====

'use client';

import React from 'react';

interface TokenFormCreatorProps {
  formData: {
    creatorName: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormCreator({ 
  formData, 
  handleInputChange 
}: TokenFormCreatorProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Creator Information</div>
      
      <div className="bg-[#1e1e1e] rounded-lg p-4">
        <div className="form-field mb-4">
          <label className="field-label block text-gray-300 mb-2">Creator Name</label>
          <input 
            placeholder="Enter creator name" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="creatorName"
            value={formData.creatorName}
            onChange={handleInputChange}
          />
          <span className="field-constraint text-xs text-gray-500 mt-1 block">
            This name will appear as the creator in token metadata
          </span>
        </div>
      </div>
      
      <div className="text-xs text-gray-500 mt-2">
        Customize the creator information instead of using the default SolMinter.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-authorities.tsx =====

'use client';

import React from 'react';

interface TokenFormAuthoritiesProps {
  formData: {
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
}

export default function TokenFormAuthorities({
  formData,
  setFormData
}: TokenFormAuthoritiesProps) {
  // Handle checkbox click with proper event simulation
  const handleCheckboxClick = (field: 'revokeMint' | 'revokeFreeze' | 'revokeUpdate') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev,
      [field]: !prev[field]
    }));
    
    // Find the related hidden checkbox and simulate a change event
    const checkbox = document.getElementById(field) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[field];
      // Create a proper change event
      const event = new Event('change', { bubbles: true });
      
      // Add properties to the event object using Object.defineProperty
      Object.defineProperty(event, 'target', {
        writable: false,
        value: {
          name: field,
          type: 'checkbox',
          checked: !formData[field]
        }
      });
      
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Revoke Authorities (Investor's Booster)</div>
      
      <div className="form-section-authorities space-y-4">
        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Freeze</div>
              <input 
                id="revokeFreeze" 
                type="checkbox" 
                name="revokeFreeze"
                checked={formData.revokeFreeze}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeFreeze: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeFreeze ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeFreeze')}
              >
                {formData.revokeFreeze && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to freeze holders' token accounts anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Mint</div>
              <input 
                id="revokeMint" 
                type="checkbox" 
                name="revokeMint"
                checked={formData.revokeMint}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeMint: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeMint ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeMint')}
              >
                {formData.revokeMint && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to create more tokens anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Update</div>
              <input 
                id="revokeUpdate" 
                type="checkbox" 
                name="revokeUpdate"
                checked={formData.revokeUpdate}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeUpdate: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeUpdate ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeUpdate')}
              >
                {formData.revokeUpdate && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to modify token metadata anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>
      </div>
      
      <div className="form-section-description text-xs text-gray-500 mt-4">
        Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.
      </div>
    </div>
  );
}

// ===== src/components/token/social-links-form.tsx =====

'use client';

import React from 'react';

interface SocialLinksFormProps {
  formData: {
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SocialLinksForm({ formData, handleInputChange }: SocialLinksFormProps) {
  return (
    <div className="social-links-form bg-[#1e1e1e] rounded-lg p-4 mt-4">
      <h3 className="text-white text-lg mb-4">Social Links</h3>
      
      <div className="space-y-4">
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Website URL</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
              </svg>
            </span>
            <input 
              placeholder="https://your-website.com" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="website"
              value={formData.website}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Twitter</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://x.com/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="twitter"
              value={formData.twitter}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Telegram</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
            </span>
            <input 
              placeholder="https://t.me/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="telegram"
              value={formData.telegram}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Discord</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://discord.gg/yourinvite" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="discord"
              value={formData.discord}
              onChange={handleInputChange}
            />
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Adding social links helps your community find and connect with your project. All fields are optional.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-basic.tsx =====

'use client';

import React, { useRef } from 'react';

interface TokenFormBasicProps {
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormBasic({
  formData,
  handleInputChange,
  handleFileChange
}: TokenFormBasicProps) {
  // Create a ref for the file input
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Function to trigger file input click
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Name *</label>
        <input 
          placeholder="Ex: Moon Coin" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Max 32 characters in your name</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Symbol *</label>
        <input 
          placeholder="Ex: MOON" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="symbol"
          value={formData.symbol}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Decimals *</label>
        <input 
          placeholder="Ex: 9" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="decimals"
          value={formData.decimals}
          onChange={handleInputChange}
          min="0"
          max="18"
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Change the number of decimals for your token</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Supply *</label>
        <input 
          placeholder="Ex: 1000000000" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="supply"
          value={formData.supply}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">The initial number of available tokens that will be created in your wallet</span>
      </div>

      <div className="logo-wrapper grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
        <div className="logo-box">
          <span className="label-text block text-gray-300 mb-2">Logo *</span>
          <div 
            className="img-input-wrapper border-2 border-dashed border-gray-700 rounded-lg p-6 text-center cursor-pointer hover:border-purple-500 transition-colors" 
            onClick={triggerFileInput}
          >
            <span className="material-symbols-rounded text-3xl mb-2 text-gray-400 block">upload</span>
            <span className="text-1 block text-gray-300 mb-1">Drag and drop here to upload</span>
            <div className="text-2 text-xs text-gray-500">.png, .jpg 1000x1000 px</div>
            <input 
              ref={fileInputRef}
              accept=".png, .jpg, .jpeg" 
              className="form-img hidden" 
              type="file"
              onChange={handleFileChange}
              // Remove required from hidden input
            />
          </div>
          <span className="field-constraint text-xs text-gray-500 mt-1 block">Add logo for your token</span>
          {!formData.logo && (
            <span className="text-red-400 text-xs mt-1 block">
              Logo image is required
            </span>
          )}
        </div>
        
        <div className="logo-preview flex items-center justify-center">
          {formData.logo ? (
            <img 
              src={URL.createObjectURL(formData.logo)} 
              alt="Token Logo Preview" 
              className="max-h-40 rounded-lg border border-gray-700"
            />
          ) : (
            <div className="text-gray-500 text-sm">Logo preview will appear here</div>
          )}
        </div>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Description *</label>
        <textarea 
          placeholder="Here you can describe your token" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white h-24" 
          name="description"
          value={formData.description}
          onChange={handleInputChange}
          required
        />
      </div>
    </div>
  );
}

// ===== src/components/ui/loading.tsx =====

// src/components/ui/loading.tsx

'use client'

import React from 'react'

interface LoadingProps {
  message?: string
  steps?: string[]
  /** If provided, controls which step is active; disables auto‐advance */
  currentStepIndex?: number
}

export default function Loading({
  message = 'Loading...',
  steps = [],
  currentStepIndex,
}: LoadingProps) {
  const stepIndex = currentStepIndex != null ? currentStepIndex : 0

  return (
    <div className="flex flex-col items-center justify-center p-8">
      <div className="relative w-16 h-16 mb-6">
        <div className="absolute inset-0 rounded-full border-4 border-purple-500 border-opacity-30"></div>
        <div className="absolute inset-0 rounded-full border-4 border-transparent border-t-purple-500 animate-spin"></div>
      </div>

      <div className="text-white text-lg mb-6">{message}</div>

      <ul className="w-full max-w-md space-y-3">
        {steps.map((step, idx) => {
          const isDone = idx < stepIndex
          const isActive = idx === stepIndex

          return (
            <li
              key={idx}
              className={`flex items-center text-sm ${
                isDone
                  ? 'text-white'
                  : isActive
                  ? 'text-white'
                  : 'text-gray-500'
              }`}
            >
              {isDone ? (
                <span className="w-6 h-6 mr-3 flex items-center justify-center bg-green-500 rounded-full text-white">
                  ✓
                </span>
              ) : isActive ? (
                <span className="w-6 h-6 mr-3 flex items-center justify-center border-2 border-purple-500 rounded-full">
                  <span className="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></span>
                </span>
              ) : (
                <span className="w-6 h-6 mr-3 flex items-center justify-center border-2 border-gray-600 rounded-full"></span>
              )}
              <span>{step}</span>
            </li>
          )
        })}
      </ul>
    </div>
  )
}


// ===== src/components/layout/navbar.tsx =====

'use client';

import Link from 'next/link';
import WalletButton from '../wallet/wallet-button';

export default function Navbar() {
  return (
    <div className="nav-container bg-[#111] border-b border-gray-800 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <Link href="/" className="logo-container flex items-center">
            <div className="logo-img">
              <span className="text-2xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <nav className="main-nav hidden md:flex space-x-6">
            <Link href="/" className="nav-link text-gray-300 hover:text-white transition-colors">
              Home
            </Link>
            <Link href="/create-token" className="nav-link text-gray-300 hover:text-white transition-colors">
              Create Token
            </Link>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Liquidity Pool
            </a>
            <a 
              href="https://raydium.io/swap" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Manage Liquidity
            </a>
            <Link href="/guides" className="nav-link text-gray-300 hover:text-white transition-colors">
              Guides
            </Link>
          </nav>
          
          <div className="wallet-dropdown">
            <WalletButton />
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/layout/footer.tsx =====

'use client';

import Link from 'next/link';

export default function Footer() {
  return (
    <div className="footer-container bg-[#111] border-t border-gray-800 py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <Link href="/" className="logo-container mb-4 md:mb-0">
            <div className="logo-img">
              <span className="text-xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <div className="bottom-bar flex flex-col md:flex-row items-center">
            <div className="copyright-bar text-gray-500 text-sm mb-2 md:mb-0">
              <span>© SolMinter 2025</span>
            </div>
            
            <div className="policies-bar flex ml-0 md:ml-6">
              <Link href="/terms" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Terms of Service
              </Link>
              <span className="separator mx-2 text-gray-600">|</span>
              <Link href="/privacy" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Privacy Policy
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-button.tsx =====

'use client';

import { useCallback, useEffect, useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { formatWalletAddress, getWalletBalance, isWalletConnected } from '@/services/wallet-service';
import { debugWallet, debugWalletCapabilities } from '@/utils/wallet-debug';
import '@/styles/wallet-button.css';

export default function WalletButton() {
  const { publicKey, connected, connecting, disconnecting, wallet } = useWallet();
  const [mounted, setMounted] = useState(false);
  const [balance, setBalance] = useState<number | null>(null);
  
  // Load balance when connected
  const loadBalance = useCallback(async () => {
    if (connected && publicKey) {
      try {
        const sol = await getWalletBalance(publicKey);
        setBalance(sol);
      } catch (error) {
        console.error('Error fetching balance:', error);
      }
    } else {
      setBalance(null);
    }
  }, [connected, publicKey]);

  // Only show the component after mounting to prevent hydration errors
  useEffect(() => {
    setMounted(true);
  }, []);

  // Fetch balance when connected
  useEffect(() => {
    if (connected && publicKey) {
      loadBalance();
    }
  }, [connected, publicKey, loadBalance]);

  // Format public key for display
  const getFormattedAddress = () => {
    if (!publicKey) return '';
    return formatWalletAddress(publicKey.toString());
  };

  // Add some logging for debugging connection issues
  useEffect(() => {
    if (connecting) {
      console.log('Wallet connecting...');
    } else if (disconnecting) {
      console.log('Wallet disconnecting...');
    } else if (connected) {
      console.log('Wallet connected:', getFormattedAddress());
      // Add additional debugging
      debugWallet(wallet);
      debugWalletCapabilities(wallet);
    }
  }, [connecting, disconnecting, connected, publicKey, wallet]);
  
  if (!mounted) {
    // Return a placeholder with the same dimensions to prevent layout shift
    return <div className="wallet-button-placeholder h-10 w-32"></div>;
  }
  
  return (
    <div className="wallet-button relative">
      <WalletMultiButton className="wallet-display hover:bg-opacity-90 transition-all" />
      
      {connected && balance !== null && (
        <div className="wallet-balance absolute -bottom-6 right-0 text-xs text-gray-400 bg-[#171717] px-2 py-1 rounded">
          {balance.toFixed(2)} SOL
        </div>
      )}
    </div>
  );
}

// ===== src/components/wallet/wallet-provider.tsx =====

'use client';

import { FC, ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Default styles that can be overridden by your app
import '@solana/wallet-adapter-react-ui/styles.css';

interface WalletContextProviderProps {
  children: ReactNode;
}

export const WalletContextProvider: FC<WalletContextProviderProps> = ({ children }) => {
  // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.
  const network = WalletAdapterNetwork.Devnet;

  // You can also provide a custom RPC endpoint.
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Only include Phantom wallet adapter to minimize dependency issues
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

// ===== src/components/wallet/wallet-provider-client.tsx =====

'use client';

import { ReactNode, useEffect, useMemo, useState } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare';

import { LedgerWalletAdapter } from '@solana/wallet-adapter-ledger';
// Removed the TorusWalletAdapter as it's causing dependency issues
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface ClientWalletProviderProps {
  children: ReactNode;
}

export function ClientWalletProvider({ children }: ClientWalletProviderProps) {
  // Track component mounting state to prevent hydration issues
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  // Set the network from environment variables
  const networkEnv = SOLANA_NETWORK || 'devnet';
  const network = networkEnv === 'mainnet-beta' 
    ? WalletAdapterNetwork.Mainnet
    : WalletAdapterNetwork.Devnet;

  // Set up the RPC endpoint
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Add a more comprehensive list of wallet adapters (except Torus which causes issues)
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),

      new LedgerWalletAdapter()
    ],
    [network]
  );

  // Only render the provider once the component is mounted to avoid hydration errors
  if (!mounted) return null;

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect={false}>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

// ===== src/services/ipfs-service.ts =====

// src/services/ipfs-service.ts

export async function uploadImageToIPFS(file: File): Promise<string> {
  const formData = new FormData()
  formData.append('file', file)

  const res = await fetch('/api/upload-image', {
    method: 'POST',
    body: formData,
  })

  if (!res.ok) {
    throw new Error(`Image upload failed: ${res.statusText}`)
  }

  const { cid } = await res.json()
  return `https://${process.env.NEXT_PUBLIC_PINATA_GATEWAY}/ipfs/${cid}`
}

export interface MetadataPayload {
  name: string
  symbol: string
  description: string
  image: string
  creator?: string
  website?: string
  twitter?: string
  telegram?: string
  discord?: string
}

export async function uploadMetadataToIPFS(
  payload: MetadataPayload
): Promise<string> {
  // Construct the metadata object with conditional fields
  const metadata: any = {
    name: payload.name,
    symbol: payload.symbol,
    description: payload.description,
    image: payload.image,
  }
  
  // Add creator if provided
  if (payload.creator) {
    metadata.creator = payload.creator
  }
  
  // Add social links if provided
  if (payload.website) metadata.website = payload.website
  if (payload.twitter) metadata.twitter = payload.twitter
  if (payload.telegram) metadata.telegram = payload.telegram
  if (payload.discord) metadata.discord = payload.discord
  
  // Add attributes section
  metadata.attributes = [
    {
      trait_type: "Platform",
      value: "SolMinter"
    }
  ]

  const res = await fetch('/api/upload-metadata', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(metadata),
  })

  if (!res.ok) {
    throw new Error(`Metadata upload failed: ${res.statusText}`)
  }

  const { cid } = await res.json()
  return `https://${process.env.NEXT_PUBLIC_PINATA_GATEWAY}/ipfs/${cid}`
}

// ===== src/services/token-service.ts =====

// src/services/token-service.ts

import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  TransactionInstruction,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  MINT_SIZE,
  createInitializeMintInstruction,
  getMinimumBalanceForRentExemptMint,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
} from "@solana/spl-token";
import type { WalletContextState } from "@solana/wallet-adapter-react";

import { getSolanaConnection } from "./wallet-service";
import {
  uploadImageToIPFS,
  uploadMetadataToIPFS,
  MetadataPayload,
} from "./ipfs-service";
import { TOKEN_METADATA_PROGRAM_ID, FEE_RECIPIENT_WALLET } from "@/config";

/** Your form data shape */
export interface FormDataType {
  name: string;
  symbol: string;
  decimals: number;
  supply: number;
  description: string;
  logo: File | null;
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
  creatorName: string;
  website: string;
  twitter: string;
  telegram: string;
  discord: string;
}

/** What we return once done */
export interface TokenResult {
  mintAddress: string;
  metadataUrl: string;
  imageUrl: string;
  explorerUrl: string;
}

/** Helper: serialize a UTF‑8 string with u32‑length prefix (LE) */
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/**
 * Helper function that correctly serializes metadata for the Metaplex createMetadataAccountV3 instruction
 */
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: PublicKey; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  // Name
  const nameBuffer = serializeString(data.name);

  // Symbol
  const symbolBuffer = serializeString(data.symbol);

  // URI
  const uriBuffer = serializeString(data.uri);

  // Seller fee basis points (u16)
  const sellerFeeBasisPointsBuffer = Buffer.alloc(2);
  sellerFeeBasisPointsBuffer.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  // Creators (Option<Vec<Creator>>)
  let creatorsBuffer;
  if (data.creators === null) {
    creatorsBuffer = Buffer.from([0]); // None
  } else {
    const creatorsVec = Buffer.concat(
      data.creators.map((creator) => {
        const address = creator.address.toBuffer();
        const verified = Buffer.from([creator.verified ? 1 : 0]);
        const share = Buffer.from([creator.share]);
        return Buffer.concat([address, verified, share]);
      })
    );

    const creatorsLength = Buffer.alloc(4);
    creatorsLength.writeUInt32LE(data.creators.length, 0);

    creatorsBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      creatorsLength,
      creatorsVec,
    ]);
  }

  // Collection (Option<Collection>)
  let collectionBuffer;
  if (data.collection === null) {
    collectionBuffer = Buffer.from([0]); // None
  } else {
    collectionBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      new PublicKey(data.collection.key).toBuffer(),
      Buffer.from([data.collection.verified ? 1 : 0]),
    ]);
  }

  // Uses (Option<Uses>)
  let usesBuffer;
  if (data.uses === null) {
    usesBuffer = Buffer.from([0]); // None
  } else {
    // Implement if needed - for now we don't use this
    usesBuffer = Buffer.from([0]); // None
  }

  // Collection Details (Option<CollectionDetails>)
  // We don't use this, so set to None
  const collectionDetailsBuffer = Buffer.from([0]);

  // isMutable
  const isMutableBuffer = Buffer.from([data.isMutable ? 1 : 0]);

  // Combine all into the expected format
  return Buffer.concat([
    nameBuffer,
    symbolBuffer,
    uriBuffer,
    sellerFeeBasisPointsBuffer,
    creatorsBuffer,
    collectionBuffer,
    usesBuffer,
    collectionDetailsBuffer,
    isMutableBuffer,
  ]);
}

/**
 * Orchestrates token creation with a single transaction
 * Network fees are deducted from the fee recipient amount, so the user pays EXACTLY the displayed fee
 */
export async function createTokenWithMetadata(
  walletAdapter: WalletContextState,
  formData: FormDataType,
  totalFee: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction, connected } = walletAdapter;
  if (!connected || !publicKey) {
    throw new Error("Wallet not connected. Please connect your wallet first.");
  }
  const connection: Connection = getSolanaConnection();

  // Validate inputs
  if (!formData.logo) {
    throw new Error("Please upload a logo image");
  }
  if (!formData.name || formData.name.trim() === "") {
    throw new Error("Token name is required");
  }
  if (!formData.symbol || formData.symbol.trim() === "") {
    throw new Error("Token symbol is required");
  }
  if (!formData.description || formData.description.trim() === "") {
    throw new Error("Token description is required");
  }

  // CRITICAL: If Revoke Update is not checked, force it to be checked
  // This is necessary because Phantom's simulation fails otherwise
  if (!formData.revokeUpdate) {
    console.warn(
      "Forcing Revoke Update to true to prevent transaction simulation failure"
    );
    formData.revokeUpdate = true;
  }

  // Make sure we have a valid fee - always ensure at least the base fee
  const minimumFeeInSOL = 0.1;
  if (totalFee < minimumFeeInSOL) {
    console.warn(
      `Fee is too low (${totalFee}), using minimum fee of ${minimumFeeInSOL} SOL`
    );
    totalFee = minimumFeeInSOL;
  }

  console.log("Creating token with fee:", totalFee, "SOL");
  console.log("Token options:", {
    revokeMint: formData.revokeMint,
    revokeFreeze: formData.revokeFreeze,
    revokeUpdate: formData.revokeUpdate,
    socialLinks: formData.socialLinks,
    creatorInfo: formData.creatorInfo,
  });

  // STEP 0: IPFS image
  onProgress?.(0);
  const imageUrl = await uploadImageToIPFS(formData.logo!);

  // STEP 1: IPFS metadata JSON
  onProgress?.(1);

  // Prepare creator info based on creatorInfo flag
  let creatorName = "SolMinter";
  if (formData.creatorInfo && formData.creatorName) {
    creatorName = formData.creatorName;
  }

  const metadataPayload: MetadataPayload = {
    name: formData.name,
    symbol: formData.symbol,
    description: formData.description,
    image: imageUrl,
    creator: creatorName,
  };

  // Only add social links if enabled
  if (formData.socialLinks) {
    metadataPayload.website = formData.website;
    metadataPayload.twitter = formData.twitter;
    metadataPayload.telegram = formData.telegram;
    metadataPayload.discord = formData.discord;
  }

  const metadataUrl = await uploadMetadataToIPFS(metadataPayload);

  // STEP 2: Prepare transaction
  onProgress?.(2);

  // Generate keypair for the new token mint
  const mintKeypair = Keypair.generate();
  const rentExempt = await getMinimumBalanceForRentExemptMint(connection);

  // Start building the transaction
  const instructions: TransactionInstruction[] = [];

  // First, add the fee payment instruction to ensure it's always included
  const feeWalletPubkey = new PublicKey(FEE_RECIPIENT_WALLET);
  const feeAmountInLamports = totalFee * LAMPORTS_PER_SOL;

  console.log(
    `Adding fee payment of ${totalFee} SOL to ${FEE_RECIPIENT_WALLET}`
  );

  const feeInstruction = SystemProgram.transfer({
    fromPubkey: publicKey,
    toPubkey: feeWalletPubkey,
    lamports: feeAmountInLamports,
  });

  instructions.push(feeInstruction);

  // Add mint account creation
  instructions.push(
    SystemProgram.createAccount({
      fromPubkey: publicKey,
      newAccountPubkey: mintKeypair.publicKey,
      space: MINT_SIZE,
      lamports: rentExempt,
      programId: TOKEN_PROGRAM_ID,
    })
  );

  // Initialize mint
  instructions.push(
    createInitializeMintInstruction(
      mintKeypair.publicKey,
      formData.decimals,
      publicKey,
      publicKey,
      TOKEN_PROGRAM_ID
    )
  );

  // Create Associated Token Account
  const ata = await getAssociatedTokenAddress(mintKeypair.publicKey, publicKey);

  instructions.push(
    createAssociatedTokenAccountInstruction(
      publicKey,
      ata,
      publicKey,
      mintKeypair.publicKey
    )
  );

  // Mint tokens to ATA
  const mintAmount = BigInt(formData.supply) * BigInt(10 ** formData.decimals);
  instructions.push(
    createMintToInstruction(mintKeypair.publicKey, ata, publicKey, mintAmount)
  );

  // STEP 4: Create metadata
  onProgress?.(4);
  // derive metadata PDA
  const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
  const [metadataPDA] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("metadata"),
      metadataProgramId.toBuffer(),
      mintKeypair.publicKey.toBuffer(),
    ],
    metadataProgramId
  );

  // Create metadata creators array if custom creator is specified
  let creators = null;
  if (formData.creatorInfo) {
    creators = [
      {
        address: publicKey,
        verified: true,
        share: 100,
      },
    ];
  }

  // Add metadata creation instruction
  instructions.push({
    programId: metadataProgramId,
    keys: [
      { pubkey: metadataPDA, isSigner: false, isWritable: true },
      { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
      { pubkey: publicKey, isSigner: true, isWritable: false }, // mint authority
      { pubkey: publicKey, isSigner: true, isWritable: false }, // payer
      { pubkey: publicKey, isSigner: false, isWritable: false }, // update authority
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ],
    data: Buffer.concat([
      Buffer.from([33]), // createMetadataAccountV3 discriminator
      serializeMetadataV3({
        name: formData.name,
        symbol: formData.symbol,
        uri: metadataUrl,
        sellerFeeBasisPoints: 0,
        creators: creators,
        collection: null,
        uses: null,
        isMutable: false, 
      }),
    ]),
  });

  // STEP 5: Add authority revocation instructions (optional)
  onProgress?.(5);

  if (formData.revokeMint) {
    instructions.push(
      createSetAuthorityInstruction(
        mintKeypair.publicKey,
        publicKey,
        AuthorityType.MintTokens,
        null,
        [],
        TOKEN_PROGRAM_ID
      )
    );
  }

  if (formData.revokeFreeze) {
    instructions.push(
      createSetAuthorityInstruction(
        mintKeypair.publicKey,
        publicKey,
        AuthorityType.FreezeAccount,
        null,
        [],
        TOKEN_PROGRAM_ID
      )
    );
  }

  // Create the transaction
  const transaction = new Transaction();

  // Add all instructions
  instructions.forEach((instruction) => {
    transaction.add(instruction);
  });

  // Set fee payer and blockhash
  transaction.feePayer = publicKey;
  transaction.recentBlockhash = (
    await connection.getLatestBlockhash()
  ).blockhash;

  // Sign with the mint keypair
  transaction.partialSign(mintKeypair);

  try {
    // Sign with the wallet and send
    console.log("Sending transaction to wallet for approval...");
    const signedTransaction = await signTransaction!(transaction);
    console.log("Transaction signed, submitting to network...");
    const txSignature = await connection.sendRawTransaction(
      signedTransaction.serialize()
    );
    console.log("Transaction submitted, signature:", txSignature);
    console.log("Waiting for confirmation...");
    await connection.confirmTransaction(txSignature);
    console.log("Transaction confirmed successfully!");
  } catch (error: unknown) {
    console.error("Transaction error:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to process transaction: ${errorMessage}`);
  }

  // Done ✅
  const clusterParam =
    process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
      ? "?cluster=devnet"
      : "";

  return {
    mintAddress: mintKeypair.publicKey.toString(),
    metadataUrl,
    imageUrl,
    explorerUrl: `https://explorer.solana.com/address/${mintKeypair.publicKey.toString()}${clusterParam}`,
  };
}


// ===== src/services/fee-service.ts =====

// src/services/fee-service.ts

export interface FeeOptions {
  revokeMint: boolean
  revokeFreeze: boolean
  revokeUpdate: boolean
  socialLinks: boolean
  creatorInfo: boolean
}

// Base fee plus optional feature fees
export function calculateFee(options: FeeOptions): number {
  let fee = 0.1; // Base fee for token creation - corrected to 0.1

  // Add fee for each enabled feature
  if (options.revokeMint)    fee += 0.1;
  if (options.revokeFreeze)  fee += 0.1;
  if (options.revokeUpdate)  fee += 0.1;
  if (options.socialLinks)   fee += 0.1;
  if (options.creatorInfo)   fee += 0.1;

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

// Format the fee for display
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

// ===== src/services/wallet-service.ts =====

// src/services/wallet-service.ts
import { WalletAdapter } from '@solana/wallet-adapter-base';
import { Connection, clusterApiUrl, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Get the Solana connection based on the configured network
export const getSolanaConnection = (): Connection => {
  const network = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
  return new Connection(clusterApiUrl(network), 'confirmed');
};

// Check if wallet is properly connected
export const isWalletConnected = (wallet: any): boolean => {
    // Debug log to help diagnose issues
    console.log("Wallet connection check:", {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false
    });
    
    // For some wallets, adapter.connected might not be reliable
    // Consider a wallet connected if it has a wallet object and a public key
    return !!wallet && !!wallet.publicKey;
  };

// Get the wallet's SOL balance
export const getWalletBalance = async (publicKey: PublicKey): Promise<number> => {
  try {
    const connection = getSolanaConnection();
    const balance = await connection.getBalance(publicKey);
    console.log(`Wallet balance: ${balance / 1_000_000_000} SOL`);
    return balance / 1_000_000_000; // Convert lamports to SOL
  } catch (error) {
    console.error('Error getting wallet balance:', error);
    return 0;
  }
};

// Format the wallet address for display
export const formatWalletAddress = (address: string): string => {
  if (!address || address.length < 10) return address;
  return `${address.slice(0, 4)}...${address.slice(-4)}`;
};

// Get the Solana explorer URL for a transaction or address
export const getExplorerUrl = (addressOrSignature: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${addressOrSignature}${network}`;
};

