// ===== next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// ===== next.config.ts =====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


// ===== src/middleware.ts =====

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// This middleware ensures CORS headers are properly set for API routes
export function middleware(request: NextRequest) {
  // Only apply to /api routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    // Handle OPTIONS requests for CORS preflight
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        },
      });
    }

    // Add CORS headers to all responses
    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return response;
  }

  return NextResponse.next();
}

// Configure which routes the middleware applies to
export const config = {
  matcher: '/api/:path*',
};

// ===== src/types/env.d.ts =====

// src/types/env.d.ts

declare namespace NodeJS {
  interface ProcessEnv {
    // Solana Network settings
    NEXT_PUBLIC_SOLANA_NETWORK: "devnet" | "mainnet-beta";

    // Fee recipient wallet address
    NEXT_PUBLIC_FEE_WALLET: string;

    // Pinata IPFS settings
    NEXT_PUBLIC_PINATA_GATEWAY: string;
    PINATA_JWT: string;

    // Solana network fee
    NEXT_PUBLIC_SOLANA_NETWORK_FEE: string;

    REVOKE_UPDATE_PRIVATE_KEY: string;
  }
}


// ===== src/types/token.ts =====

// Update or create this in a shared location like src/types/token.ts

export interface FormDataType {
  name: string;
  symbol: string;
  decimals: number;
  supply: number;
  description: string;
  logo: File | null;
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
  creatorName: string; // Added for Creator's Info
  website: string;
  twitter: string;
  telegram: string;
  discord: string;
}

export interface TokenResult {
  mintAddress: string;
  metadataUrl: string;
  imageUrl: string;
  explorerUrl: string;
}

// New interface for minted token information retrieved from Pinata/IPFS
export interface MintedTokenInfo {
  name: string;
  symbol: string;
  description?: string;
  image?: string;
  imageUrl?: string; // Alternative property name for image
  mintAddress: string;
  mint?: string;     // Alternative property name for mintAddress
  creator?: string;
  metadataUrl?: string;
  pinHash?: string;
  
  // Social links
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  
  // Token information
  tokenInfo?: {
    chain?: string;
    totalSupply: number;
    circulatingSupply?: number;
    decimals: number;
  };
  
  // Authority status
  authorities?: {
    mintRevoked: boolean;
    freezeRevoked: boolean;
    updateRevoked: boolean;
  };
  
  // Session tracking
  sessionUuid?: string;
  createdOn?: string;
}

// ===== src/app/my-tokens/page.tsx =====

// src/app/my-tokens/page.tsx

"use client";

import { useEffect, useState, useCallback } from "react";
import { useWallet } from "@solana/wallet-adapter-react";
import WalletRequired from "@/components/wallet/wallet-required";
import TokenList from "@/components/token/token-list";
import Loading from "@/components/ui/loading";
import NoTokensFound from "@/components/token/no-tokens-found";
import TokenErrorState from "@/components/token/token-error-state";
import { TokenSkeletonList } from "@/components/token/token-skeleton";
import { getUserMintedTokens } from "@/services/token-discovery-service";
import { MintedTokenInfo } from "@/types/token";

export default function MyTokensPage() {
  const { connected, publicKey } = useWallet();
  const [tokens, setTokens] = useState<MintedTokenInfo[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUserTokens = useCallback(async () => {
    if (!connected || !publicKey) return;

    try {
      setLoading(true);
      setError(null);

      const userTokens = await getUserMintedTokens(publicKey.toString());
      setTokens(userTokens);
    } catch (err) {
      console.error("Error fetching user tokens:", err);
      setError("Failed to fetch your minted tokens. Please try again later.");
    } finally {
      setLoading(false);
    }
  }, [connected, publicKey]);

  useEffect(() => {
    fetchUserTokens();
  }, [fetchUserTokens]);

  if (!connected) {
    return (
      <div className="min-h-screen">
        <WalletRequired message="Connect your wallet to see your minted tokens" />
      </div>
    );
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16 text-center">
          <h1 className="text-4xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Discovering Your Tokens
            </span>
          </h1>
          {/* Just show the skeleton loaders—no cancel or retry here */}
          <TokenSkeletonList />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          {/* Only the error component handles retry */}
          <TokenErrorState message={error} onRetry={fetchUserTokens} />
        </div>
      </div>
    );
  }

  if (tokens.length === 0) {
    return <NoTokensFound />;
  }

  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <h1 className="text-4xl font-bold text-center mb-6">
          <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
            My Minted Tokens
          </span>
        </h1>
        <p className="text-center text-gray-400 mb-6">
          View and manage all tokens you've created with SolMinter
        </p>
        <TokenList tokens={tokens} />
      </div>
    </div>
  );
}


// ===== src/app/guides/page.tsx =====

export default function Guides() {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          <h1 className="text-4xl font-bold text-center mb-10">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Guides & Resources
            </span>
          </h1>
          
          <div className="space-y-12">
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">How to Create a Solana Token</h2>
              <div className="prose prose-invert max-w-none">
                <ol className="list-decimal pl-5 space-y-4">
                  <li>
                    <strong>Connect Your Wallet</strong>
                    <p className="text-gray-400">
                      Click the "Connect Wallet" button in the top right corner and connect your Phantom, Solflare, or other compatible Solana wallet.
                    </p>
                  </li>
                  <li>
                    <strong>Fill in Token Details</strong>
                    <p className="text-gray-400">
                      Enter your token's name, symbol, supply, and other details. Upload a logo image (1000x1000px recommended).
                    </p>
                  </li>
                  <li>
                    <strong>Configure Token Options</strong>
                    <p className="text-gray-400">
                      Choose whether to include social links and creator information. Select which authorities to revoke (recommended for investor trust).
                    </p>
                  </li>
                  <li>
                    <strong>Launch Your Token</strong>
                    <p className="text-gray-400">
                      Click "Launch Token" and approve the transaction in your wallet. Your token will be created on the Solana blockchain.
                    </p>
                  </li>
                  <li>
                    <strong>Create Liquidity</strong>
                    <p className="text-gray-400">
                      After creating your token, consider setting up a liquidity pool on Raydium or another Solana DEX to make your token tradable.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">Token Authorities Explained</h2>
              <div className="prose prose-invert max-w-none">
                <p className="text-gray-400">
                  Solana tokens have three types of authorities that control different aspects of the token:
                </p>
                <ul className="list-disc pl-5 space-y-3 mt-4">
                  <li>
                    <strong>Mint Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to create (mint) new tokens. Revoking this authority creates a fixed supply token that cannot be inflated.
                    </p>
                  </li>
                  <li>
                    <strong>Freeze Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to freeze token accounts, preventing transfers. Revoking this ensures no one can freeze holders' tokens.
                    </p>
                  </li>
                  <li>
                    <strong>Update Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to modify token metadata (name, symbol, image, etc.). Revoking makes the token's metadata immutable.
                    </p>
                  </li>
                </ul>
                <p className="text-gray-400 mt-4">
                  For maximum credibility with your community, we recommend revoking all authorities.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

// ===== src/app/create-token/page.tsx =====

import TokenForm from '@/components/token/token-form';

export default function CreateToken() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <TokenForm />
    </div>
  );
}

// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Navbar from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SolMinter - Create Solana Tokens Easily",
  description: "Create, launch, and manage Solana tokens with ease. Your one-stop solution for Solana meme coin creation.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link 
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" 
          rel="stylesheet"
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0a0a0a] text-white`}
      >
        <Providers>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            {/* Add padding-top to main content to account for the fixed navbar */}
            <main className="flex-grow pt-24">{children}</main>
            <Footer />
          </div>
        </Providers>
      </body>
    </html>
  );
}

// ===== src/app/api/upload-metadata/route.ts =====

// src/app/api/upload-metadata/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the metadata from the request body
    const { metadata, fileName, pinataMetadata: customPinataMetadata } = await request.json();
    
    // Use the provided filename or create a default one
    const actualFileName = fileName || 'metadata.json';
    
    console.log("Received metadata for:", metadata.name);
    console.log("Using filename:", actualFileName);
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Prepare pinata options and metadata
      const options = {
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      };
      
      // Create pinata metadata - either use the custom one passed or create a default
      const pinataMetadata = customPinataMetadata || {
        name: actualFileName,
        keyvalues: {
          app: "SolMinter",
          type: "token_metadata",
          symbol: metadata.symbol,
          timestamp: Date.now().toString()
        }
      };
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: JSON.stringify({
          pinataOptions: options,
          pinataMetadata: pinataMetadata,
          pinataContent: metadata
        })
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway,
        fileName: actualFileName
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud',
      fileName: actualFileName
    });
  } catch (error) {
    console.error('Error uploading metadata:', error);
    return NextResponse.json(
      { error: 'Failed to upload metadata' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/update-authority/route.ts =====

// src/app/api/update-authority/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Keypair } from '@solana/web3.js';

/**
 * API route that securely provides the public key of the update authority
 * This keeps the private key on the server side
 */
export async function GET(request: NextRequest) {
  try {
    // Get the private key from environment variables
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updateAuthorityPrivateKey) {
      console.error("REVOKE_UPDATE_PRIVATE_KEY is not set in environment variables");
      return NextResponse.json(
        { 
          success: false, 
          error: "Update authority not configured",
          message: "Server environment is not properly configured for update authority revocation."
        },
        { status: 500 }
      );
    }
    
    try {
      // Decode the base58-encoded private key to generate keypair
      const secretKey = bs58.decode(updateAuthorityPrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      
      // Return only the public key
      return NextResponse.json({
        success: true,
        updateAuthorityPublicKey: updateAuthorityKeypair.publicKey.toString()
      });
    } catch (error) {
      console.error("Error creating update authority keypair:", error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid update authority key format",
          message: "Server has an invalid private key format."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error accessing update authority:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Server error", 
        message: "An unexpected error occurred while accessing the update authority."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/sign-transaction/route.ts =====

// src/app/api/sign-transaction/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import {
  Transaction,
  Keypair,
  PublicKey,
  SystemProgram,
  Connection,
  clusterApiUrl
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  createInitializeMintInstruction,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint
} from "@solana/spl-token";
import { TOKEN_METADATA_PROGRAM_ID, SOLANA_NETWORK } from '@/config';

/** Helper: serialize a UTF‑8 string with u32‑length prefix (LE) */
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/** Helper: serialize metadata for Metaplex createMetadataAccountV3 */
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: PublicKey; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  const nameBuff   = serializeString(data.name);
  const symbolBuff = serializeString(data.symbol);
  const uriBuff    = serializeString(data.uri);

  const feeBuff = Buffer.alloc(2);
  feeBuff.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  let creatorsBuff: Buffer;
  if (!data.creators) {
    creatorsBuff = Buffer.from([0]);
  } else {
    const vec = Buffer.concat(
      data.creators.map(c => Buffer.concat([
        c.address.toBuffer(),
        Buffer.from([c.verified ? 1 : 0]),
        Buffer.from([c.share])
      ]))
    );
    const len = Buffer.alloc(4);
    len.writeUInt32LE(data.creators.length, 0);
    creatorsBuff = Buffer.concat([Buffer.from([1]), len, vec]);
  }

  const collectionBuff = data.collection
    ? Buffer.concat([
        Buffer.from([1]),
        new PublicKey(data.collection.key).toBuffer(),
        Buffer.from([data.collection.verified ? 1 : 0])
      ])
    : Buffer.from([0]);

  const usesBuff              = Buffer.from([0]);
  const collectionDetailsBuff = Buffer.from([0]);
  const isMutableBuff         = Buffer.from([data.isMutable ? 1 : 0]);

  return Buffer.concat([
    nameBuff,
    symbolBuff,
    uriBuff,
    feeBuff,
    creatorsBuff,
    collectionBuff,
    usesBuff,
    collectionDetailsBuff,
    isMutableBuff,
  ]);
}

export async function POST(request: NextRequest) {
  try {
    const {
      mintPrivateKey,
      metadataUrl,
      tokenName,
      tokenSymbol,
      tokenDecimals,
      tokenSupply,
      payerPublicKey,
      hasCreators,
      revokeUpdate,
      revokeMint,
      revokeFreeze,
      recentBlockhash,
      feeWalletPubkey,
      feeAmountInLamports,
      includeFeeTx = false
    } = await request.json();

    // Validate required fields...
    if (!mintPrivateKey || !metadataUrl || !tokenName || !tokenSymbol || !payerPublicKey) {
      return NextResponse.json({ error: "Missing required transaction data" }, { status: 400 });
    }

    // Server‐side update authority key
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    if (revokeUpdate && !updateAuthorityPrivateKey) {
      return NextResponse.json({ error: "Update authority not configured on server" }, { status: 500 });
    }

    const network    = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
    const connection = new Connection(clusterApiUrl(network));

    // Reconstruct the mint keypair
    const mintSecret  = Buffer.from(mintPrivateKey, 'base64');
    const mintKeypair = Keypair.fromSecretKey(new Uint8Array(mintSecret));

    // Choose update authority keypair
    let updateAuthorityKeypair: Keypair;
    if (revokeUpdate) {
      const serverSecret = bs58.decode(updateAuthorityPrivateKey!);
      updateAuthorityKeypair = Keypair.fromSecretKey(serverSecret);
    } else {
      updateAuthorityKeypair = mintKeypair;
    }

    const payer = new PublicKey(payerPublicKey);

    // Build the transaction
    const transaction = new Transaction();
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer       = payer;

    // Optional fee transfer
    if (includeFeeTx && feeWalletPubkey && feeAmountInLamports > 0) {
      transaction.instructions.unshift(
        SystemProgram.transfer({
          fromPubkey: payer,
          toPubkey: new PublicKey(feeWalletPubkey),
          lamports: feeAmountInLamports,
        })
      );
    }

    // Rent‐exempt mint account creation & initialization
    const rentExempt = await getMinimumBalanceForRentExemptMint(connection);
    transaction.add(
      SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: mintKeypair.publicKey,
        space: MINT_SIZE,
        lamports: rentExempt,
        programId: TOKEN_PROGRAM_ID,
      })
    );
    transaction.add(
      createInitializeMintInstruction(
        mintKeypair.publicKey,
        tokenDecimals,
        payer,
        payer,
        TOKEN_PROGRAM_ID
      )
    );

    // Associated Token Account & minting
    const ata = await getAssociatedTokenAddress(mintKeypair.publicKey, payer);
    transaction.add(
      createAssociatedTokenAccountInstruction(
        payer,
        ata,
        payer,
        mintKeypair.publicKey
      )
    );
    const mintAmount = BigInt(tokenSupply) * BigInt(10 ** tokenDecimals);
    transaction.add(
      createMintToInstruction(
        mintKeypair.publicKey,
        ata,
        payer,
        mintAmount
      )
    );

    // Metadata PDA
    const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        metadataProgramId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      metadataProgramId
    );

    // **1.** Prepare creators array - IMPORTANT FIX: Always include creators
    // The payer (wallet owner) must be the creator, but with verified=false
    // They will sign the transaction later, which implicitly verifies them
    const creators = [
      {
        address: payer,
        verified: false,  // CRITICAL FIX: Set verified to false since the server can't verify on behalf of the user
        share: 100,
      }
    ];

    // **2.** Create Metadata instruction
    transaction.add({
      programId: metadataProgramId,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
        { pubkey: payer, isSigner: true, isWritable: false },                // mint authority
        { pubkey: payer, isSigner: true, isWritable: false },                // payer
        { pubkey: updateAuthorityKeypair.publicKey, isSigner: true, isWritable: false }, // update authority
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data: Buffer.concat([
        Buffer.from([33]), // createMetadataAccountV3 discriminator
        serializeMetadataV3({
          name: tokenName,
          symbol: tokenSymbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators,  // Always include creators
          collection: null,
          uses: null,
          isMutable: !revokeUpdate,
        }),
      ]),
    });

    // **3.** Optional authority revocations
    if (revokeMint) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.MintTokens,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }
    if (revokeFreeze) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.FreezeAccount,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    // **4.** Sign with server key if revoking update authority
    if (revokeUpdate) {
      console.log("Signing with server update authority:", updateAuthorityKeypair.publicKey.toString());
      transaction.partialSign(updateAuthorityKeypair);
    }

    // Always sign with the mint keypair
    console.log("Signing with mint keypair:", mintKeypair.publicKey.toString());
    transaction.partialSign(mintKeypair);

    // **5.** Serialize and return for wallet to sign & send
    const serialized = transaction.serialize({ requireAllSignatures: false });
    const b64 = Buffer.from(serialized).toString('base64');

    return NextResponse.json({
      success: true,
      signedTransaction: b64,
      updateAuthority: updateAuthorityKeypair.publicKey.toString(),
      mintAddress: mintKeypair.publicKey.toString(),
    });

  } catch (error) {
    console.error("Error in sign-transaction:", error);
    return NextResponse.json(
      { error: `Failed to sign transaction: ${error instanceof Error ? error.message : error}` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upload-image/route.ts =====

// src/app/api/upload-image/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const fileName = formData.get('fileName') as string; // Get the custom file name
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    console.log("Received file:", fileName || file.name, "Size:", file.size, "Type:", file.type);
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Create a FormData object to send to Pinata
      const pinataFormData = new FormData();
      
      // If we have a custom fileName, create a new File object with that name
      if (fileName) {
        const newFile = new File([file], fileName, { type: file.type });
        pinataFormData.append('file', newFile);
      } else {
        pinataFormData.append('file', file);
      }
      
      // Add pin options as metadata
      const pinOptions = JSON.stringify({
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      });
      pinataFormData.append('pinataOptions', pinOptions);
      
      // Add metadata
      const metadata = JSON.stringify({
        name: fileName || file.name,
        keyvalues: {
          app: "SolMinter",
          type: "token_image",
          timestamp: Date.now().toString()
        }
      });
      pinataFormData.append('pinataMetadata', metadata);
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: pinataFormData
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway,
        fileName: fileName || file.name // Return the filename used
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud',
      fileName: fileName || file.name // Return the filename used
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/create-token/route.ts =====

// src/app/api/create-token/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Connection, Keypair, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// This API endpoint is for validating the environment is correctly set up
// We don't actually create tokens here - that happens client-side
// But we confirm the update authority keypair is valid
export async function GET(request: NextRequest) {
  try {
    // Check if the required environment variable is present
    const updatePrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updatePrivateKey) {
      return NextResponse.json(
        { 
          ok: false, 
          error: "Update authority private key is not configured",
          message: "The server is not properly configured for revoking update authority. Please check server configuration."
        },
        { status: 500 }
      );
    }
    
    // Try to create a keypair from the private key
    try {
      const secretKey = bs58.decode(updatePrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      const updateAuthorityPublicKey = updateAuthorityKeypair.publicKey.toString();
      
      // Return a redacted version of the public key for confirmation
      const redactedPublicKey = `${updateAuthorityPublicKey.substring(0, 4)}...${updateAuthorityPublicKey.substring(updateAuthorityPublicKey.length - 4)}`;
      
      return NextResponse.json({ 
        ok: true, 
        message: "Update authority configuration is valid", 
        updateAuthority: redactedPublicKey,
        network: SOLANA_NETWORK
      });
    } catch (error) {
      console.error("Error validating update authority keypair:", error);
      return NextResponse.json(
        { 
          ok: false, 
          error: "Invalid update authority key format",
          message: "The server has an incorrectly formatted update authority key."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error in update authority validation:", error);
    return NextResponse.json(
      { 
        ok: false, 
        error: "Server error", 
        message: "An unexpected error occurred while validating the server configuration."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/delete-pinata-files/route.ts =====

// src/app/api/delete-pinata-files/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { uuid } = await request.json();
    
    if (!uuid) {
      return NextResponse.json(
        { error: 'UUID parameter is required' },
        { status: 400 }
      );
    }
    
    console.log(`Attempting to delete Pinata files with UUID: ${uuid}`);
    
    // Get Pinata credentials from environment variables
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    if (!pinataJWT) {
      console.warn('No Pinata JWT found in environment variables');
      return NextResponse.json(
        { error: 'Pinata API credentials not configured' },
        { status: 500 }
      );
    }
    
    // First, we need to get a list of all files
    const searchResponse = await fetch('https://api.pinata.cloud/data/pinList?status=pinned', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${pinataJWT}`
      }
    });
    
    if (!searchResponse.ok) {
      const searchError = await searchResponse.text();
      console.error('Error fetching pin list from Pinata:', searchError);
      return NextResponse.json(
        { error: `Failed to fetch file list from Pinata: ${searchError}` },
        { status: 500 }
      );
    }
    
    const pinListData = await searchResponse.json();
    
    // Find pins containing the UUID in their keyvalues metadata
    // @ts-ignore
    const pinsToDelete = pinListData.rows.filter(pin => {
      // Look for UUID in Pinata metadata keyvalues.sessionUuid
      const metadataMatch = pin.metadata?.keyvalues?.sessionUuid === uuid;
      // Also check in the name as a fallback in case keyvalues aren't used
      const nameMatch = pin.metadata?.name && pin.metadata.name.includes(uuid);
      
      return metadataMatch || nameMatch;
    });
    
    console.log(`Found ${pinsToDelete.length} files containing UUID: ${uuid}`);
    
    // Track deletion results
    const deletionResults = [];
    
    // Delete each matching pin
    for (const pin of pinsToDelete) {
      try {
        const deleteResponse = await fetch(`https://api.pinata.cloud/pinning/unpin/${pin.ipfs_pin_hash}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${pinataJWT}`
          }
        });
        
        if (deleteResponse.ok) {
          console.log(`Successfully deleted: ${pin.ipfs_pin_hash} (${pin.metadata?.name || 'unnamed'})`);
          deletionResults.push({
            cid: pin.ipfs_pin_hash,
            name: pin.metadata?.name || 'unnamed',
            status: 'deleted'
          });
        } else {
          const deleteError = await deleteResponse.text();
          console.error(`Failed to delete ${pin.ipfs_pin_hash}:`, deleteError);
          deletionResults.push({
            cid: pin.ipfs_pin_hash,
            name: pin.metadata?.name || 'unnamed',
            status: 'error',
            error: deleteError
          });
        }
      } catch (error) {
        console.error(`Error deleting ${pin.ipfs_pin_hash}:`, error);
        deletionResults.push({
          cid: pin.ipfs_pin_hash,
          name: pin.metadata?.name || 'unnamed',
          status: 'error',
          error: String(error)
        });
      }
    }
    
    return NextResponse.json({ 
      success: true, 
      message: `Deletion process completed for UUID: ${uuid}`,
      deletedCount: deletionResults.filter(r => r.status === 'deleted').length,
      errorCount: deletionResults.filter(r => r.status === 'error').length,
      details: deletionResults
    });
    
  } catch (error) {
    console.error('Error in delete-pinata-files endpoint:', error);
    return NextResponse.json(
      { error: 'Failed to process deletion request', details: String(error) },
      { status: 500 }
    );
  }
}

// ===== src/app/api/user-tokens/route.ts =====

// src/app/api/user-tokens/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { MintedTokenInfo } from '@/types/token';

export async function GET(request: NextRequest) {
  try {
    // Get the wallet public key from the query parameters
    const url = new URL(request.url);
    const publicKey = url.searchParams.get('publicKey');
    
    if (!publicKey) {
      return NextResponse.json(
        { error: 'Public key is required' },
        { status: 400 }
      );
    }
    
    console.log(`Searching for tokens minted by: ${publicKey}`);
    
    // Get Pinata credentials from environment variables
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    if (!pinataJWT) {
      console.warn('No Pinata JWT found in environment variables');
      return NextResponse.json(
        { error: 'Pinata API credentials not configured' },
        { status: 500 }
      );
    }
    
    // Build the search query for Pinata - find files that contain the public key
    // but exclude files with 'image' or 'metadata' in their name
    const searchResponse = await fetch('https://api.pinata.cloud/data/pinList?status=pinned', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${pinataJWT}`
      }
    });
    
    if (!searchResponse.ok) {
      const searchError = await searchResponse.text();
      console.error('Error fetching pin list from Pinata:', searchError);
      return NextResponse.json(
        { error: `Failed to search Pinata: ${searchError}` },
        { status: 500 }
      );
    }
    
    const pinListData = await searchResponse.json();
    
    // Filter pins to find the token metadata files:
    // 1. Contains the user's public key in the name 
    // 2. Does NOT contain 'metadata' or 'image' in the name
    // These should be the final token metadata files with the format: {public-key_token-id}
    const userTokenPins = pinListData.rows.filter((pin: any) => {
      const nameContainsPublicKey = pin.metadata?.name && pin.metadata.name.includes(publicKey);
      const isNotTempMetadata = pin.metadata?.name && 
        !pin.metadata.name.includes('metadata') && 
        !pin.metadata.name.includes('image');
      
      return nameContainsPublicKey && isNotTempMetadata;
    });
    
    console.log(`Found ${userTokenPins.length} tokens for wallet: ${publicKey}`);
    
    // For each pin, fetch and parse the token metadata
    const tokens: MintedTokenInfo[] = await Promise.all(
      userTokenPins.map(async (pin: any) => {
        try {
          const ipfsUrl = `https://${pinataGateway}/ipfs/${pin.ipfs_pin_hash}`;
          const response = await fetch(ipfsUrl);
          
          if (!response.ok) {
            console.error(`Failed to fetch metadata from ${ipfsUrl}`);
            return null;
          }
          
          const metadata = await response.json();
          
          // Fix for image URL - make sure we preserve the actual image URL
          const imageUrl = metadata.image || null;
          
          // Structure the token data
          return {
            name: metadata.name,
            symbol: metadata.symbol,
            description: metadata.description,
            mintAddress: metadata.mint || '',
            imageUrl: imageUrl, // Use the actual image URL 
            creator: metadata.creator,
            tokenInfo: metadata.tokenInfo,
            authorities: metadata.authorities,
            website: metadata.website,
            twitter: metadata.twitter,
            telegram: metadata.telegram,
            discord: metadata.discord,
            metadataUrl: ipfsUrl,
            pinHash: pin.ipfs_pin_hash,
          } as MintedTokenInfo;
        } catch (err) {
          console.error(`Error processing pin ${pin.ipfs_pin_hash}:`, err);
          return null;
        }
      })
    );
    
    // Filter out any null entries from errors
    const validTokens = tokens.filter(token => token !== null) as MintedTokenInfo[];
    
    return NextResponse.json({
      success: true,
      count: validTokens.length,
      tokens: validTokens
    });
    
  } catch (error) {
    console.error('Error in user-tokens API:', error);
    return NextResponse.json(
      { error: 'Failed to retrieve user tokens', details: String(error) },
      { status: 500 }
    );
  }
}

// ===== src/app/page.tsx =====

import CTASection from "@/components/home/cta-section";
import FeaturesSection from "@/components/home/features-section";
import HeroSection from "@/components/home/hero-section";
import HowItWorksSection from "@/components/home/how-it-works-section";

export default function Home() {
  return (
    <div className="bg-[#0a0a0a] overflow-hidden">
      <HeroSection />
      <FeaturesSection />
      <HowItWorksSection />
      <CTASection />
    </div>
  );
}

// ===== src/app/providers.tsx =====

'use client';

import { ReactNode, useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Create a client-only wrapper component
const WalletConnectionProvider = ({ children }: { children: ReactNode }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return <>{children}</>;
};

// Dynamically import the wallet components with ssr: false
const ClientWalletProvider = dynamic(
  () => import('../components/wallet/wallet-provider-client').then(module => module.ClientWalletProvider),
  {
    ssr: false,
    loading: () => <WalletConnectionProvider><div>{/* Loading placeholder */}</div></WalletConnectionProvider>
  }
);

export function Providers({ children }: { children: ReactNode }) {
  return (
    <ClientWalletProvider>
      {children}
    </ClientWalletProvider>
  );
}

// ===== src/config/ipfs.ts =====

// src/config/ipfs.ts

/**
 * Configuration for IPFS and Pinata services
 */

// IPFS Gateway configuration
export const IPFS_CONFIG = {
    // Default gateway to use (fallback if environment variable is not set)
    DEFAULT_GATEWAY: 'gateway.pinata.cloud',
    
    // The gateway to use from environment variables or fallback
    GATEWAY: process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud',
    
    // Whether we have proper Pinata credentials (JWT token)
    HAS_PINATA_CREDENTIALS: !!process.env.PINATA_JWT,
    
    // Pinata API endpoints
    PINATA_API: {
      UPLOAD_FILE: 'https://api.pinata.cloud/pinning/pinFileToIPFS',
      UPLOAD_JSON: 'https://api.pinata.cloud/pinning/pinJSONToIPFS',
      REMOVE_PIN: 'https://api.pinata.cloud/pinning/unpin',
    },
    
    // Default pin policy for geographical redundancy
    DEFAULT_PIN_POLICY: {
      regions: [
        {
          id: 'FRA1',
          desiredReplicationCount: 1
        },
        {
          id: 'NYC1',
          desiredReplicationCount: 1
        }
      ]
    }
  };
  
  /**
   * Get the complete IPFS URL with gateway
   * @param cid The IPFS CID
   * @returns Full gateway URL
   */
  export function getIpfsUrl(cid: string): string {
    return `https://${IPFS_CONFIG.GATEWAY}/ipfs/${cid}`;
  }
  
  /**
   * Check if we have proper Pinata credentials
   */
  export function hasPinataCredentials(): boolean {
    return IPFS_CONFIG.HAS_PINATA_CREDENTIALS;
  }

// ===== src/config/index.ts =====

// src/config/index.ts

// Solana network configuration
export const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

// Fee recipient wallet - address that will receive token creation fees
export const FEE_RECIPIENT_WALLET = process.env.NEXT_PUBLIC_FEE_WALLET || '8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt';

// Solana network fee in SOL - this amount is subtracted from the total fee
export const SOLANA_NETWORK_FEE = parseFloat(process.env.NEXT_PUBLIC_SOLANA_NETWORK_FEE || '0.01862');

// IPFS/Pinata configuration
export const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
export const PINATA_API_KEY = process.env.NEXT_PUBLIC_PINATA_API_KEY;
export const PINATA_SECRET_KEY = process.env.NEXT_PUBLIC_PINATA_SECRET_KEY;

// Token creation fees (in SOL)
export const TOKEN_FEES = {
  BASE_FEE: 0.2,  // Base fee for token creation
  AUTHORITY_FEE: 0.1, // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MAX_FEE: 0.3 // Maximum fee (capped for discount)
};

// Default token configuration
export const DEFAULT_TOKEN_CONFIG = {
  decimals: 9,
  supply: 1000000000, // 1 billion
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true
};

// Explorer URL generator
export const getExplorerUrl = (address: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK;
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${address}${network === 'devnet' ? '?cluster=devnet' : ''}`;
};

// Metaplex Token Metadata Program ID (constant across all Solana networks)
// UPDATED: This is the correct Metaplex Token Metadata Program ID
export const TOKEN_METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Program ID for the SPL Token Program
export const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';

// ===== src/utils/ipfs-utils.ts =====

// src/utils/ipfs-utils.ts

/**
 * Utility functions for working with IPFS and Pinata
 */

/**
 * Extracts the CID from an IPFS URL
 */
export function extractCidFromUrl(ipfsUrl: string): string | null {
    try {
      if (ipfsUrl.includes('/ipfs/')) {
        // Format: https://gateway.domain/ipfs/CID
        return ipfsUrl.split('/ipfs/')[1];
      } else if (ipfsUrl.startsWith('ipfs://')) {
        // Format: ipfs://CID
        return ipfsUrl.replace('ipfs://', '');
      }
      return null;
    } catch (error) {
      console.error('Error extracting CID from URL:', error);
      return null;
    }
  }
  
  /**
   * Converts an IPFS URL to use a specific gateway
   */
  export function convertToGatewayUrl(
    ipfsUrl: string, 
    gateway: string = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud'
  ): string {
    const cid = extractCidFromUrl(ipfsUrl);
    if (!cid) return ipfsUrl; // Return original if we can't extract CID
    
    // Make sure gateway doesn't have protocol or trailing slash
    const cleanGateway = gateway.replace(/^https?:\/\//, '').replace(/\/$/, '');
    return `https://${cleanGateway}/ipfs/${cid}`;
  }
  
  /**
   * Logs IPFS operation details for debugging
   */
  export function logIpfsOperation(operation: string, details: any): void {
    console.log(`==== IPFS ${operation.toUpperCase()} ====`);
    console.table(details);
    console.log('==============================');
  }

// ===== src/utils/update-authority-utils.ts =====

// src/utils/update-authority-utils.ts

/**
 * Utility functions for handling update authority operations
 */

/**
 * Validates that the server is properly configured for update authority revocation
 * returns Promise resolving to true if configuration is valid, false otherwise
 */
export async function validateUpdateAuthorityConfig(): Promise<boolean> {
    try {
      const response = await fetch('/api/update-authority', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        console.error("Server configuration check failed:", await response.text());
        return false;
      }
  
      const data = await response.json();
      return data.success === true;
    } catch (error) {
      console.error("Error validating update authority configuration:", error);
      return false;
    }
  }
  
  /**
   * Checks the update authority configuration when the form loads or when
   * the user toggles the revokeUpdate option
   * @param enabled Whether revoke update is enabled
   * @param onWarning Callback for showing a warning to the user
   */
  export async function checkUpdateAuthorityStatus(
    enabled: boolean,
    onWarning: (message: string) => void
  ): Promise<void> {
    // Only check if the feature is enabled
    if (enabled) {
      const isValid = await validateUpdateAuthorityConfig();
      
      if (!isValid) {
        onWarning(
          "Warning: The server is not properly configured for revoking update authority. " +
          "This feature might not work correctly. Please contact support."
        );
      } else {
        // Clear any previous warnings if valid
        onWarning("");
      }
    }
  }
  
  /**
   * Gets the update authority public key from the server
   * @returns Promise resolving to the update authority public key
   */
  export async function getUpdateAuthorityPublicKey(): Promise<string | null> {
    try {
      const response = await fetch('/api/update-authority');
      
      if (!response.ok) {
        console.error("Failed to get update authority:", await response.text());
        return null;
      }
      
      const data = await response.json();
      
      if (!data.success || !data.updateAuthorityPublicKey) {
        console.error("Invalid response from update authority endpoint:", data);
        return null;
      }
      
      return data.updateAuthorityPublicKey;
    } catch (error) {
      console.error("Error getting update authority public key:", error);
      return null;
    }
  }

// ===== src/utils/wallet-debug.ts =====

// src/utils/wallet-debug.ts

/**
 * Helper function to debug wallet connection status
 */
export function debugWallet(wallet: any) {
    const connection = {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      publicKeyValue: wallet && wallet.publicKey ? wallet.publicKey.toString() : 'none',
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false,
      walletName: wallet?.adapter?.name || 'unknown'
    };
    
    console.log("===== WALLET DEBUG INFO =====");
    console.table(connection);
    console.log("=============================");
    
    return connection;
  }
  
  /**
   * Helper function to debug wallet adapter capabilities
   */
  export function debugWalletCapabilities(wallet: any) {
    if (!wallet || !wallet.adapter) {
      console.log("No wallet adapter found");
      return;
    }
    
    const adapter = wallet.adapter;
    
    const capabilities = {
      name: adapter.name,
      icon: !!adapter.icon,
      connected: !!adapter.connected,
      publicKey: !!adapter.publicKey,
      connecting: !!adapter.connecting,
      ready: !!adapter.ready,
      supportedTransactionVersions: adapter.supportedTransactionVersions ? 
        Array.from(adapter.supportedTransactionVersions) : [],
      hasConnect: typeof adapter.connect === 'function',
      hasDisconnect: typeof adapter.disconnect === 'function',
      hasSignTransaction: typeof adapter.signTransaction === 'function',
      hasSignAllTransactions: typeof adapter.signAllTransactions === 'function',
      hasSignMessage: typeof adapter.signMessage === 'function',
      hasSendTransaction: typeof adapter.sendTransaction === 'function',
    };
    
    console.log("===== WALLET CAPABILITIES =====");
    console.table(capabilities);
    console.log("===============================");
    
    return capabilities;
  }

// ===== src/utils/error-utils.ts =====

// src/utils/error-utils.ts

/**
 * Formats Solana errors into user-friendly messages
 */
export function formatSolanaError(error: any): string {
    // If it's already a string, just return it
    if (typeof error === 'string') return error;
    
    // Extract error message from Error object
    const errorMessage = error.message || 'Unknown error occurred';
    
    // Handle specific Solana error messages
    if (errorMessage.includes('0x1')) {
      return 'Insufficient funds for transaction. Please make sure you have enough SOL to cover the fees.';
    }
    
    if (errorMessage.includes('Blockhash not found')) {
      return 'Network congestion detected. Please try again in a few moments.';
    }
    
    if (errorMessage.includes('Transaction simulation failed')) {
      return 'Transaction simulation failed. This could be due to network congestion or insufficient SOL.';
    }
    
    if (errorMessage.includes('User rejected')) {
      return 'Transaction was rejected by wallet. You must approve the transaction to continue.';
    }
    
      // Handle wallet connection errors
    if (errorMessage.includes('wallet disconnected') || errorMessage.includes('wallet not connected')) {
      return 'Wallet disconnected. Please reconnect your wallet and try again.';
    }
    
    if (errorMessage.includes('timeout')) {
      return 'Transaction timed out. The Solana network might be congested, please try again.';
    }
    
    // Handle metadata errors
    if (errorMessage.includes('metadata')) {
      return 'Error with token metadata. Please ensure your token information is valid.';
    }
    
    // Handle Pinata/IPFS errors
    if (errorMessage.includes('Pinata') || errorMessage.includes('IPFS')) {
      return 'Error uploading to IPFS. Please try again or check if your image file is valid.';
    }
  
    // Fall back to the original error message
    return errorMessage;
  }
  
  /**
   * Logs detailed error information
   */
  export function logError(error: any, context: string): void {
    console.error(`Error in ${context}:`, error);
    
    // Log additional information if available
    if (error.code) {
      console.error(`Error code: ${error.code}`);
    }
    
    if (error.stack) {
      console.error(`Stack trace: ${error.stack}`);
    }
    
    // For Solana-specific errors
    if (error.logs) {
      console.error('Solana logs:', error.logs);
    }
  }
  
  /**
   * Creates a user-friendly error message for validation errors
   */
  export function getValidationErrorMessage(field: string, message: string): string {
    return `${field}: ${message}`;
  }
  
  /**
   * Checks common token validation rules
   */
  export function validateTokenData(data: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
  }): string | null {
    if (!data.name || data.name.trim() === '') {
      return 'Token name is required';
    }
    
    if (data.name.length > 32) {
      return 'Token name must be 32 characters or less';
    }
    
    if (!data.symbol || data.symbol.trim() === '') {
      return 'Token symbol is required';
    }
    
    if (data.symbol.length > 10) {
      return 'Token symbol must be 10 characters or less';
    }
    
    if (data.decimals < 0 || data.decimals > 18) {
      return 'Decimals must be between 0 and 18';
    }
    
    if (data.supply <= 0) {
      return 'Supply must be greater than 0';
    }
    
    if (data.supply > Number.MAX_SAFE_INTEGER) {
      return 'Supply is too large';
    }
    
    return null;
  }

// ===== src/utils/token-utils.ts =====

// src/utils/token-utils.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length < 2 || symbol.length > 10) {
      return false;
    }
    
    // Most token symbols are uppercase alphanumeric
    const validSymbolRegex = /^[A-Z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Formats a wallet address for display 
   */
  export function formatWalletAddress(address: string): string {
    if (!address || address.length < 10) return address;
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  }
  
  /**
   * Generates a token explorer URL
   */
  export function getTokenExplorerUrl(tokenAddress: string, network: string = 'devnet'): string {
    return `https://explorer.solana.com/address/${tokenAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`;
  }

// ===== src/utils/token-validation.ts =====

// src/utils/token-validation.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters - allow more flexibility than the original
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length > 10) {
      return false;
    }
    
    // Allow more flexibility in symbol format
    const validSymbolRegex = /^[A-Za-z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token description
   */
  export function isValidTokenDescription(description: string): boolean {
    // Description should exist
    if (!description || description.trim() === '') {
      return false;
    }
    
    // Reasonable length limit
    if (description.length > 1000) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits - allow bigger supply than original
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates token decimals
   */
  export function isValidTokenDecimals(decimals: number): boolean {
    // Decimals must be in the valid range for Solana tokens
    return Number.isInteger(decimals) && decimals >= 0 && decimals <= 9;
  }
  
  /**
   * Validates an image file for token logo
   */
  export function isValidTokenImage(file: File | null): boolean {
    if (!file) {
      return false;
    }
    
    // Check file type
    const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!validTypes.includes(file.type)) {
      return false;
    }
    
    // Check file size (max 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Validates the entire token form data
   * @returns string error message or null if valid
   */
  export function validateTokenForm(formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  }): string | null {
    if (!isValidTokenName(formData.name)) {
      return "Token name is required and must be up to 32 alphanumeric characters";
    }
    
    if (!isValidTokenSymbol(formData.symbol)) {
      return "Token symbol is required and must be 2-10 alphanumeric characters";
    }
    
    if (!isValidTokenDescription(formData.description)) {
      return "Description is required and must be less than 1000 characters";
    }
    
    if (!isValidTokenDecimals(formData.decimals)) {
      return "Decimals must be a whole number between 0 and 9";
    }
    
    if (!isValidTokenSupply(formData.supply)) {
      return "Supply must be a positive whole number";
    }
    
    if (!isValidTokenImage(formData.logo)) {
      return "Logo image is required (PNG or JPG, max 5MB)";
    }
    
    return null;
  }

// ===== src/components/token/token-form-options.tsx =====

'use client';

import React from 'react';
import SocialLinksForm from './social-links-form';

interface TokenFormOptionsProps {
  formData: {
    socialLinks: boolean;
    creatorInfo: boolean;
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
}

export default function TokenFormOptions({
  formData,
  setFormData,
  handleInputChange
}: TokenFormOptionsProps) {
  // Toggle function that also updates the input checkbox
  const toggleOption = (option: 'socialLinks' | 'creatorInfo') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev, 
      [option]: !prev[option]
    }));
    
    // Also simulate changing the checkbox by dispatching an event
    const checkbox = document.getElementById(option) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[option];
      const event = new Event('change', { bubbles: true });
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="creatorInfo" 
                type="checkbox" 
                name="creatorInfo"
                checked={formData.creatorInfo}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.creatorInfo ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('creatorInfo')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.creatorInfo ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Creator's Info (Optional)</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Change the information of the creator in the metadata. By default, it is SolMinter.
        </div>
      </div>

      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="socialLinks" 
                type="checkbox" 
                name="socialLinks"
                checked={formData.socialLinks}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.socialLinks ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('socialLinks')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.socialLinks ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Add Social Links & Tags</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Add links to your token metadata.
        </div>
      </div>
      
      {formData.socialLinks && (
        <SocialLinksForm formData={formData} handleInputChange={handleInputChange} />
      )}
    </div>
  );
}

// ===== src/components/token/token-form.tsx =====

"use client"

import { useState, useCallback, useEffect } from "react"
import { useWallet, useConnection } from "@solana/wallet-adapter-react"
import {
  createTokenWithMetadata,
} from "@/services/token-service"
import { calculateFee, formatFee } from "@/services/fee-service"
import TokenCreationSuccess from "./token-creation-success"
import Loading from "../ui/loading"
import TokenFormBasic from "./token-form-basic"
import TokenFormOptions from "./token-form-options"
import TokenFormAuthorities from "./token-form-authorities"
import TokenFormCreator from "./token-form-creator"
import WalletRequired from "../wallet/wallet-required"
import { FormDataType, TokenResult } from "@/types/token"
import { SOLANA_NETWORK_FEE } from "@/config"

// Enhanced steps with more concise and user-friendly messages
const STEPS = [
  "Uploading token image...",
  "Creating token metadata...",
  "Preparing transaction...",
  "Processing on blockchain...",
  "Finalizing token details...",
  "Almost done...",
  "Completing token creation...",
]

export default function TokenForm() {
  const walletAdapter = useWallet()
  const { connection } = useConnection()

  const [formData, setFormData] = useState<FormDataType>({
    name: "",
    symbol: "",
    decimals: 9,
    supply: 1_000_000_000,
    description: "",
    logo: null,
    revokeMint: true,
    revokeFreeze: true,
    revokeUpdate: true,
    socialLinks: false,
    creatorInfo: false,
    creatorName: "SolMinter", // Default creator name
    website: "",
    twitter: "",
    telegram: "",
    discord: "",
  })

  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [progressStep, setProgressStep] = useState(0)
  const [tokenResult, setTokenResult] = useState<TokenResult | null>(null)
  const [totalFee, setTotalFee] = useState<number>(0.4) // Initial fee calculation with all defaults (0.1 base + 0.3 for all authorities)
  const [formSubmitAttempted, setFormSubmitAttempted] = useState(false) // Track form submission attempts
  const [cancelled, setCancelled] = useState(false) // Track if token creation was cancelled

  // Calculate fee whenever relevant form options change
  useEffect(() => {
    const fee = calculateFee({
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    console.log("Calculated fee:", fee, "with options:", {
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    setTotalFee(fee)
  }, [
    formData.revokeMint,
    formData.revokeFreeze,
    formData.revokeUpdate,
    formData.socialLinks,
    formData.creatorInfo,
  ])

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target as HTMLInputElement
    const checked = type === 'checkbox' ? (e.target as HTMLInputElement).checked : undefined
    
    console.log(`Input changed: ${name} = ${type === 'checkbox' ? checked : value}`)
    
    setFormData((prev) => ({
      ...prev,
      [name]:
        type === "checkbox"
          ? checked
          : type === "number"
          ? parseInt(value)
          : value,
    }))
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFormData((prev) => ({ ...prev, logo: e.target.files![0] }))
    }
  }

  // Function to validate form data before submission
  const validateForm = (): string | null => {
    if (!walletAdapter.connected) {
      return "Please connect your wallet first";
    }
    if (!formData.logo) {
      return "Please upload a logo image";
    }
    if (!formData.name || formData.name.trim() === '') {
      return "Token name is required";
    }
    if (!formData.symbol || formData.symbol.trim() === '') {
      return "Token symbol is required";
    }
    if (!formData.description || formData.description.trim() === '') {
      return "Token description is required";
    }
    return null;
  };

  // Handle cancellation from the loading screen
  const handleCancel = useCallback(() => {
    setCancelled(true);
    setIsSubmitting(false);
    setError("Token creation was cancelled.");
  }, []);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      
      // Mark that a submission attempt was made
      setFormSubmitAttempted(true)
      
      // Clear previous errors and reset cancellation state
      setError(null)
      setCancelled(false)
      
      // Validate form
      const validationError = validateForm();
      if (validationError) {
        setError(validationError);
        return;
      }

      try {
        setIsSubmitting(true)
        setProgressStep(0)

        const result = await createTokenWithMetadata(
          walletAdapter,
          formData,
          totalFee, // Pass the calculated total fee
          (step) => {
            // Skip progress updates if cancelled
            if (!cancelled) setProgressStep(step);
          }
        )
        setTokenResult(result)
      } catch (err: any) {
        console.error("Token creation error:", err)
        setError(err.message || "Unknown error occurred during token creation")
      } finally {
        if (!cancelled) {
          setIsSubmitting(false)
        }
      }
    },
    [walletAdapter, formData, totalFee, cancelled]
  )

  if (tokenResult) {
    return <TokenCreationSuccess result={tokenResult} />
  }

  if (isSubmitting) {
    return (
      <Loading
        message="Creating Your Token"
        steps={STEPS}
        currentStepIndex={progressStep}
        onCancel={handleCancel}
      />
    )
  }

  // If wallet is not connected, use the shared WalletRequired component
  if (!walletAdapter.connected) {
    return <WalletRequired message="Please connect your wallet to create a new Solana token" />;
  }

  // Calculate net fee after Solana network fee
  const netFee = Math.max(totalFee - SOLANA_NETWORK_FEE, 0);

  return (
    <form
      onSubmit={handleSubmit}
      className="max-w-3xl mx-auto space-y-6 p-6 bg-[#171717] rounded-xl my-12"
    >
      {error && (
        <div className="text-red-400 bg-red-800/30 p-3 rounded mb-4">{error}</div>
      )}

      <TokenFormBasic
        formData={formData}
        handleInputChange={handleInputChange}
        handleFileChange={handleFileChange}
        formSubmitted={formSubmitAttempted}
      />

      <TokenFormOptions
        formData={formData}
        setFormData={setFormData}
        handleInputChange={handleInputChange}
      />

      {formData.creatorInfo && (
        <TokenFormCreator
          formData={formData}
          handleInputChange={handleInputChange}
        />
      )}

      <TokenFormAuthorities
        formData={formData}
        setFormData={setFormData}
      />

      {/* Display dynamic feature‐fee total */}
      <div className="flex justify-between items-center text-gray-300">
        <span>Total fee:</span>
        <span className="text-purple-500 font-semibold">
          {formatFee(totalFee)}
        </span>
      </div>
      <div className="text-xs text-gray-500 flex justify-between">
        <span>(Includes Solana network fee: {formatFee(SOLANA_NETWORK_FEE)})</span>
        <span>Net fee: {formatFee(netFee)}</span>
      </div>

      <button
        type="submit"
        className="w-full py-3 rounded-full text-white font-medium transition cursor-pointer bg-gradient-to-r from-purple-600 to-blue-500 hover:opacity-90"
      >
        Launch Token
      </button>
    </form>
  )
}

// ===== src/components/token/token-detail-view.tsx =====

'use client';

import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { MintedTokenInfo } from '@/types/token';
import { SOLANA_NETWORK } from '@/config';
import { formatNumberWithCommas } from '@/utils/token-utils';

interface TokenDetailViewProps {
  token: MintedTokenInfo;
  onClose: () => void;
}

export default function TokenDetailView({ token, onClose }: TokenDetailViewProps) {
  const [activeTab, setActiveTab] = useState<'details' | 'social' | 'explorer'>('details');
  const modalRef = useRef<HTMLDivElement>(null);
  
  const networkParam = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const explorerUrl = `https://explorer.solana.com/address/${token.mintAddress}${networkParam}`;
  const raydiumLiquidityUrl = `https://raydium.io/liquidity/create-pool${networkParam.replace('?', '#')}`;
  const raydiumSwapUrl = `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${token.mintAddress}${networkParam.replace('?', '&')}`;

  // Check if social links exist
  const hasSocialLinks = !!(token.website || token.twitter || token.telegram || token.discord);

  // Handle click outside to close modal
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {
        onClose();
      }
    }
    
    // Add event listener when the component mounts
    document.addEventListener('mousedown', handleClickOutside);
    
    // Prevent body scrolling while modal is open
    document.body.style.overflow = 'hidden';
    
    // Clean up
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.body.style.overflow = 'auto';
    };
  }, [onClose]);

  return (
    <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50 p-4 overflow-auto">
      <div 
        ref={modalRef}
        className="relative bg-[#171717] rounded-xl shadow-xl border border-gray-800 max-w-2xl w-full max-h-[90vh] flex flex-col"
      >
        {/* Header - Fixed position */}
        <div className="flex justify-between items-center p-6 border-b border-gray-800">
          <h3 className="text-2xl font-bold text-white truncate pr-4">{token.name} ({token.symbol})</h3>
          <button 
            onClick={onClose}
            className="text-gray-400 hover:text-white flex-shrink-0"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        
        {/* Tabs - Fixed position */}
        <div className="flex border-b border-gray-800 sticky top-0 bg-[#171717] z-10">
          <button 
            onClick={() => setActiveTab('details')}
            className={`flex-1 py-3 px-4 text-center ${activeTab === 'details' 
              ? 'text-purple-500 border-b-2 border-purple-500'
              : 'text-gray-400 hover:text-gray-200'}`}
          >
            Token Details
          </button>
          {hasSocialLinks && (
            <button 
              onClick={() => setActiveTab('social')}
              className={`flex-1 py-3 px-4 text-center ${activeTab === 'social' 
                ? 'text-purple-500 border-b-2 border-purple-500'
                : 'text-gray-400 hover:text-gray-200'}`}
            >
              Social Links
            </button>
          )}
          <button 
            onClick={() => setActiveTab('explorer')}
            className={`flex-1 py-3 px-4 text-center ${activeTab === 'explorer' 
              ? 'text-purple-500 border-b-2 border-purple-500'
              : 'text-gray-400 hover:text-gray-200'}`}
          >
            Explorer
          </button>
        </div>
        
        {/* Content - Scrollable area */}
        <div className="p-6 overflow-y-auto flex-grow">
          {activeTab === 'details' && (
            <div className="space-y-6">
              <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="w-32 h-32 rounded-full bg-gradient-to-r from-purple-900/20 to-blue-900/20 flex items-center justify-center flex-shrink-0">
                  {token.imageUrl || token.image ? (
                    <img 
                      src={token.imageUrl || token.image} 
                      alt={token.name} 
                      className="w-28 h-28 object-contain rounded-full"
                      onError={(e) => {
                        (e.target as HTMLImageElement).style.display = 'none';
                        (e.target as HTMLImageElement).parentElement!.innerHTML = `
                          <div class="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
                            <span class="text-3xl font-bold text-gray-600">${token.symbol.substring(0, 2)}</span>
                          </div>
                        `;
                      }}
                    />
                  ) : (
                    <div className="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
                      <span className="text-3xl font-bold text-gray-600">{token.symbol.substring(0, 2)}</span>
                    </div>
                  )}
                </div>
                
                <div className="flex-1 text-center md:text-left">
                  <h4 className="text-xl font-bold text-white">{token.name}</h4>
                  <p className="text-purple-400 font-mono">{token.symbol}</p>
                  
                  <div className="mt-2 space-y-1">
                    <div className="text-gray-300">
                      <span className="text-gray-500">Total Supply:</span> {formatNumberWithCommas(token.tokenInfo?.totalSupply || 0)}
                    </div>
                    <div className="text-gray-300">
                      <span className="text-gray-500">Decimals:</span> {token.tokenInfo?.decimals || 9}
                    </div>
                    <div className="text-gray-300">
                      <span className="text-gray-500">Creator:</span> {token.creator || 'Unknown'}
                    </div>
                  </div>
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Description</h5>
                <p className="text-gray-300 bg-[#222] p-3 rounded-lg">
                  {token.description || "No description provided"}
                </p>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Token Address</h5>
                <div className="font-mono text-gray-300 bg-[#222] p-3 rounded-lg text-sm overflow-x-auto">
                  {token.mintAddress || token.mint}
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Authorities</h5>
                <div className="bg-[#222] p-3 rounded-lg">
                  <ul className="space-y-2">
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.mintRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Mint Authority: {token.authorities?.mintRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.freezeRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Freeze Authority: {token.authorities?.freezeRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.updateRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Update Authority: {token.authorities?.updateRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          )}
          
          {activeTab === 'social' && hasSocialLinks && (
            <div className="space-y-6">
              {token.website && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Website</h5>
                  <a 
                    href={token.website}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                    </svg>
                    <span className="break-all">{token.website}</span>
                  </a>
                </div>
              )}
              
              {token.twitter && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Twitter</h5>
                  <a 
                    href={token.twitter}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-400 hover:text-blue-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                    </svg>
                    <span className="break-all">{token.twitter}</span>
                  </a>
                </div>
              )}
              
              {token.telegram && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Telegram</h5>
                  <a 
                    href={token.telegram}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-500 hover:text-blue-400"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                    </svg>
                    <span className="break-all">{token.telegram}</span>
                  </a>
                </div>
              )}
              
              {token.discord && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Discord</h5>
                  <a 
                    href={token.discord}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-indigo-400 hover:text-indigo-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    <span className="break-all">{token.discord}</span>
                  </a>
                </div>
              )}
            </div>
          )}
          
          {activeTab === 'explorer' && (
            <div className="space-y-6">
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Explorer Links</h5>
                <div className="space-y-3">
                  <a 
                    href={explorerUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                    </svg>
                    <span>View on Solana Explorer</span>
                  </a>
                  
                  <a 
                    href={raydiumLiquidityUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-400 hover:text-blue-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span>Create Liquidity Pool on Raydium</span>
                  </a>
                  
                  <a 
                    href={raydiumSwapUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-green-400 hover:text-green-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                    </svg>
                    <span>Swap on Raydium</span>
                  </a>
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">IPFS Links</h5>
                <div className="space-y-3">
                  <a 
                    href={token.metadataUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <span>View Metadata on IPFS</span>
                  </a>
                  
                  {(token.image || token.imageUrl) && (
                    <a 
                      href={token.image || token.imageUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="flex items-center text-blue-400 hover:text-blue-300 bg-[#222] p-3 rounded-lg"
                      onClick={(e) => e.stopPropagation()}
                    >
                      <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                      </svg>
                      <span>View Image on IPFS</span>
                    </a>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
        
        {/* Footer - Fixed at bottom */}
        <div className="border-t border-gray-800 p-6 flex justify-between items-center">
          <div className="text-sm text-gray-500">
            Created with SolMinter
          </div>
          
          <button 
            onClick={onClose}
            className="bg-purple-600 hover:bg-purple-700 text-white py-2 px-6 rounded-full transition-colors"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-creation-success.tsx =====

'use client';

import Link from 'next/link';
import React, { useEffect, useState } from 'react';
import { extractCidFromUrl } from '@/utils/ipfs-utils';
import CheckmarkAnimation from '../ui/checkmark-animation';
import CopyButton from '../ui/copy-button';
import '../../styles/checkmark.css';

interface TokenCreationSuccessProps {
  result: {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  };
}

interface TokenMetadata {
  name: string;
  symbol: string;
  description?: string;
  image?: string;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  tokenInfo?: {
    totalSupply?: number;
    decimals?: number;
  };
}

export default function TokenCreationSuccess({ result }: TokenCreationSuccessProps) {
  const [metadata, setMetadata] = useState<TokenMetadata | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch metadata to display additional token info
  useEffect(() => {
    async function fetchMetadata() {
      try {
        setLoading(true);
        const response = await fetch(result.metadataUrl);
        if (response.ok) {
          const data = await response.json();
          setMetadata(data);
        }
      } catch (error) {
        console.error("Error fetching metadata:", error);
      } finally {
        setLoading(false);
      }
    }

    if (result.metadataUrl) {
      fetchMetadata();
    }
  }, [result.metadataUrl]);

  // Extract relevant information from result and metadata
  const cid = extractCidFromUrl(result.metadataUrl);
  const networkParam = result.explorerUrl.includes("?cluster=devnet") ? "devnet" : "mainnet-beta";
  
  return (
    <div className="max-w-3xl mx-auto py-12 px-4">
      <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-purple-500/30 border-opacity-30">
        <div className="text-center mb-6">
          {/* Replace static success icon with animated checkmark */}
          <CheckmarkAnimation />
          
          <h1 className="text-3xl font-bold text-white mb-2">Token Created Successfully!</h1>
          <p className="text-gray-400 text-lg">Your Solana token has been created and is ready to use.</p>
        </div>
        
        <div className="token-info bg-[#222] rounded-lg p-5 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="token-image flex items-center justify-center">
              <img 
                src={result.imageUrl} 
                alt="Token Logo" 
                className="w-32 h-32 rounded-full border-4 border-gray-700"
              />
            </div>
            
            <div className="token-details">
              {metadata && (
                <div className="mb-4">
                  <div className="text-gray-500 text-sm">Token Name / Symbol</div>
                  <div className="text-white text-xl mt-1">
                    {metadata.name} <span className="text-gray-400">({metadata.symbol})</span>
                  </div>
                </div>
              )}
              
              <div className="mb-4 relative">
                <div className="text-gray-500 text-sm flex items-center justify-between">
                  <span>Token Address</span>
                  <CopyButton textToCopy={result.mintAddress} />
                </div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.mintAddress}
                </div>
              </div>
              
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Network</div>
                <div className="text-white mt-1 flex items-center">
                  <span className={networkParam === "devnet" ? "text-yellow-500" : "text-blue-500"}>
                    {networkParam === "devnet" ? "Devnet" : "Mainnet"}
                  </span>
                  {networkParam === "devnet" && (
                    <span className="ml-2 px-2 py-0.5 text-xs bg-yellow-900 text-yellow-300 rounded-full">
                      Testnet
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>
          
          {metadata && metadata.description && (
            <div className="mt-4">
              <div className="text-gray-500 text-sm mb-1">Description</div>
              <div className="text-gray-300 bg-[#333] p-3 rounded text-sm">{metadata.description}</div>
            </div>
          )}
          
          <div className="mt-4 relative">
            <div className="text-gray-500 text-sm flex items-center justify-between">
              <span>Metadata URL</span>
              <CopyButton textToCopy={result.metadataUrl} />
            </div>
            <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
              {result.metadataUrl}
            </div>
            <div className="text-xs text-gray-500 mt-1">IPFS CID: {cid}</div>
          </div>
          
          {metadata && metadata.tokenInfo && (
            <div className="flex flex-wrap gap-4 mt-4">
              {metadata.tokenInfo.totalSupply && (
                <div>
                  <div className="text-gray-500 text-sm">Total Supply</div>
                  <div className="text-white font-semibold">
                    {metadata.tokenInfo.totalSupply.toLocaleString()}
                  </div>
                </div>
              )}
              
              {metadata.tokenInfo.decimals !== undefined && (
                <div>
                  <div className="text-gray-500 text-sm">Decimals</div>
                  <div className="text-white font-semibold">{metadata.tokenInfo.decimals}</div>
                </div>
              )}
            </div>
          )}
        </div>
        
        {/* Social Links Section */}
        {metadata && (metadata.website || metadata.twitter || metadata.telegram || metadata.discord) && (
          <div className="social-links bg-[#222] rounded-lg p-5 mb-6">
            <h3 className="text-lg font-medium text-white mb-3">Social Links</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {metadata.website && (
                <a 
                  href={metadata.website} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-purple-400 hover:text-purple-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                  </svg>
                  Website
                </a>
              )}
              
              {metadata.twitter && (
                <a 
                  href={metadata.twitter} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-blue-400 hover:text-blue-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                  </svg>
                  Twitter
                </a>
              )}
              
              {metadata.telegram && (
                <a 
                  href={metadata.telegram} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-blue-500 hover:text-blue-400"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                  </svg>
                  Telegram
                </a>
              )}
              
              {metadata.discord && (
                <a 
                  href={metadata.discord} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-indigo-400 hover:text-indigo-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                  </svg>
                  Discord
                </a>
              )}
            </div>
          </div>
        )}
        
        <div className="next-steps space-y-4 mb-8">
          <h2 className="text-xl font-semibold text-white">Next Steps</h2>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">View Your Tokens</h3>
            <p className="text-gray-400 mb-2">Go to your tokens page to see all the tokens you've created.</p>
            <Link 
              href="/my-tokens"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to My Tokens
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
              </svg>
            </Link>
          </div>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">Create Liquidity</h3>
            <p className="text-gray-400 mb-2">Create a liquidity pool on a DEX like Raydium to make your token tradable.</p>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to Raydium
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">View on Explorer</h3>
            <p className="text-gray-400 mb-2">Check your token on the Solana blockchain explorer.</p>
            <a 
              href={result.explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              View on Explorer
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
        </div>
        
        <div className="buttons flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4">
          <Link 
            href="/my-tokens"
            className="btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all text-center"
          >
            View My Tokens
          </Link>
          
          <Link 
            href="/create-token"
            className="btn bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Create Another Token
          </Link>
          
          <Link 
            href="/"
            className="btn bg-transparent border border-gray-700 text-gray-400 font-medium py-3 px-8 rounded-full hover:bg-gray-700 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-analytics.tsx =====

'use client';

import React from 'react';
import { MintedTokenInfo } from '@/types/token';
import { formatNumberWithCommas } from '@/utils/token-utils';

interface TokenAnalyticsProps {
  tokens: MintedTokenInfo[];
}

export default function TokenAnalytics({ tokens }: TokenAnalyticsProps) {
  if (!tokens || tokens.length === 0) return null;

  // Calculate total token count
  const tokenCount = tokens.length;

  // Calculate total supply across all tokens
  const totalSupply = tokens.reduce((sum, token) => 
    sum + (token.tokenInfo?.totalSupply || 0), 0);

  // Count revoked authorities across all tokens
  const revokedAuthoritiesCount = {
    mint: tokens.filter(token => token.authorities?.mintRevoked).length,
    freeze: tokens.filter(token => token.authorities?.freezeRevoked).length,
    update: tokens.filter(token => token.authorities?.updateRevoked).length
  };

  // Count tokens with social links
  const tokensWithSocialLinks = tokens.filter(token => 
    token.website || token.twitter || token.telegram || token.discord
  ).length;

  return (
    <div className="bg-[#171717] rounded-xl p-6 shadow-lg mb-8">
      <h2 className="text-xl font-semibold text-white mb-4">Token Analytics</h2>
      
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-purple-400 text-sm mb-1">Total Tokens</div>
          <div className="text-white text-2xl font-bold">{tokenCount}</div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-blue-400 text-sm mb-1">Total Supply</div>
          <div className="text-white text-2xl font-bold">{formatNumberWithCommas(totalSupply)}</div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-green-400 text-sm mb-1">Revoked Authorities</div>
          <div className="flex space-x-2 mt-2">
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Mint: {revokedAuthoritiesCount.mint}
            </div>
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Freeze: {revokedAuthoritiesCount.freeze}
            </div>
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Update: {revokedAuthoritiesCount.update}
            </div>
          </div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-yellow-400 text-sm mb-1">Social Links</div>
          <div className="text-white">
            <span className="text-2xl font-bold">{tokensWithSocialLinks}</span>
            <span className="text-gray-400 text-sm ml-1">/ {tokenCount}</span>
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Overview of your created tokens and their configuration.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-creator.tsx =====

'use client';

import React from 'react';

interface TokenFormCreatorProps {
  formData: {
    creatorName: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormCreator({ 
  formData, 
  handleInputChange 
}: TokenFormCreatorProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Creator Information</div>
      
      <div className="bg-[#1e1e1e] rounded-lg p-4">
        <div className="form-field mb-4">
          <label className="field-label block text-gray-300 mb-2">Creator Name</label>
          <input 
            placeholder="Enter creator name" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="creatorName"
            value={formData.creatorName}
            onChange={handleInputChange}
          />
          <span className="field-constraint text-xs text-gray-500 mt-1 block">
            This name will appear as the creator in token metadata
          </span>
        </div>
      </div>
      
      <div className="text-xs text-gray-500 mt-2">
        Customize the creator information instead of using the default SolMinter.
      </div>
    </div>
  );
}

// ===== src/components/token/token-list.tsx =====

'use client';

import { MintedTokenInfo } from '@/types/token';
import TokenCard from './token-card';

interface TokenListProps {
  tokens: MintedTokenInfo[];
}

export default function TokenList({ tokens }: TokenListProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
      {tokens.map((token) => (
        <TokenCard key={token.mintAddress} token={token} />
      ))}
    </div>
  );
}

// ===== src/components/token/token-error-state.tsx =====

'use client';

import Link from 'next/link';

interface TokenErrorStateProps {
  message: string;
  onRetry?: () => void;
}

export default function TokenErrorState({ message, onRetry }: TokenErrorStateProps) {
  return (
    <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-red-800 max-w-2xl mx-auto">
      <div className="text-center mb-6">
        <div className="w-20 h-20 bg-red-500 bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg className="w-10 h-10 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-2">Something Went Wrong</h2>
        <p className="text-gray-400 mb-6">
          {message || "We couldn't load your token information. Please try again later."}
        </p>
        
        <div className="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
          {onRetry && (
            <button 
              onClick={onRetry}
              className="bg-red-700 hover:bg-red-600 text-white font-medium py-2 px-6 rounded-full transition-colors"
            >
              Try Again
            </button>
          )}
          
          <Link 
            href="/create-token"
            className="bg-purple-700 hover:bg-purple-600 text-white font-medium py-2 px-6 rounded-full transition-colors"
          >
            Create New Token
          </Link>
          
          <Link 
            href="/"
            className="bg-transparent border border-gray-600 text-gray-300 hover:border-gray-400 hover:text-white font-medium py-2 px-6 rounded-full transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-authorities.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import { checkUpdateAuthorityStatus } from '@/utils/update-authority-utils';

interface TokenFormAuthoritiesProps {
  formData: {
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
}

export default function TokenFormAuthorities({
  formData,
  setFormData
}: TokenFormAuthoritiesProps) {
  const [updateAuthorityWarning, setUpdateAuthorityWarning] = useState<string>("");
  const [isCheckingConfig, setIsCheckingConfig] = useState<boolean>(false);

  // Check update authority configuration on initial load and when toggled
  useEffect(() => {
    async function checkConfig() {
      if (formData.revokeUpdate) {
        setIsCheckingConfig(true);
        await checkUpdateAuthorityStatus(
          formData.revokeUpdate, 
          (message) => setUpdateAuthorityWarning(message)
        );
        setIsCheckingConfig(false);
      } else {
        setUpdateAuthorityWarning("");
      }
    }
    
    checkConfig();
  }, [formData.revokeUpdate]);

  // Handle checkbox click with proper event simulation
  const handleCheckboxClick = (field: 'revokeMint' | 'revokeFreeze' | 'revokeUpdate') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev,
      [field]: !prev[field]
    }));
    
    // Find the related hidden checkbox and simulate a change event
    const checkbox = document.getElementById(field) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[field];
      // Create a proper change event
      const event = new Event('change', { bubbles: true });
      
      // Add properties to the event object using Object.defineProperty
      Object.defineProperty(event, 'target', {
        writable: false,
        value: {
          name: field,
          type: 'checkbox',
          checked: !formData[field]
        }
      });
      
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Revoke Authorities (Investor's Booster)</div>
      
      <div className="form-section-authorities space-y-4">
        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Freeze</div>
              <input 
                id="revokeFreeze" 
                type="checkbox" 
                name="revokeFreeze"
                checked={formData.revokeFreeze}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeFreeze: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeFreeze ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeFreeze')}
              >
                {formData.revokeFreeze && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to freeze holders' token accounts anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Mint</div>
              <input 
                id="revokeMint" 
                type="checkbox" 
                name="revokeMint"
                checked={formData.revokeMint}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeMint: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeMint ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeMint')}
              >
                {formData.revokeMint && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to create more tokens anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Update</div>
              <input 
                id="revokeUpdate" 
                type="checkbox" 
                name="revokeUpdate"
                checked={formData.revokeUpdate}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeUpdate: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeUpdate ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeUpdate')}
              >
                {formData.revokeUpdate && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to modify token metadata anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
          
          {/* Display warning if there's an issue with update authority configuration */}
          {updateAuthorityWarning && (
            <div className="mt-2 text-xs text-amber-500 bg-amber-950/40 p-2 rounded">
              <div className="flex items-center">
                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                {updateAuthorityWarning}
              </div>
            </div>
          )}
          
          {/* Show loading spinner when checking server configuration */}
          {isCheckingConfig && (
            <div className="mt-2 text-xs text-blue-500 flex items-center">
              <svg className="animate-spin h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Checking server configuration...
            </div>
          )}
        </div>
      </div>
      
      <div className="form-section-description text-xs text-gray-500 mt-4">
        Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.
      </div>
    </div>
  );
}

// ===== src/components/token/token-skeleton.tsx =====

'use client';

export default function TokenSkeleton() {
  return (
    <div className="bg-[#171717] rounded-xl overflow-hidden shadow-lg border border-gray-800 animate-pulse">
      {/* Image Skeleton */}
      <div className="h-48 bg-gray-800 relative flex items-center justify-center">
        <div className="w-20 h-20 bg-gray-700 rounded-full"></div>
      </div>
      
      {/* Content Skeleton */}
      <div className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <div className="h-6 bg-gray-700 rounded w-32 mb-2"></div>
            <div className="h-4 bg-gray-700 rounded w-16"></div>
          </div>
          <div className="h-6 bg-gray-700 rounded w-20"></div>
        </div>
        
        <div className="h-4 bg-gray-700 rounded w-full mb-2"></div>
        <div className="h-4 bg-gray-700 rounded w-3/4 mb-4"></div>
        
        <div className="mb-4">
          <div className="h-3 bg-gray-700 rounded w-24 mb-2"></div>
          <div className="h-8 bg-gray-700 rounded w-full"></div>
        </div>
        
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div>
            <div className="h-3 bg-gray-700 rounded w-20 mb-2"></div>
            <div className="h-5 bg-gray-700 rounded w-24"></div>
          </div>
          
          <div>
            <div className="h-3 bg-gray-700 rounded w-32 mb-2"></div>
            <div className="h-5 bg-gray-700 rounded w-28"></div>
          </div>
        </div>
        
        <div className="flex space-x-3 mb-4">
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
        </div>
        
        <div className="flex justify-between space-x-2 mt-6">
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
        </div>
      </div>
    </div>
  );
}

export function TokenSkeletonList() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
      <TokenSkeleton />
      <TokenSkeleton />
      <TokenSkeleton />
    </div>
  );
}

// ===== src/components/token/social-links-form.tsx =====

'use client';

import React from 'react';

interface SocialLinksFormProps {
  formData: {
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SocialLinksForm({ formData, handleInputChange }: SocialLinksFormProps) {
  return (
    <div className="social-links-form bg-[#1e1e1e] rounded-lg p-4 mt-4">
      <h3 className="text-white text-lg mb-4">Social Links</h3>
      
      <div className="space-y-4">
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Website URL</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
              </svg>
            </span>
            <input 
              placeholder="https://your-website.com" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="website"
              value={formData.website}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Twitter</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://x.com/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="twitter"
              value={formData.twitter}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Telegram</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
            </span>
            <input 
              placeholder="https://t.me/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="telegram"
              value={formData.telegram}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Discord</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://discord.gg/yourinvite" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="discord"
              value={formData.discord}
              onChange={handleInputChange}
            />
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Adding social links helps your community find and connect with your project. All fields are optional.
      </div>
    </div>
  );
}

// ===== src/components/token/token-card.tsx =====

'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';
import { MintedTokenInfo } from '@/types/token';
import { SOLANA_NETWORK } from '@/config';
import { formatNumberWithCommas } from '@/utils/token-utils';
import TokenDetailView from './token-detail-view';

interface TokenCardProps {
  token: MintedTokenInfo;
}

export default function TokenCard({ token }: TokenCardProps) {
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [showDetailView, setShowDetailView] = useState(false);

  const networkParam = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const explorerUrl = `https://explorer.solana.com/address/${token.mintAddress}${networkParam}`;
  const raydiumLiquidityUrl = `https://raydium.io/liquidity/create-pool${networkParam.replace('?', '#')}`;
  const raydiumSwapUrl = `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${token.mintAddress}${networkParam.replace('?', '&')}`;

  // Determine the image URL - might be in imageUrl or image property
  const actualImageUrl = token.imageUrl || token.image || '';

  useEffect(() => {
    // Reset image states when token changes
    setImageLoaded(false);
    setImageError(false);
    
    // Preload the image to check if it's valid
    if (actualImageUrl) {
      const img = new Image();
      img.onload = () => setImageLoaded(true);
      img.onerror = () => setImageError(true);
      img.src = actualImageUrl;
    } else {
      setImageError(true);
    }
  }, [token, actualImageUrl]);

  const handleImageLoad = () => {
    setImageLoaded(true);
  };

  const handleImageError = () => {
    setImageError(true);
  };

  const openDetailView = () => {
    setShowDetailView(true);
  };

  const closeDetailView = () => {
    setShowDetailView(false);
  };

  return (
    <>
      <div 
        className="bg-[#171717] rounded-xl overflow-hidden shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all cursor-pointer"
        onClick={openDetailView}
      >
        {/* Token Image Header */}
        <div className="h-48 bg-gradient-to-r from-purple-900/20 to-blue-900/20 relative flex items-center justify-center">
          {!imageLoaded && !imageError && (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="w-12 h-12 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin"></div>
            </div>
          )}
          
          {!imageError ? (
            <img 
              src={actualImageUrl} 
              alt={`${token.name} logo`}
              className={`object-contain max-h-40 mx-auto ${imageLoaded ? 'opacity-100' : 'opacity-0'}`}
              style={{ transition: 'opacity 0.3s ease-in-out' }}
              onLoad={handleImageLoad}
              onError={handleImageError}
            />
          ) : (
            <div className="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
              <span className="text-2xl font-bold text-gray-600">{token.symbol.substring(0, 2)}</span>
            </div>
          )}
        </div>
        
        {/* Token Info */}
        <div className="p-6">
          <div className="flex justify-between items-start mb-4">
            <div>
              <h3 className="text-xl font-bold text-white">{token.name}</h3>
              <p className="text-purple-400 font-mono">{token.symbol}</p>
            </div>
            <span className="bg-purple-900/30 text-purple-300 text-xs px-2 py-1 rounded-full">
              {token.tokenInfo?.decimals || 9} decimals
            </span>
          </div>
          
          <p className="text-gray-400 text-sm mb-4 line-clamp-2">
            {token.description || 'No description provided'}
          </p>
          
          <div className="mb-4">
            <div className="text-gray-500 text-xs mb-1">Token Address</div>
            <div className="font-mono text-xs bg-[#222] p-2 rounded overflow-hidden text-ellipsis">
              {token.mintAddress}
            </div>
          </div>
          
          <div className="grid grid-cols-2 gap-4 mb-4">
            <div>
              <div className="text-gray-500 text-xs">Total Supply</div>
              <div className="text-white font-medium">
                {formatNumberWithCommas(token.tokenInfo?.totalSupply || 0)}
              </div>
            </div>
            
            <div>
              <div className="text-gray-500 text-xs">Revoked Authorities</div>
              <div className="flex space-x-1">
                {token.authorities?.mintRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Mint</span>
                )}
                {token.authorities?.freezeRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Freeze</span>
                )}
                {token.authorities?.updateRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Update</span>
                )}
              </div>
            </div>
          </div>

          {/* Social Links (if available) */}
          {(token.website || token.twitter || token.telegram || token.discord) && (
            <div className="flex space-x-3 mb-4">
              {token.website && (
                <a 
                  href={token.website} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-purple-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                  </svg>
                </a>
              )}
              
              {token.twitter && (
                <a 
                  href={token.twitter} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-blue-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                  </svg>
                </a>
              )}
              
              {token.telegram && (
                <a 
                  href={token.telegram} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-blue-500"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                  </svg>
                </a>
              )}
              
              {token.discord && (
                <a 
                  href={token.discord} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-indigo-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                  </svg>
                </a>
              )}
            </div>
          )}
          
          {/* Action Links */}
          <div className="flex justify-between space-x-2 mt-6">
            <a 
              href={explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-purple-500 text-purple-500 hover:bg-purple-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Explorer
            </a>
            
            <a 
              href={raydiumLiquidityUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-blue-500 text-blue-500 hover:bg-blue-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Create Pool
            </a>
            
            <a 
              href={raydiumSwapUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-green-500 text-green-500 hover:bg-green-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Swap
            </a>
          </div>
        </div>
      </div>

      {/* Detail Modal */}
      {showDetailView && (
        <TokenDetailView 
          token={token} 
          onClose={closeDetailView} 
        />
      )}
    </>
  );
}

// ===== src/components/token/token-form-basic.tsx =====

'use client';

import React, { useRef } from 'react';

interface TokenFormBasicProps {
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  formSubmitted?: boolean; // New prop to track if form was submitted
}

export default function TokenFormBasic({
  formData,
  handleInputChange,
  handleFileChange,
  formSubmitted = false // Default to false
}: TokenFormBasicProps) {
  // Create a ref for the file input
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Function to trigger file input click
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Name *</label>
        <input 
          placeholder="Ex: Moon Coin" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Max 32 characters in your name</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Symbol *</label>
        <input 
          placeholder="Ex: MOON" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="symbol"
          value={formData.symbol}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Decimals *</label>
        <input 
          placeholder="Ex: 9" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="decimals"
          value={formData.decimals}
          onChange={handleInputChange}
          min="0"
          max="18"
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Change the number of decimals for your token</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Supply *</label>
        <input 
          placeholder="Ex: 1000000000" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="supply"
          value={formData.supply}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">The initial number of available tokens that will be created in your wallet</span>
      </div>

      <div className="logo-wrapper grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
        <div className="logo-box">
          <span className="label-text block text-gray-300 mb-2">Logo *</span>
          <div 
            className="img-input-wrapper border-2 border-dashed border-gray-700 rounded-lg p-6 text-center cursor-pointer hover:border-purple-500 transition-colors" 
            onClick={triggerFileInput}
          >
            <span className="material-symbols-rounded text-3xl mb-2 text-gray-400 block">upload</span>
            <span className="text-1 block text-gray-300 mb-1">Drag and drop here to upload</span>
            <div className="text-2 text-xs text-gray-500">.png, .jpg 1000x1000 px</div>
            <input 
              ref={fileInputRef}
              accept=".png, .jpg, .jpeg" 
              className="form-img hidden" 
              type="file"
              onChange={handleFileChange}
              // Remove required from hidden input
            />
          </div>
          <span className="field-constraint text-xs text-gray-500 mt-1 block">Add logo for your token</span>
          {formSubmitted && !formData.logo && (
            <span className="text-red-400 text-xs mt-1 block">
              Logo image is required
            </span>
          )}
        </div>
        
        <div className="logo-preview flex items-center justify-center">
          {formData.logo ? (
            <img 
              src={URL.createObjectURL(formData.logo)} 
              alt="Token Logo Preview" 
              className="max-h-40 rounded-lg border border-gray-700"
            />
          ) : (
            <div className="text-gray-500 text-sm">Logo preview will appear here</div>
          )}
        </div>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Description *</label>
        <textarea 
          placeholder="Here you can describe your token" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white h-24" 
          name="description"
          value={formData.description}
          onChange={handleInputChange}
          required
        />
      </div>
    </div>
  );
}

// ===== src/components/token/no-tokens-found.tsx =====

'use client';

import Link from 'next/link';

export default function NoTokensFound() {
  return (
    <div className="min-h-screen bg-[#0a0a0a] flex items-center justify-center">
      <div className="max-w-3xl w-full mx-auto p-10 bg-[#171717] rounded-xl text-center">
        <div className="w-20 h-20 bg-purple-900/20 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg className="w-10 h-10 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-4">No Tokens Found</h2>
        <p className="text-gray-400 mb-8">
          You haven't created any tokens with SolMinter yet. Get started by creating your first token!
        </p>
        
        <Link 
          href="/create-token" 
          className="inline-block bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all"
        >
          Create Your First Token
        </Link>
      </div>
    </div>
  );
}

// ===== src/components/ui/copy-button.tsx =====

'use client';

import { useState } from 'react';

interface CopyButtonProps {
  textToCopy: string;
  className?: string;
}

export default function CopyButton({ textToCopy, className = '' }: CopyButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(textToCopy);
      setCopied(true);
      
      // Reset the copied state after 2 seconds
      setTimeout(() => {
        setCopied(false);
      }, 2000);
      
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  };

  return (
    <div className="relative inline-flex items-center">
      <button 
        onClick={handleCopy} 
        className={`copy-button flex items-center justify-center p-2 ${className}`}
        title="Copy to clipboard"
        style={{ width: '30px', height: '30px' }} // Fixed dimensions for better hitbox
      >
        <svg 
          className="w-5 h-5" 
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24" 
          xmlns="http://www.w3.org/2000/svg"
          style={{ pointerEvents: 'none' }} // Prevent SVG from intercepting clicks
        >
          {copied ? (
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth="2" 
              d="M5 13l4 4L19 7"
              style={{ pointerEvents: 'none' }}
            />
          ) : (
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth="2" 
              d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"
              style={{ pointerEvents: 'none' }}
            />
          )}
        </svg>
      </button>
      <div className={`copy-success ${copied ? 'show' : ''}`}>
        Copied!
      </div>
    </div>
  );
}

// ===== src/components/ui/loading.tsx =====

"use client";

import React, { useState } from "react";
import { cleanupSessionFiles } from "@/services/pinata-cleanup";
import "@/styles/loading.css";

interface LoadingProps {
  message?: string;
  steps?: string[];
  /** If provided, controls which step is active; disables auto-advance */
  currentStepIndex?: number;
  /** Optional cancel handler */
  onCancel?: () => void;
}

export default function Loading({
  message = "Loading...",
  steps = [],
  currentStepIndex,
  onCancel,
}: LoadingProps) {
  const stepIndex = currentStepIndex != null ? currentStepIndex : 0;
  const [isCancelling, setIsCancelling] = useState(false);

  // Handle cancel button click
  const handleCancel = async () => {
    if (isCancelling) return;
    setIsCancelling(true);

    // Clean up Pinata files
    await cleanupSessionFiles();

    // Call the parent's onCancel handler if provided
    if (onCancel) {
      onCancel();
    }
  };

  // Determine if we should show wallet notification based on step
  const showWalletNotification = () => {
    // For client-side flow (revoke update off), wallet appears during step 5 ("Almost done...")
    // For server-side flow (revoke update on), wallet appears during step 3 ("Processing on blockchain...")
    return stepIndex === 3 || stepIndex === 5;
  };

  return (
    <div className="flex flex-col items-center justify-center p-8 max-w-md mx-auto">
      <div className="relative mb-8">
        {/* New wave loader */}
        <div className="wave-loader"></div>
      </div>

      <div className="w-full mb-8">
        <div className="mt-2 text-gray-400 text-sm text-center">
          {steps[stepIndex]}
          {showWalletNotification() && (
            <div className="text-xs text-yellow-400 mt-1 wallet-notification">
              Please approve the transaction in your wallet
            </div>
          )}
        </div>
      </div>

      {/* Cancel button */}
      <button
        onClick={handleCancel}
        disabled={isCancelling}
        className="px-6 py-2 rounded-full bg-transparent border border-gray-600 text-gray-300 hover:border-red-500 hover:text-red-400 transition-colors"
      >
        {isCancelling ? "Cancelling..." : "Cancel"}
      </button>
    </div>
  );
}

// ===== src/components/ui/checkmark-animation.tsx =====

'use client';

import { useEffect, useRef } from 'react';
import '../../styles/checkmark.css';

export default function CheckmarkAnimation() {
  const animationRef = useRef<HTMLDivElement>(null);
  
  // Ensure the animation restarts when component mounts
  useEffect(() => {
    if (animationRef.current) {
      const checkmark = animationRef.current.querySelector('.checkmark') as HTMLElement;
      
      if (checkmark) {
        // Reset animations
        checkmark.style.animation = 'none';
        
        // Force reflow
        void checkmark.offsetWidth;
        
        // Restart animations
        checkmark.style.animation = '';
        
        // SVG elements need a different approach for animation reset
        const svgElements = animationRef.current.querySelectorAll('circle, path');
        svgElements.forEach(el => {
          // Remove and re-add the element to force animation restart
          const parent = el.parentNode;
          if (parent) {
            const clone = el.cloneNode(true);
            parent.removeChild(el);
            setTimeout(() => parent.appendChild(clone), 0);
          }
        });
      }
    }
  }, []);

  return (
    <div className="checkmark-container">
      <div className="success-checkmark" ref={animationRef}>
        <svg 
          className="checkmark" 
          xmlns="http://www.w3.org/2000/svg" 
          viewBox="0 0 52 52"
        >
          <circle 
            className="checkmark__circle" 
            cx="26" 
            cy="26" 
            r="25" 
            fill="none"
          />
          <path 
            className="checkmark__check" 
            fill="none" 
            d="M14.1 27.2l7.1 7.2 16.7-16.8"
          />
        </svg>
      </div>
    </div>
  );
}

// ===== src/components/home/hero-section.tsx =====

'use client';
import { useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';

export default function HeroSection() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    // Simple particle background effect
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let particles: { x: number; y: number; vx: number; vy: number; }[] = [];
    const createParticles = () => {
      particles = Array.from({ length: 100 }).map(() => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
      }));
    };
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      createParticles();
    };
    resize();
    window.addEventListener('resize', resize);

    const animate = () => {
      if (!ctx) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      });
      requestAnimationFrame(animate);
    };
    animate();
    return () => window.removeEventListener('resize', resize);
  }, []);

  return (
    <section className="relative h-screen flex items-center justify-center overflow-hidden">
      <canvas ref={canvasRef} className="absolute inset-0" />
      <motion.div
        initial={{ y: 50, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{ delay: 0.5, duration: 1 }}
        className="relative text-center px-4"
      >
        <h1 className="text-5xl md:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
          Launch Your Solana Token Today
        </h1>
        <p className="mt-4 text-gray-400 text-lg md:text-xl max-w-2xl mx-auto">
          Create, launch, and manage Solana tokens effortlessly with SolMinter.
        </p>
        <div className="mt-8 flex justify-center gap-4">
          <Link
            href="/create-token"
            className="bg-gradient-to-r from-purple-600 to-blue-500 py-3 px-8 rounded-full text-white hover:shadow-lg transition"
          >
            Create Token
          </Link>
          <Link
            href="/guides"
            className="border border-purple-500 py-3 px-8 rounded-full text-purple-500 hover:bg-purple-500 hover:text-white transition"
          >
            Learn More
          </Link>
        </div>
      </motion.div>
    </section>
  );
}

// ===== src/components/home/how-it-works-section.tsx =====

'use client';
import { motion } from 'framer-motion';

const steps = [
  { number: 1, title: 'Upload Logo', description: 'Add your token logo and details.' },
  { number: 2, title: 'Configure Options', description: 'Set authorities, socials, and creator info.' },
  { number: 3, title: 'Review & Launch', description: 'Confirm & approve transaction in your wallet.' },
];

export default function HowItWorksSection() {
  return (
    <section className="py-20">
      <div className="max-w-5xl mx-auto px-4 text-center">
        <h2 className="text-3xl font-bold text-white mb-12">How It Works</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          {steps.map((s) => (
            <motion.div
              key={s.number}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ duration: 0.5 }}
              className="bg-[#171717] p-6 rounded-2xl shadow-lg"
            >
              <div className="text-purple-500 text-2xl font-bold mb-4">{s.number}</div>
              <h3 className="text-xl font-semibold text-white mb-2">{s.title}</h3>
              <p className="text-gray-400">{s.description}</p>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  );
}

// ===== src/components/home/features-section.tsx =====

'use client';
import { motion } from 'framer-motion';

const features = [
  {
    title: 'Easy Token Creation',
    description: 'Mint your token in just a few clicks—no coding required.',
    icon: (
      <svg className="w-8 h-8 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 ..." />
      </svg>
    ),
  },
  {
    title: 'Secure & Trusted',
    description: 'Built on Solana for blazing speed and top-tier security standards.',
    icon: (
      <svg className="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4 ..." />
      </svg>
    ),
  },
  {
    title: 'Lightning Fast',
    description: 'Launch in seconds with minimal network fees.',
    icon: (
      <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
      </svg>
    ),
  },
];

export default function FeaturesSection() {
  return (
    <section className="py-20 bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 text-center">
        <h2 className="text-3xl font-bold text-white mb-12">Why Choose SolMinter?</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          {features.map((f, i) => (
            <motion.div
              key={f.title}
              whileHover={{ scale: 1.05 }}
              transition={{ duration: 0.3 }}
              className="bg-[#171717] p-6 rounded-2xl shadow-lg"
            >
              <div className="mb-4 flex justify-center">{f.icon}</div>
              <h3 className="text-xl font-semibold text-white mb-2">{f.title}</h3>
              <p className="text-gray-400">{f.description}</p>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  );
}

// ===== src/components/home/cta-section.tsx =====

'use client';
import { motion } from 'framer-motion';
import Link from 'next/link';

export default function CTASection() {
  return (
    <section className="py-20 bg-gradient-to-r from-purple-900 to-blue-900">
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        whileInView={{ scale: 1, opacity: 1 }}
        viewport={{ once: true }}
        transition={{ duration: 0.6 }}
        className="max-w-3xl mx-auto text-center px-4"
      >
        <h2 className="text-4xl font-bold text-white mb-6">Ready to Launch Your Token?</h2>
        <p className="text-gray-300 mb-8">
          Join hundreds of creators using SolMinter to bring their projects to life.
        </p>
        <Link
          href="/create-token"
          className="bg-white text-black font-semibold py-3 px-8 rounded-full hover:shadow-xl transition"
        >
          Get Started Now
        </Link>
      </motion.div>
    </section>
  );
}

// ===== src/components/layout/navbar.tsx =====

'use client';

import Link from 'next/link';
import { useEffect, useState } from 'react';
import WalletButton from '../wallet/wallet-button';

export default function Navbar() {
  const [scrolled, setScrolled] = useState(false);
  
  // Track scroll position to add shadow and background when scrolled
  useEffect(() => {
    const handleScroll = () => {
      const isScrolled = window.scrollY > 10;
      if (isScrolled !== scrolled) {
        setScrolled(isScrolled);
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [scrolled]);

  return (
    <div 
      className={`fixed top-4 left-0 right-0 z-50 transition-all duration-300 ${
        scrolled ? 'top-2' : 'top-4'
      }`}
    >
      <div className="max-w-6xl mx-auto px-4">
        <div 
          className={`nav-container rounded-full py-3 px-6 transition-all duration-300 ${
            scrolled 
              ? 'bg-black/50 backdrop-blur-md shadow-lg shadow-black/20' 
              : 'bg-transparent'
          }`}
        >
          <div className="flex justify-between items-center">
            <Link href="/" className="logo-container flex items-center">
              <div className="logo-img">
                <span className="text-2xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
                  SolMinter
                </span>
              </div>
            </Link>

            <nav className="main-nav hidden md:flex space-x-6">
              <Link
                href="/"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                Home
              </Link>
              <Link
                href="/create-token"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                Create Token
              </Link>
              <Link
                href="/my-tokens"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                My Tokens
              </Link>
              <a
                href="https://raydium.io/liquidity/create-pool"
                className="nav-link text-gray-300 hover:text-white transition-colors"
                rel="noopener noreferrer"
                target="_blank"
              >
                Liquidity Pool
              </a>
              <a
                href="https://raydium.io/swap"
                className="nav-link text-gray-300 hover:text-white transition-colors"
                rel="noopener noreferrer"
                target="_blank"
              >
                Manage Liquidity
              </a>
              <Link
                href="/guides"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                Guides
              </Link>
            </nav>

            <div className="wallet-dropdown">
              <WalletButton />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/layout/footer.tsx =====

'use client';

import Link from 'next/link';

export default function Footer() {
  return (
    <div className="footer-container bg-[#111] border-t border-gray-800 py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <Link href="/" className="logo-container mb-4 md:mb-0">
            <div className="logo-img">
              <span className="text-xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <div className="bottom-bar flex flex-col md:flex-row items-center">
            <div className="copyright-bar text-gray-500 text-sm mb-2 md:mb-0">
              <span>© SolMinter 2025</span>
            </div>
            
            <div className="policies-bar flex ml-0 md:ml-6">
              <Link href="/terms" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Terms of Service
              </Link>
              <span className="separator mx-2 text-gray-600">|</span>
              <Link href="/privacy" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Privacy Policy
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-button.tsx =====

'use client';

import { useCallback, useEffect, useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { formatWalletAddress, getWalletBalance, saveWalletPublicKey } from '@/services/wallet-service';
import { debugWallet } from '@/utils/wallet-debug';

export default function WalletButton() {
  const { publicKey, connected, connecting, disconnecting, wallet } = useWallet();
  const [mounted, setMounted] = useState(false);
  const [balance, setBalance] = useState<number | null>(null);
  
  // Load balance when connected
  const loadBalance = useCallback(async () => {
    if (connected && publicKey) {
      try {
        const sol = await getWalletBalance(publicKey);
        setBalance(sol);
      } catch (error) {
        console.error('Error fetching balance:', error);
      }
    } else {
      setBalance(null);
    }
  }, [connected, publicKey]);

  // Only show the component after mounting to prevent hydration errors
  useEffect(() => {
    setMounted(true);
  }, []);

  // Fetch balance when connected
  useEffect(() => {
    if (connected && publicKey) {
      loadBalance();
      
      // Save the public key to localStorage for use in IPFS naming
      saveWalletPublicKey(publicKey.toString());
    }
  }, [connected, publicKey, loadBalance]);

  // Format public key for display
  const getFormattedAddress = () => {
    if (!publicKey) return '';
    return formatWalletAddress(publicKey.toString());
  };

  // Add logging for debugging connection issues
  useEffect(() => {
    if (connecting) {
      console.log('Wallet connecting...');
    } else if (disconnecting) {
      console.log('Wallet disconnecting...');
    } else if (connected) {
      console.log('Wallet connected:', getFormattedAddress());
      debugWallet(wallet);
    }
  }, [connecting, disconnecting, connected, publicKey, wallet]);
  
  if (!mounted) {
    // Return a placeholder with the same dimensions to prevent layout shift
    return <div className="wallet-button-placeholder"></div>;
  }
  
  return (
    <div className="wallet-button relative">
      <WalletMultiButton 
        className="wallet-adapter-button-trigger !bg-gradient-to-r from-purple-600 to-blue-500 !rounded-full transition-all hover:shadow-lg" 
      />
      
      {connected && balance !== null && (
        <div className="wallet-balance absolute -bottom-6 right-0 text-xs text-gray-300 bg-black/50 backdrop-blur-sm px-2 py-1 rounded-full">
          {balance.toFixed(2)} SOL
        </div>
      )}
    </div>
  );
}

// ===== src/components/wallet/wallet-provider.tsx =====

'use client';

import { FC, ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Default styles that can be overridden by your app
import '@solana/wallet-adapter-react-ui/styles.css';

interface WalletContextProviderProps {
  children: ReactNode;
}

export const WalletContextProvider: FC<WalletContextProviderProps> = ({ children }) => {
  // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.
  const network = WalletAdapterNetwork.Devnet;

  // You can also provide a custom RPC endpoint.
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Only include Phantom wallet adapter to minimize dependency issues
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

// ===== src/components/wallet/wallet-required.tsx =====

'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

interface WalletRequiredProps {
  message?: string;
}

export default function WalletRequired({ message = 'Please connect your wallet to continue' }: WalletRequiredProps) {
  const { connected } = useWallet();

  if (connected) {
    return null;
  }

  return (
    <div className="min-h-[80vh] bg-[#0a0a0a] flex items-center justify-center p-4">
      <div className="max-w-3xl w-full mx-auto p-10 bg-[#171717] rounded-xl text-center">
        <div className="w-20 h-20 bg-purple-900/20 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg className="w-10 h-10 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-4">Connect Your Wallet</h2>
        <p className="text-gray-400 mb-8">
          {message}
        </p>
        
        <div className="flex justify-center">
          <WalletMultiButton className="wallet-adapter-button-trigger !bg-gradient-to-r from-purple-600 to-blue-500 !rounded-full transition-all hover:shadow-lg" />
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-provider-client.tsx =====

'use client';

import { ReactNode, useEffect, useMemo, useState } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare';

import { LedgerWalletAdapter } from '@solana/wallet-adapter-ledger';
// Removed the TorusWalletAdapter as it's causing dependency issues
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface ClientWalletProviderProps {
  children: ReactNode;
}

export function ClientWalletProvider({ children }: ClientWalletProviderProps) {
  // Track component mounting state to prevent hydration issues
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  // Set the network from environment variables
  const networkEnv = SOLANA_NETWORK || 'devnet';
  const network = networkEnv === 'mainnet-beta' 
    ? WalletAdapterNetwork.Mainnet
    : WalletAdapterNetwork.Devnet;

  // Set up the RPC endpoint
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Add a more comprehensive list of wallet adapters (except Torus which causes issues)
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),

      new LedgerWalletAdapter()
    ],
    [network]
  );

  // Only render the provider once the component is mounted to avoid hydration errors
  if (!mounted) return null;

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect={false}>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

// ===== src/services/ipfs-service.ts =====

// src/services/ipfs-service.ts

/**
 * Service for handling IPFS uploads via Pinata
 */

import { FormDataType } from "@/types/token";
import { v4 as uuidv4 } from "uuid"; // Need to add this dependency
import { setCurrentSessionUuid } from "./pinata-cleanup";

// Store the current UUID for the token creation session
let currentSessionUuid: string | null = null;

// Helper function to get the current wallet's public key
function getCurrentWalletPublicKey(): string {
  // Check if we're in a browser environment and window is defined
  if (typeof window !== "undefined") {
    // Try to get the public key from local storage if it's been saved there
    const savedPublicKey = localStorage.getItem("walletPublicKey");
    if (savedPublicKey) {
      return savedPublicKey;
    }
  }
  // Fallback if we can't get the actual public key
  return "unknown_wallet";
}

// Helper function to get the current session UUID or create a new one
function getSessionUuid(): string {
  if (!currentSessionUuid) {
    currentSessionUuid = uuidv4();
    console.log(`Created new session UUID: ${currentSessionUuid}`);

    // Sync with cleanup service
    setCurrentSessionUuid(currentSessionUuid);
  }
  return currentSessionUuid;
}

// Helper function to reset the session UUID (call this at the start of a new token creation)
export function resetSessionUuid(): void {
  currentSessionUuid = null;
  console.log("Reset session UUID for new token creation");

  // Sync with cleanup service
  setCurrentSessionUuid(null);
}

// Helper function to generate a unique file name based on wallet, UUID, and type
function generateUniqueFileName(
  type: "image" | "metadata" | "final_metadata",
  tokenKey?: string
): string {
  const walletPublicKey = getCurrentWalletPublicKey();

  // For the initial uploads, use the same UUID for both image and metadata
  if (type === "image" || type === "metadata") {
    // Use the current session UUID
    const uuid = getSessionUuid();

    if (type === "image") {
      return `${walletPublicKey}_${uuid}_image`;
    } else {
      return `${walletPublicKey}_${uuid}_metadata`;
    }
  }

  // For the final metadata after minting, use the token key
  if (type === "final_metadata" && tokenKey) {
    return `${walletPublicKey}_${tokenKey}`;
  }

  // Fallback name with timestamp
  const timestamp = Date.now();
  return `${walletPublicKey}_${timestamp}_${type}`;
}

/**
 * Uploads an image file to IPFS via Pinata
 * @returns IPFS URL for the uploaded image
 */
export async function uploadImageToIPFS(
  file: File,
  tokenName: string,
  tokenSymbol: string
): Promise<string> {
  try {
    // Reset the session UUID at the start of a new token creation
    resetSessionUuid();

    // Generate a unique filename using our new naming convention
    const uniqueFileName = generateUniqueFileName("image");
    const fileExtension = file.name.split(".").pop() || "png";
    const newFileName = `${uniqueFileName}.${fileExtension}`;

    // Create a new file with the unique name
    const uniqueFile = new File([file], newFileName, { type: file.type });

    // Create FormData to send to the API
    const formData = new FormData();
    formData.append("file", uniqueFile);

    // Add the unique filename as metadata
    formData.append("fileName", newFileName);

    console.log(`Uploading image as: ${newFileName}`);

    const res = await fetch("/api/upload-image", {
      method: "POST",
      body: formData,
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Image upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const imageUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(`Image uploaded successfully: ${imageUrl}`);
    return imageUrl;
  } catch (error) {
    console.error("Error uploading image to IPFS:", error);
    throw error;
  }
}

export interface MetadataPayload {
  name: string;
  symbol: string;
  description: string;
  image: string;
  mint?: string; // Optional mint address (added after token creation)
  creator?: string;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  // Additional fields from your non-Next.js implementation
  showName?: boolean;
  tokenInfo?: {
    chain: string;
    totalSupply: number;
    circulatingSupply: number;
    decimals: number;
  };
  createdOn?: string;
  // New metadata fields for authority status
  authorities?: {
    mintRevoked: boolean;
    freezeRevoked: boolean;
    updateRevoked: boolean;
  };
  // Removed sessionUuid from the interface as we don't want it in customer-facing metadata
}

/**
 * Uploads token metadata to IPFS via Pinata
 * @returns IPFS URL for the uploaded metadata
 */
export async function uploadMetadataToIPFS(
  payload: MetadataPayload
): Promise<string> {
  try {
    // Generate a unique filename based on our new naming convention
    // This will use the same UUID as the image since we're using the session UUID
    const uniqueFileName = generateUniqueFileName("metadata");

    // Construct the complete metadata object similar to your non-Next.js version
    const metadata: any = {
      // Core token information
      name: payload.name,
      symbol: payload.symbol,
      description: payload.description,
      image: payload.image,

      // Display preference
      showName: true,

      // Token information
      tokenInfo: {
        chain: "Solana",
        totalSupply: payload.tokenInfo?.totalSupply || 0,
        circulatingSupply: payload.tokenInfo?.circulatingSupply || 0,
        decimals: payload.tokenInfo?.decimals || 9,
      },

      // Add mint address if available (could be added later)
      ...(payload.mint && { mint: payload.mint }),

      // Add creator if provided
      ...(payload.creator && { creator: payload.creator }),

      // Add social links if provided
      ...(payload.website && { website: payload.website }),
      ...(payload.twitter && { twitter: payload.twitter }),
      ...(payload.telegram && { telegram: payload.telegram }),
      ...(payload.discord && { discord: payload.discord }),

      // Origin
      createdOn: "SolMinter",

      // Add authority status if provided
      ...(payload.authorities && { authorities: payload.authorities }),

      // Removed sessionUuid from the actual metadata
    };

    // In Pinata metadata (separate from the token metadata)
    const pinataMetadata = {
      name: `${uniqueFileName}.json`,
      keyvalues: {
        app: "SolMinter",
        type: "token_metadata",
        symbol: payload.symbol,
        timestamp: Date.now().toString(),
        sessionUuid: getSessionUuid(), // Keep tracking the session UUID in Pinata metadata
      }
    };

    console.log(
      `Uploading metadata for: ${payload.name} (${payload.symbol}) as ${uniqueFileName}`
    );

    const res = await fetch("/api/upload-metadata", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        metadata,
        fileName: `${uniqueFileName}.json`,
        pinataMetadata, // Pass the Pinata metadata separately
      }),
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Metadata upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const metadataUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(`Metadata uploaded successfully: ${metadataUrl}`);
    return metadataUrl;
  } catch (error) {
    console.error("Error uploading metadata to IPFS:", error);
    throw error;
  }
}

/**
 * Update token metadata with mint address after token creation
 * @returns IPFS URL for the updated metadata
 */
export async function updateMetadataWithMintAddress(
  originalMetadataUrl: string,
  mintAddress: string,
  formData: FormDataType,
  imageUrl: string // Add imageUrl parameter to ensure we use the correct image URL
): Promise<string> {
  try {
    // Create updated metadata payload with mint address and use the token key in the filename
    const payload: MetadataPayload = {
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      image: imageUrl, // Use the actual image URL instead of the metadata URL
      mint: mintAddress,
      creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
      tokenInfo: {
        chain: "Solana",
        totalSupply: formData.supply,
        circulatingSupply: formData.supply,
        decimals: formData.decimals,
      },
      // Add authority status information
      authorities: {
        mintRevoked: formData.revokeMint,
        freezeRevoked: formData.revokeFreeze,
        updateRevoked: formData.revokeUpdate,
      },
      // Removed sessionUuid from the payload
    };

    // Add social links if enabled
    if (formData.socialLinks) {
      payload.website = formData.website || undefined;
      payload.twitter = formData.twitter || undefined;
      payload.telegram = formData.telegram || undefined;
      payload.discord = formData.discord || undefined;
    }

    // Generate the final metadata filename using the token mint address
    const uniqueFileName = generateUniqueFileName(
      "final_metadata",
      mintAddress
    );
    
    // In Pinata metadata (separate from the token metadata)
    const pinataMetadata = {
      name: `${uniqueFileName}.json`,
      keyvalues: {
        app: "SolMinter",
        type: "token_metadata",
        symbol: formData.symbol,
        mintAddress: mintAddress,
        timestamp: Date.now().toString(),
        sessionUuid: currentSessionUuid || "unknown", // Keep tracking in Pinata metadata only
      }
    };

    // Upload the updated metadata with the new filename
    const res = await fetch("/api/upload-metadata", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        metadata: payload,
        fileName: `${uniqueFileName}.json`,
        pinataMetadata, // Pass the Pinata metadata separately
      }),
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Updated metadata upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const metadataUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(
      `Updated metadata uploaded successfully as ${uniqueFileName}: ${metadataUrl}`
    );

    // Reset the session UUID after the token is fully created
    resetSessionUuid();

    return metadataUrl;
  } catch (error) {
    console.error("Error updating metadata with mint address:", error);
    throw error;
  }
}

/**
 * Gets the current session UUID
 * Useful for cleanup operations
 */
export function getCurrentSessionUuid(): string | null {
  return currentSessionUuid;
}

// ===== src/services/pinata-cleanup.ts =====

// src/services/pinata-cleanup.ts

/**
 * Utility functions for cleaning up Pinata IPFS files
 * Used when a token creation transaction is canceled
 */

let currentSessionUuid: string | null = null;

/**
 * Gets the current session UUID
 * This UUID is used to track files uploaded during a token creation attempt
 */
export function getCurrentSessionUuid(): string | null {
  return currentSessionUuid;
}

/**
 * Sets the current session UUID from the IPFS service
 * Should be called when the IPFS service generates a new UUID
 */
export function setCurrentSessionUuid(uuid: string | null): void {
  currentSessionUuid = uuid;
  console.log(`Session UUID ${uuid ? `set to: ${uuid}` : 'cleared'}`);
}

/**
 * Deletes all Pinata files associated with the current session UUID
 * Called when a token creation transaction fails or is canceled
 * This function is exported for use by the Cancel button in the Loading component
 */
export async function cleanupSessionFiles(): Promise<boolean> {
  if (!currentSessionUuid) {
    console.log('No session UUID to cleanup');
    return false;
  }
  
  try {
    console.log(`Cleaning up Pinata files for session: ${currentSessionUuid}`);
    
    const response = await fetch('/api/delete-pinata-files', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        uuid: currentSessionUuid
      }),
    });
    
    if (!response.ok) {
      console.error('Failed to cleanup Pinata files:', await response.text());
      return false;
    }
    
    const result = await response.json();
    console.log('Pinata cleanup result:', result);
    
    // Clear the session UUID after successful cleanup
    currentSessionUuid = null;
    
    return true;
  } catch (error) {
    console.error('Error cleaning up Pinata files:', error);
    return false;
  }
}

/**
 * Handles error by cleaning up any uploaded files if the error matches known patterns
 * for user cancellation or transaction failure
 * 
 * @param error The error object or string
 * @returns The original error for further handling
 */
export async function handleErrorWithCleanup(error: unknown): Promise<unknown> {
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  // Check if the error is a user cancellation or transaction failure
  if (
    errorMessage.includes('Transaction was canceled by the user') ||
    errorMessage.includes('User rejected') ||
    errorMessage.includes('Wallet adapter error') ||
    errorMessage.includes('Failed to process transaction')
  ) {
    console.log('Transaction was canceled. Cleaning up Pinata files...');
    await cleanupSessionFiles();
  }
  
  // Return the original error for further handling
  return error;
}

// ===== src/services/token-service.ts =====

// src/services/token-service.ts
// Main orchestration of token creation process

import { WalletContextState } from "@solana/wallet-adapter-react";
import { Connection } from "@solana/web3.js";
import { FormDataType, TokenResult } from "@/types/token";
import { SOLANA_NETWORK_FEE } from "@/config";
import { uploadImageToIPFS, uploadMetadataToIPFS } from "./ipfs-service";
import { getSolanaConnection, saveWalletPublicKey } from "./wallet-service";
import { createTokenClientSide } from "./token-creation/client-side-creation";
import { createTokenServerSide } from "./token-creation/server-side-creation";
import { handleErrorWithCleanup } from "./pinata-cleanup";

/**
 * Orchestrates token creation with a single transaction
 * Network fees are deducted from the fee recipient amount, so the user pays EXACTLY the displayed fee
 */
export async function createTokenWithMetadata(
  walletAdapter: WalletContextState,
  formData: FormDataType,
  totalFee: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, connected } = walletAdapter;
  if (!connected || !publicKey) {
    throw new Error("Wallet not connected. Please connect your wallet first.");
  }
  const connection: Connection = getSolanaConnection();

  // Ensure public key is saved for IPFS naming
  saveWalletPublicKey(publicKey.toString());

  // Validate inputs
  if (!formData.logo) {
    throw new Error("Please upload a logo image");
  }
  if (!formData.name || formData.name.trim() === "") {
    throw new Error("Token name is required");
  }
  if (!formData.symbol || formData.symbol.trim() === "") {
    throw new Error("Token symbol is required");
  }
  if (!formData.description || formData.description.trim() === "") {
    throw new Error("Token description is required");
  }

  // Ensure minimum fee
  const minimumFeeInSOL = 0.1;
  if (totalFee < minimumFeeInSOL) {
    console.warn(
      `Fee is too low (${totalFee}), using minimum fee of ${minimumFeeInSOL} SOL`
    );
    totalFee = minimumFeeInSOL;
  }

  // Calculate the net fee after subtracting the Solana network fee
  const networkFee = SOLANA_NETWORK_FEE;
  const netFeeAmount = Math.max(totalFee - networkFee, 0);

  console.log("Creating token with displayed fee:", totalFee, "SOL");
  console.log("Solana network fee:", networkFee, "SOL");
  console.log("Net fee to fee recipient:", netFeeAmount, "SOL");
  console.log("Token options:", {
    revokeMint: formData.revokeMint,
    revokeFreeze: formData.revokeFreeze,
    revokeUpdate: formData.revokeUpdate,
    socialLinks: formData.socialLinks,
    creatorInfo: formData.creatorInfo,
  });

  try {
    // STEP 0: IPFS image with unique name (now using {public_key}_{random_uuid}_image pattern)
    onProgress?.(0);
    const imageUrl = await uploadImageToIPFS(formData.logo, formData.name, formData.symbol);

    // STEP 1: IPFS metadata JSON (now using {public_key}_{random_uuid}_metadata pattern)
    onProgress?.(1);
    const metadataUrl = await uploadMetadataToIPFS({
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      image: imageUrl,
      creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
      showName: true,
      tokenInfo: {
        chain: "Solana",
        totalSupply: formData.supply,
        circulatingSupply: formData.supply,
        decimals: formData.decimals,
      },
      createdOn: "SolMinter",
      // Add authorities status for initial metadata as well
      authorities: {
        mintRevoked: formData.revokeMint,
        freezeRevoked: formData.revokeFreeze,
        updateRevoked: formData.revokeUpdate
      },
      ...(formData.socialLinks && {
        website: formData.website,
        twitter: formData.twitter,
        telegram: formData.telegram,
        discord: formData.discord,
      }),
    });

    // STEP 2: Choose flow based on whether we need to revoke update authority
    onProgress?.(2);
    
    // Check whether to use server-side update authority (only when revoking update)
    if (formData.revokeUpdate) {
      return createTokenServerSide(
        walletAdapter,
        connection,
        formData,
        metadataUrl,
        imageUrl,
        netFeeAmount,
        onProgress
      );
    } else {
      return createTokenClientSide(
        walletAdapter,
        connection,
        formData,
        metadataUrl,
        imageUrl,
        netFeeAmount,
        onProgress
      );
    }
  } catch (error) {
    // Handle error with Pinata cleanup
    console.error("Error in token creation process:", error);
    await handleErrorWithCleanup(error);
    
    // Rethrow the error for the UI to handle
    throw error;
  }
}

// ===== src/services/token-discovery-service.ts =====

// src/services/token-discovery-service.ts
// Service to discover tokens minted by the user

import { MintedTokenInfo } from '@/types/token';
import { PINATA_GATEWAY } from '@/config';

/**
 * Fetches tokens minted by a user from Pinata IPFS
 * @param publicKey - The public key of the user's wallet
 * @returns Array of minted token information
 */
export async function getUserMintedTokens(publicKey: string): Promise<MintedTokenInfo[]> {
  try {
    console.log(`Fetching tokens for wallet: ${publicKey}`);
    
    // Call our API endpoint that will search Pinata for user tokens
    const response = await fetch(`/api/user-tokens?publicKey=${encodeURIComponent(publicKey)}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user tokens: ${response.statusText}`);
    }

    const data = await response.json();
    return data.tokens;
  } catch (error) {
    console.error('Error in getUserMintedTokens:', error);
    throw error;
  }
}

/**
 * Fetches individual token data from IPFS URL
 * @param ipfsUrl - The IPFS URL to the token metadata
 * @returns Parsed token metadata
 */
export async function getTokenMetadata(ipfsUrl: string): Promise<MintedTokenInfo> {
  try {
    const response = await fetch(ipfsUrl);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch token metadata: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching token metadata:', error);
    throw error;
  }
}

/**
 * Fetches token metadata for multiple tokens
 * @param cidList - List of CIDs to fetch
 * @returns Mapped token information
 */
export async function getTokensMetadata(cidList: string[]): Promise<MintedTokenInfo[]> {
  try {
    const gateway = PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    // Fetch all token metadata in parallel
    const tokenPromises = cidList.map(async (cid) => {
      const url = `https://${gateway}/ipfs/${cid}`;
      return getTokenMetadata(url);
    });
    
    return await Promise.all(tokenPromises);
  } catch (error) {
    console.error('Error in getTokensMetadata:', error);
    throw error;
  }
}

// ===== src/services/fee-service.ts =====

// src/services/fee-service.ts

export interface FeeOptions {
  revokeMint: boolean
  revokeFreeze: boolean
  revokeUpdate: boolean
  socialLinks: boolean
  creatorInfo: boolean
}

// Base fee plus optional feature fees
export function calculateFee(options: FeeOptions): number {
  let fee = 0.1; // Base fee for token creation - corrected to 0.1

  // Add fee for each enabled feature
  if (options.revokeMint)    fee += 0.1;
  if (options.revokeFreeze)  fee += 0.1;
  if (options.revokeUpdate)  fee += 0.1;
  if (options.socialLinks)   fee += 0.1;
  if (options.creatorInfo)   fee += 0.1;

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

// Format the fee for display
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

// ===== src/services/token-creation/server-side-creation.ts =====

// src/services/token-creation/server-side-creation.ts
// Handles server-side token creation flow (when revokeUpdate is true)

import {
  Connection,
  Transaction,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import type { WalletContextState } from "@solana/wallet-adapter-react";
import { FormDataType, TokenResult } from "@/types/token";
import { updateMetadataWithMintAddress } from "../ipfs-service";
import { handleErrorWithCleanup } from "../pinata-cleanup";

/**
 * Creates a token using server-side signing for update authority
 * Used when revokeUpdate is true
 */
export async function createTokenServerSide(
  walletAdapter: WalletContextState,
  connection: Connection,
  formData: FormDataType,
  metadataUrl: string,
  imageUrl: string,
  netFeeAmount: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction } = walletAdapter;

  // Validate that publicKey and signTransaction are available
  if (!publicKey) {
    throw new Error("Public key is null. Wallet must be connected.");
  }

  if (!signTransaction) {
    throw new Error("Wallet does not support transaction signing");
  }

  try {
    // Generate mint keypair client-side
    const mintKeypair = Keypair.generate();
    const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);
    const mintPrivateKey = Buffer.from(mintKeypair.secretKey).toString(
      "base64"
    );
    const { blockhash } = await connection.getLatestBlockhash();

    // Request server-side signing
    const response = await fetch("/api/sign-transaction", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        mintPrivateKey,
        metadataUrl,
        tokenName: formData.name,
        tokenSymbol: formData.symbol,
        tokenDecimals: formData.decimals,
        tokenSupply: formData.supply,
        payerPublicKey: publicKey.toString(), // Safe to call toString() now
        hasCreators: true, // IMPORTANT FIX: Always include creators
        revokeUpdate: formData.revokeUpdate,
        revokeMint: formData.revokeMint,
        revokeFreeze: formData.revokeFreeze,
        recentBlockhash: blockhash,
        feeWalletPubkey: process.env.NEXT_PUBLIC_FEE_WALLET,
        feeAmountInLamports,
        includeFeeTx: netFeeAmount > 0,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        errorData.error || "Failed to sign transaction on server"
      );
    }

    const { signedTransaction, mintAddress } = await response.json();
    const transaction = Transaction.from(
      Buffer.from(signedTransaction, "base64")
    );
    console.log(
      "Transaction constructed and signed by server for update authority"
    );

    onProgress?.(3);

    // Properly handle wallet rejection
    let walletSignedTransaction;
    try {
      walletSignedTransaction = await signTransaction(transaction);
    } catch (walletError) {
      console.error("Wallet signature rejected by user:", walletError);
      // Handle the error with cleanup
      await handleErrorWithCleanup(
        new Error("Transaction was canceled by the user")
      );
      throw new Error("Transaction was canceled by the user");
    }

    if (!walletSignedTransaction) {
      // Handle the error with cleanup
      await handleErrorWithCleanup(new Error("Transaction signing failed"));
      throw new Error("Transaction signing failed");
    }

    // Send and confirm transaction
    const txSignature = await connection.sendRawTransaction(
      walletSignedTransaction.serialize()
    );
    await connection.confirmTransaction(txSignature);
    console.log("Transaction confirmed successfully!");

    onProgress?.(6);

    // Update metadata with mint address
    // Now using {public_key}_{token_key} naming pattern
    // Now using {public_key}_{token_key} naming pattern
    const updatedMetadataUrl = await updateMetadataWithMintAddress(
      metadataUrl,
      mintAddress,
      formData,
      imageUrl // Pass the actual image URL
    );

    const clusterParam =
      process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
        ? "?cluster=devnet"
        : "";

    return {
      mintAddress,
      metadataUrl: updatedMetadataUrl,
      imageUrl,
      explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
    };
  } catch (error) {
    console.error("Error in server-side update authority flow:", error);
    // Make sure to clean up Pinata files in case of an error
    await handleErrorWithCleanup(error);

    throw new Error(
      `Failed to process transaction: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}


// ===== src/services/token-creation/token-types.ts =====

// src/services/token-creation/token-types.ts
// Type definitions for token creation process

import { PublicKey } from "@solana/web3.js";

/**
 * Metadata parameters for token creation
 */
export interface TokenMetadataParams {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: TokenCreator[] | null;
  collection: TokenCollection | null;
  uses: any | null;
  isMutable: boolean;
}

/**
 * Creator information for token metadata
 */
export interface TokenCreator {
  address: PublicKey;
  verified: boolean;
  share: number;
}

/**
 * Collection information for token metadata
 */
export interface TokenCollection {
  key: string;
  verified: boolean;
}

/**
 * Parameters for server-side transaction signing
 */
export interface ServerSignParams {
  mintPrivateKey: string;
  metadataUrl: string;
  tokenName: string;
  tokenSymbol: string;
  tokenDecimals: number;
  tokenSupply: number;
  payerPublicKey: string;
  hasCreators: boolean;
  revokeUpdate: boolean;
  revokeMint: boolean;
  revokeFreeze: boolean;
  recentBlockhash: string;
  feeWalletPubkey?: string;
  feeAmountInLamports: number;
  includeFeeTx: boolean;
}

/**
 * Response from server-side transaction signing
 */
export interface ServerSignResponse {
  success: boolean;
  signedTransaction: string;
  updateAuthority: string;
  mintAddress: string;
  error?: string;
}

// ===== src/services/token-creation/metadata-serializer.ts =====

// src/services/token-creation/metadata-serializer.ts
// Handles serialization of token metadata for on-chain storage

import { PublicKey } from "@solana/web3.js";

/**
 * Serializes a UTF-8 string with u32-length prefix (LE)
 */
export function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/**
 * Metadata parameters for token creation
 */
interface TokenMetadataParams {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: TokenCreator[] | null;
  collection: TokenCollection | null;
  uses: any | null;
  isMutable: boolean;
}

/**
 * Creator information for token metadata
 */
interface TokenCreator {
  address: PublicKey;
  verified: boolean;
  share: number;
}

/**
 * Collection information for token metadata
 */
interface TokenCollection {
  key: string;
  verified: boolean;
}

/**
 * Serializes metadata for Metaplex createMetadataAccountV3 instruction
 */
export function serializeMetadataV3(data: TokenMetadataParams): Uint8Array {
  // Serialize name, symbol, and URI
  const nameBuffer = serializeString(data.name);
  const symbolBuffer = serializeString(data.symbol);
  const uriBuffer = serializeString(data.uri);
  
  // Serialize seller fee basis points (u16)
  const sellerFeeBasisPointsBuffer = Buffer.alloc(2);
  sellerFeeBasisPointsBuffer.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  // Serialize creators (Option<Vec<Creator>>)
  let creatorsBuffer;
  if (data.creators === null) {
    creatorsBuffer = Buffer.from([0]); // None
  } else {
    const creatorsVec = Buffer.concat(
      data.creators.map((creator) => {
        const address = creator.address.toBuffer();
        const verified = Buffer.from([creator.verified ? 1 : 0]);
        const share = Buffer.from([creator.share]);
        return Buffer.concat([address, verified, share]);
      })
    );

    const creatorsLength = Buffer.alloc(4);
    creatorsLength.writeUInt32LE(data.creators.length, 0);

    creatorsBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      creatorsLength,
      creatorsVec,
    ]);
  }

  // Serialize collection (Option<Collection>)
  let collectionBuffer;
  if (data.collection === null) {
    collectionBuffer = Buffer.from([0]); // None
  } else {
    collectionBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      new PublicKey(data.collection.key).toBuffer(),
      Buffer.from([data.collection.verified ? 1 : 0]),
    ]);
  }

  // Serialize uses (Option<Uses>) - not used so set to None
  const usesBuffer = Buffer.from([0]);

  // Serialize collection details (Option<CollectionDetails>) - not used so set to None
  const collectionDetailsBuffer = Buffer.from([0]);

  // Serialize isMutable
  const isMutableBuffer = Buffer.from([data.isMutable ? 1 : 0]);

  // Combine all serialized components
  return Buffer.concat([
    nameBuffer,
    symbolBuffer,
    uriBuffer,
    sellerFeeBasisPointsBuffer,
    creatorsBuffer,
    collectionBuffer,
    usesBuffer,
    collectionDetailsBuffer,
    isMutableBuffer,
  ]);
}

// ===== src/services/token-creation/client-side-creation.ts =====

// src/services/token-creation/client-side-creation.ts
// Handles client-side token creation flow (when revokeUpdate is false)

import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  TransactionInstruction,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  MINT_SIZE,
  createInitializeMintInstruction,
  getMinimumBalanceForRentExemptMint,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
} from "@solana/spl-token";
import type { WalletContextState } from "@solana/wallet-adapter-react";

import { FormDataType, TokenResult } from "@/types/token";
import { TOKEN_METADATA_PROGRAM_ID, FEE_RECIPIENT_WALLET } from "@/config";
import { serializeMetadataV3 } from "./metadata-serializer";
import { updateMetadataWithMintAddress } from "../ipfs-service";
import { handleErrorWithCleanup } from "../pinata-cleanup";

/**
 * Creates a token using client-side transaction flow
 * Used when revokeUpdate is false (no server-side update authority needed)
 */
export async function createTokenClientSide(
  walletAdapter: WalletContextState,
  connection: Connection,
  formData: FormDataType,
  metadataUrl: string,
  imageUrl: string,
  netFeeAmount: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction } = walletAdapter;

  // Validate that publicKey is not null before proceeding
  if (!publicKey) {
    throw new Error("Public key is null. Wallet must be connected.");
  }

  try {
    const mintKeypair = Keypair.generate();
    const rentExempt = await getMinimumBalanceForRentExemptMint(connection);

    const instructions: TransactionInstruction[] = [];
    const feeWalletPubkey = new PublicKey(FEE_RECIPIENT_WALLET);
    const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);

    // Add fee transfer instruction if needed
    if (feeAmountInLamports > 0) {
      instructions.push(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: feeWalletPubkey,
          lamports: feeAmountInLamports,
        })
      );
    } else {
      console.log("Net fee is zero or negative, skipping fee transfer");
    }

    // Create and initialize mint account
    instructions.push(
      SystemProgram.createAccount({
        fromPubkey: publicKey,
        newAccountPubkey: mintKeypair.publicKey,
        space: MINT_SIZE,
        lamports: rentExempt,
        programId: TOKEN_PROGRAM_ID,
      })
    );

    instructions.push(
      createInitializeMintInstruction(
        mintKeypair.publicKey,
        formData.decimals,
        publicKey,
        publicKey,
        TOKEN_PROGRAM_ID
      )
    );

    // Create associated token account and mint tokens
    const ata = await getAssociatedTokenAddress(
      mintKeypair.publicKey,
      publicKey
    );

    instructions.push(
      createAssociatedTokenAccountInstruction(
        publicKey,
        ata,
        publicKey,
        mintKeypair.publicKey
      )
    );

    const mintAmount =
      BigInt(formData.supply) * BigInt(10 ** formData.decimals);
    instructions.push(
      createMintToInstruction(mintKeypair.publicKey, ata, publicKey, mintAmount)
    );

    onProgress?.(4);

    // Create metadata
    const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        metadataProgramId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      metadataProgramId
    );

    // IMPORTANT FIX: Always include creators array with the user's wallet
    // This ensures the creator field is properly set in the Metaplex metadata
    const creators = [
      {
        address: publicKey,
        verified: true,
        share: 100,
      },
    ];

    // If custom creator info is enabled, we'll update the creator name in the URI metadata
    // but the on-chain Metaplex metadata should still have the actual wallet address

    instructions.push({
      programId: metadataProgramId,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
        { pubkey: publicKey, isSigner: true, isWritable: false }, // mint authority
        { pubkey: publicKey, isSigner: true, isWritable: false }, // payer
        { pubkey: publicKey, isSigner: false, isWritable: false }, // update authority
        {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false,
        },
      ],
      data: Buffer.concat([
        Buffer.from([33]), // createMetadataAccountV3 discriminator
        serializeMetadataV3({
          name: formData.name,
          symbol: formData.symbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators, // Always include creators array with user's wallet
          collection: null,
          uses: null,
          isMutable: false,
        }),
      ]),
    });

    onProgress?.(5);

    // Add authority revocation instructions if requested
    if (formData.revokeMint) {
      instructions.push(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          publicKey,
          AuthorityType.MintTokens,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    if (formData.revokeFreeze) {
      instructions.push(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          publicKey,
          AuthorityType.FreezeAccount,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    // Create and sign transaction
    const transaction = new Transaction();
    instructions.forEach((ix) => transaction.add(ix));
    transaction.feePayer = publicKey;
    transaction.recentBlockhash = (
      await connection.getLatestBlockhash()
    ).blockhash;
    transaction.partialSign(mintKeypair);

    console.log("Sending transaction to wallet for approval...");

    // Handle wallet rejection properly
    if (!signTransaction) {
      throw new Error("Wallet does not support transaction signing");
    }

    let signedTransaction;
    try {
      signedTransaction = await signTransaction(transaction);
    } catch (walletError) {
      console.error("Wallet signature rejected by user:", walletError);
      // Handle the error with cleanup
      await handleErrorWithCleanup(
        new Error("Transaction was canceled by the user")
      );
      throw new Error("Transaction was canceled by the user");
    }

    if (!signedTransaction) {
      // Handle the error with cleanup
      await handleErrorWithCleanup(new Error("Transaction signing failed"));
      throw new Error("Transaction signing failed");
    }

    // Send and confirm transaction
    const txSignature = await connection.sendRawTransaction(
      signedTransaction.serialize()
    );
    await connection.confirmTransaction(txSignature);

    const mintAddress = mintKeypair.publicKey.toString();
    onProgress?.(6);

    // Fix in createTokenClientSide function:

    // Update metadata with mint address - now using {public_key}_{token_key} format
    let finalMetadataUrl = metadataUrl;
    try {
      finalMetadataUrl = await updateMetadataWithMintAddress(
        metadataUrl,
        mintAddress,
        formData,
        imageUrl // Pass the actual image URL
      );
    } catch (updateError) {
      console.error("Error updating metadata (non-critical):", updateError);
    }

    const clusterParam =
      process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
        ? "?cluster=devnet"
        : "";

    return {
      mintAddress,
      metadataUrl: finalMetadataUrl,
      imageUrl,
      explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
    };
  } catch (error: unknown) {
    console.error("Transaction error:", error);
    // Make sure to clean up Pinata files in case of an error
    await handleErrorWithCleanup(error);

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to process transaction: ${errorMessage}`);
  }
}


// ===== src/services/token-creation/token-validation.ts =====

// src/services/token-creation/token-validation.ts
// Functions for validating token parameters

import { FormDataType } from "@/types/token";

/**
 * Validates all token creation parameters before submission
 * @returns Error message or null if valid
 */
export function validateTokenCreationParams(formData: FormDataType): string | null {
  // Validate basic token info
  if (!formData.logo) {
    return "Please upload a logo image";
  }
  
  if (!formData.name || formData.name.trim() === "") {
    return "Token name is required";
  }
  
  if (formData.name.length > 32) {
    return "Token name must be 32 characters or less";
  }
  
  if (!formData.symbol || formData.symbol.trim() === "") {
    return "Token symbol is required";
  }
  
  if (formData.symbol.length > 10) {
    return "Token symbol must be 10 characters or less";
  }
  
  if (!formData.description || formData.description.trim() === "") {
    return "Token description is required";
  }
  
  // Validate token parameters
  if (formData.decimals < 0 || formData.decimals > 9) {
    return "Decimals must be between 0 and 9";
  }
  
  if (formData.supply <= 0) {
    return "Supply must be greater than 0";
  }
  
  if (formData.supply > Number.MAX_SAFE_INTEGER) {
    return "Supply is too large";
  }
  
  // Validate social links if they're enabled
  if (formData.socialLinks) {
    // Optional URL validation
    if (formData.website && !isValidUrl(formData.website)) {
      return "Website URL is invalid";
    }
    
    if (formData.twitter && !isValidUrl(formData.twitter)) {
      return "Twitter URL is invalid";
    }
    
    if (formData.telegram && !isValidUrl(formData.telegram)) {
      return "Telegram URL is invalid";
    }
    
    if (formData.discord && !isValidUrl(formData.discord)) {
      return "Discord URL is invalid";
    }
  }
  
  return null;
}

/**
 * Validates an image file for token logo
 */
export function isValidTokenImage(file: File | null): boolean {
  if (!file) {
    return false;
  }
  
  // Check file type
  const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
  if (!validTypes.includes(file.type)) {
    return false;
  }
  
  // Check file size (max 5MB)
  const maxSize = 5 * 1024 * 1024; // 5MB
  if (file.size > maxSize) {
    return false;
  }
  
  return true;
}

/**
 * Simple URL validation
 */
function isValidUrl(urlString: string): boolean {
  try {
    const url = new URL(urlString);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch (e) {
    return false;
  }
}

// ===== src/services/fee-calculator.ts =====

// src/services/fee-calculator.ts
// Functions for calculating and formatting token creation fees

import { SOLANA_NETWORK_FEE } from "@/config";

/**
 * Options for fee calculation
 */
export interface FeeOptions {
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
}

/**
 * Fee calculation constants
 */
export const FEE_CONSTANTS = {
  BASE_FEE: 0.1,        // Base fee for token creation
  AUTHORITY_FEE: 0.1,   // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MINIMUM_FEE: 0.1      // Minimum fee for any token creation
};

/**
 * Calculates the total fee based on selected options
 * @returns Fee amount in SOL
 */
export function calculateFee(options: FeeOptions): number {
  let fee = FEE_CONSTANTS.BASE_FEE;

  // Add fee for each enabled feature
  if (options.revokeMint) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.revokeFreeze) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.revokeUpdate) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.socialLinks) fee += FEE_CONSTANTS.SOCIAL_LINKS_FEE;
  if (options.creatorInfo) fee += FEE_CONSTANTS.CREATOR_INFO_FEE;

  // Ensure minimum fee
  fee = Math.max(fee, FEE_CONSTANTS.MINIMUM_FEE);

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

/**
 * Calculates the net fee after deducting network costs
 * @returns Net fee amount in SOL that goes to the fee recipient
 */
export function calculateNetFee(totalFee: number): number {
  // Deduct the Solana network fee from the total
  const networkFee = SOLANA_NETWORK_FEE;
  return Math.max(totalFee - networkFee, 0);
}

/**
 * Format a fee amount for display
 * @returns Formatted fee string
 */
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

/**
 * Gets a breakdown of fees for display
 * @returns Object with fee breakdowns
 */
export function getFeeBreakdown(options: FeeOptions): {
  total: number;
  net: number;
  networkFee: number;
  components: { name: string; amount: number }[];
} {
  const total = calculateFee(options);
  const networkFee = SOLANA_NETWORK_FEE;
  const net = calculateNetFee(total);
  
  const components = [
    { name: "Base fee", amount: FEE_CONSTANTS.BASE_FEE }
  ];
  
  if (options.revokeMint) {
    components.push({ name: "Revoke mint authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.revokeFreeze) {
    components.push({ name: "Revoke freeze authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.revokeUpdate) {
    components.push({ name: "Revoke update authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.socialLinks) {
    components.push({ name: "Social links", amount: FEE_CONSTANTS.SOCIAL_LINKS_FEE });
  }
  
  if (options.creatorInfo) {
    components.push({ name: "Creator info", amount: FEE_CONSTANTS.CREATOR_INFO_FEE });
  }
  
  return {
    total,
    net,
    networkFee,
    components
  };
}

// ===== src/services/wallet-service.ts =====

// src/services/wallet-service.ts
import { WalletAdapter } from '@solana/wallet-adapter-base';
import { Connection, clusterApiUrl, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Get the Solana connection based on the configured network
export const getSolanaConnection = (): Connection => {
  const network = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
  return new Connection(clusterApiUrl(network), 'confirmed');
};

// Save the current wallet's public key to localStorage for reference
export const saveWalletPublicKey = (publicKey: string): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('walletPublicKey', publicKey);
    console.log(`Wallet public key saved: ${publicKey}`);
  }
};

// Get the saved wallet public key
export const getSavedWalletPublicKey = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('walletPublicKey');
  }
  return null;
};

// Check if wallet is properly connected
export const isWalletConnected = (wallet: any): boolean => {
  // Debug log to help diagnose issues
  console.log("Wallet connection check:", {
    walletExists: !!wallet,
    publicKeyExists: wallet ? !!wallet.publicKey : false,
    adapterExists: wallet ? !!wallet.adapter : false,
    adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false
  });
  
  // For some wallets, adapter.connected might not be reliable
  // Consider a wallet connected if it has a wallet object and a public key
  return !!wallet && !!wallet.publicKey;
};

// Get the wallet's SOL balance
export const getWalletBalance = async (publicKey: PublicKey): Promise<number> => {
  try {
    const connection = getSolanaConnection();
    const balance = await connection.getBalance(publicKey);
    console.log(`Wallet balance: ${balance / 1_000_000_000} SOL`);
    return balance / 1_000_000_000; // Convert lamports to SOL
  } catch (error) {
    console.error('Error getting wallet balance:', error);
    return 0;
  }
};

// Format the wallet address for display
export const formatWalletAddress = (address: string): string => {
  if (!address || address.length < 10) return address;
  return `${address.slice(0, 4)}...${address.slice(-4)}`;
};

// Get the Solana explorer URL for a transaction or address
export const getExplorerUrl = (addressOrSignature: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${addressOrSignature}${network}`;
};

