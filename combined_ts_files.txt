// ===== next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// ===== next.config.ts =====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


// ===== src/middleware.ts =====

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// This middleware ensures CORS headers are properly set for API routes
export function middleware(request: NextRequest) {
  // Only apply to /api routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    // Handle OPTIONS requests for CORS preflight
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        },
      });
    }

    // Add CORS headers to all responses
    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return response;
  }

  return NextResponse.next();
}

// Configure which routes the middleware applies to
export const config = {
  matcher: '/api/:path*',
};

// ===== src/app/guides/page.tsx =====

export default function Guides() {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          <h1 className="text-4xl font-bold text-center mb-10">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Guides & Resources
            </span>
          </h1>
          
          <div className="space-y-12">
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">How to Create a Solana Token</h2>
              <div className="prose prose-invert max-w-none">
                <ol className="list-decimal pl-5 space-y-4">
                  <li>
                    <strong>Connect Your Wallet</strong>
                    <p className="text-gray-400">
                      Click the "Connect Wallet" button in the top right corner and connect your Phantom, Solflare, or other compatible Solana wallet.
                    </p>
                  </li>
                  <li>
                    <strong>Fill in Token Details</strong>
                    <p className="text-gray-400">
                      Enter your token's name, symbol, supply, and other details. Upload a logo image (1000x1000px recommended).
                    </p>
                  </li>
                  <li>
                    <strong>Configure Token Options</strong>
                    <p className="text-gray-400">
                      Choose whether to include social links and creator information. Select which authorities to revoke (recommended for investor trust).
                    </p>
                  </li>
                  <li>
                    <strong>Launch Your Token</strong>
                    <p className="text-gray-400">
                      Click "Launch Token" and approve the transaction in your wallet. Your token will be created on the Solana blockchain.
                    </p>
                  </li>
                  <li>
                    <strong>Create Liquidity</strong>
                    <p className="text-gray-400">
                      After creating your token, consider setting up a liquidity pool on Raydium or another Solana DEX to make your token tradable.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">Token Authorities Explained</h2>
              <div className="prose prose-invert max-w-none">
                <p className="text-gray-400">
                  Solana tokens have three types of authorities that control different aspects of the token:
                </p>
                <ul className="list-disc pl-5 space-y-3 mt-4">
                  <li>
                    <strong>Mint Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to create (mint) new tokens. Revoking this authority creates a fixed supply token that cannot be inflated.
                    </p>
                  </li>
                  <li>
                    <strong>Freeze Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to freeze token accounts, preventing transfers. Revoking this ensures no one can freeze holders' tokens.
                    </p>
                  </li>
                  <li>
                    <strong>Update Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to modify token metadata (name, symbol, image, etc.). Revoking makes the token's metadata immutable.
                    </p>
                  </li>
                </ul>
                <p className="text-gray-400 mt-4">
                  For maximum credibility with your community, we recommend revoking all authorities.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

// ===== src/app/create-token/page.tsx =====

import TokenForm from '@/components/token/token-form';

export default function CreateToken() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <TokenForm />
    </div>
  );
}

// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Navbar from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SolMinter - Create Solana Tokens Easily",
  description: "Create, launch, and manage Solana tokens with ease. Your one-stop solution for Solana meme coin creation.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link 
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" 
          rel="stylesheet"
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0a0a0a] text-white`}
      >
        <Providers>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            <main className="flex-grow">{children}</main>
            <Footer />
          </div>
        </Providers>
      </body>
    </html>
  );
}

// ===== src/app/api/upload-metadata/route.ts =====

// src/app/api/upload-metadata/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the metadata from the request body
    const metadata = await request.json();
    
    console.log("Received metadata:", metadata);
    
    // Here you would typically upload to Pinata or another IPFS service
    // For now, we'll simulate a successful upload with a fake CID
    // In a real implementation, replace this with actual Pinata API call
    
    // Simulate IPFS upload with a random CID
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    
    // Simulate a slight delay like a real API call would have
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid
    });
  } catch (error) {
    console.error('Error uploading metadata:', error);
    return NextResponse.json(
      { error: 'Failed to upload metadata' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upload-image/route.ts =====

// src/app/api/upload-image/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    console.log("Received file:", file.name, "Size:", file.size);
    
    // Here you would typically upload to Pinata or another IPFS service
    // For now, we'll simulate a successful upload with a fake CID
    // In a real implementation, replace this with actual Pinata API call
    
    // Simulate IPFS upload with a random CID
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    
    // Simulate a slight delay like a real API call would have
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid 
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// ===== src/app/page.tsx =====

import Link from 'next/link';

export default function Home() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20">
        <div className="text-center">
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              SolMinter
            </span>
          </h1>
          <p className="text-xl md:text-2xl text-gray-400 mb-8 max-w-3xl mx-auto">
            Create, launch, and manage Solana tokens with ease. 
            Your one-stop solution for Solana meme coin creation.
          </p>
          
          <div className="flex flex-col sm:flex-row justify-center gap-4 mb-12">
            <Link href="/create-token" className="bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all">
              Create Token
            </Link>
            <Link href="/guides" className="bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all">
              Learn More
            </Link>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-purple-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Easy Token Creation</h2>
              <p className="text-gray-400">Create your Solana token with just a few clicks. No coding required.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-blue-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Secure & Trusted</h2>
              <p className="text-gray-400">Built on Solana for fast transactions and high security standards.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Lightning Fast</h2>
              <p className="text-gray-400">Launch your token in seconds with minimal fees on the Solana blockchain.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};  

// ===== src/app/providers.tsx =====

'use client';

import { ReactNode, useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Create a client-only wrapper component
const WalletConnectionProvider = ({ children }: { children: ReactNode }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return <>{children}</>;
};

// Dynamically import the wallet components with ssr: false
const ClientWalletProvider = dynamic(
  () => import('../components/wallet/wallet-provider-client').then(module => module.ClientWalletProvider),
  {
    ssr: false,
    loading: () => <WalletConnectionProvider><div>{/* Loading placeholder */}</div></WalletConnectionProvider>
  }
);

export function Providers({ children }: { children: ReactNode }) {
  return (
    <ClientWalletProvider>
      {children}
    </ClientWalletProvider>
  );
}

// ===== src/config/index.ts =====

// src/config/index.ts

// Solana network configuration
export const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

// Fee recipient wallet
export const FEE_RECIPIENT_WALLET = process.env.NEXT_PUBLIC_FEE_WALLET || '8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt';

// IPFS configuration
export const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';

// Token creation fees
export const TOKEN_FEES = {
  BASE_FEE: 0.2,
  AUTHORITY_FEE: 0.1,
  SOCIAL_LINKS_FEE: 0.1,
  CREATOR_INFO_FEE: 0.1,
  MAX_FEE: 0.3 // Capped discount
};

// Default token configuration
export const DEFAULT_TOKEN_CONFIG = {
  decimals: 9,
  supply: 1000000000, // 1 billion
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true
};

// Explorer URL generator
export const getExplorerUrl = (address: string): string => {
  const network = SOLANA_NETWORK;
  return `https://explorer.solana.com/address/${address}${network === 'devnet' ? '?cluster=devnet' : ''}`;
};

// ===== src/utils/error-utils.ts =====

// src/utils/error-utils.ts

/**
 * Formats Solana errors into user-friendly messages
 */
export function formatSolanaError(error: any): string {
    // If it's already a string, just return it
    if (typeof error === 'string') return error;
    
    // Extract error message from Error object
    const errorMessage = error.message || 'Unknown error occurred';
    
    // Handle specific Solana error messages
    if (errorMessage.includes('0x1')) {
      return 'Insufficient funds for transaction. Please make sure you have enough SOL to cover the fees.';
    }
    
    if (errorMessage.includes('Blockhash not found')) {
      return 'Network congestion detected. Please try again in a few moments.';
    }
    
    if (errorMessage.includes('Transaction simulation failed')) {
      return 'Transaction simulation failed. This could be due to network congestion or insufficient SOL.';
    }
    
    if (errorMessage.includes('User rejected')) {
      return 'Transaction was rejected by wallet. You must approve the transaction to continue.';
    }
    
      // Handle wallet connection errors
    if (errorMessage.includes('wallet disconnected') || errorMessage.includes('wallet not connected')) {
      return 'Wallet disconnected. Please reconnect your wallet and try again.';
    }
    
    if (errorMessage.includes('timeout')) {
      return 'Transaction timed out. The Solana network might be congested, please try again.';
    }
    
    // Handle metadata errors
    if (errorMessage.includes('metadata')) {
      return 'Error with token metadata. Please ensure your token information is valid.';
    }
    
    // Handle Pinata/IPFS errors
    if (errorMessage.includes('Pinata') || errorMessage.includes('IPFS')) {
      return 'Error uploading to IPFS. Please try again or check if your image file is valid.';
    }
  
    // Fall back to the original error message
    return errorMessage;
  }
  
  /**
   * Logs detailed error information
   */
  export function logError(error: any, context: string): void {
    console.error(`Error in ${context}:`, error);
    
    // Log additional information if available
    if (error.code) {
      console.error(`Error code: ${error.code}`);
    }
    
    if (error.stack) {
      console.error(`Stack trace: ${error.stack}`);
    }
    
    // For Solana-specific errors
    if (error.logs) {
      console.error('Solana logs:', error.logs);
    }
  }
  
  /**
   * Creates a user-friendly error message for validation errors
   */
  export function getValidationErrorMessage(field: string, message: string): string {
    return `${field}: ${message}`;
  }
  
  /**
   * Checks common token validation rules
   */
  export function validateTokenData(data: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
  }): string | null {
    if (!data.name || data.name.trim() === '') {
      return 'Token name is required';
    }
    
    if (data.name.length > 32) {
      return 'Token name must be 32 characters or less';
    }
    
    if (!data.symbol || data.symbol.trim() === '') {
      return 'Token symbol is required';
    }
    
    if (data.symbol.length > 10) {
      return 'Token symbol must be 10 characters or less';
    }
    
    if (data.decimals < 0 || data.decimals > 18) {
      return 'Decimals must be between 0 and 18';
    }
    
    if (data.supply <= 0) {
      return 'Supply must be greater than 0';
    }
    
    if (data.supply > Number.MAX_SAFE_INTEGER) {
      return 'Supply is too large';
    }
    
    return null;
  }

// ===== src/utils/token-utils.ts =====

// src/utils/token-utils.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length < 2 || symbol.length > 10) {
      return false;
    }
    
    // Most token symbols are uppercase alphanumeric
    const validSymbolRegex = /^[A-Z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Formats a wallet address for display 
   */
  export function formatWalletAddress(address: string): string {
    if (!address || address.length < 10) return address;
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  }
  
  /**
   * Generates a token explorer URL
   */
  export function getTokenExplorerUrl(tokenAddress: string, network: string = 'devnet'): string {
    return `https://explorer.solana.com/address/${tokenAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`;
  }

// ===== src/components/token/token-form-options.tsx =====

'use client';

import React from 'react';
import SocialLinksForm from './social-links-form';

interface TokenFormOptionsProps {
  formData: {
    socialLinks: boolean;
    creatorInfo: boolean;
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
}

export default function TokenFormOptions({
  formData,
  setFormData,
  handleInputChange
}: TokenFormOptionsProps) {
  return (
    <div className="form-section mb-8">
      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="creatorInfo" 
                type="checkbox" 
                name="creatorInfo"
                checked={formData.creatorInfo}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.creatorInfo ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => setFormData((prev: any) => ({...prev, creatorInfo: !prev.creatorInfo}))}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.creatorInfo ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Creator's Info (Optional)</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Change the information of the creator in the metadata. By default, it is SolMinter.
        </div>
      </div>

      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="socialLinks" 
                type="checkbox" 
                name="socialLinks"
                checked={formData.socialLinks}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.socialLinks ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => setFormData((prev: any) => ({...prev, socialLinks: !prev.socialLinks}))}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.socialLinks ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Add Social Links & Tags</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Add links to your token metadata.
        </div>
      </div>
      
      {formData.socialLinks && (
        <SocialLinksForm formData={formData} handleInputChange={handleInputChange} />
      )}
    </div>
  );
}

// ===== src/components/token/token-form.tsx =====

'use client';

import { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { createTokenWithMetadata } from '@/services/token-service';
import { useConnection } from '@solana/wallet-adapter-react';
import TokenCreationSuccess from './token-creation-success';
import SocialLinksForm from './social-links-form';
import TokenFormBasic from './token-form-basic';
import TokenFormOptions from './token-form-options';
import TokenFormAuthorities from './token-form-authorities';

export default function TokenForm() {
  const { publicKey, connected, wallet } = useWallet();
  const { connection } = useConnection();
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [tokenCreationResult, setTokenCreationResult] = useState<any>(null);
  
  const [formData, setFormData] = useState({
    name: '',
    symbol: '',
    decimals: 9,
    supply: 1000000000,
    description: '',
    logo: null as File | null,
    revokeMint: true,
    revokeFreeze: true,
    revokeUpdate: true,
    socialLinks: false,
    creatorInfo: false,
    website: '',
    twitter: '',
    telegram: '',
    discord: ''
  });

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    
    if (type === 'checkbox') {
      const checkbox = e.target as HTMLInputElement;
      setFormData({
        ...formData,
        [name]: checkbox.checked
      });
    } else if (type === 'number') {
      setFormData({
        ...formData,
        [name]: parseInt(value)
      });
    } else {
      setFormData({
        ...formData,
        [name]: value
      });
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFormData({
        ...formData,
        logo: e.target.files[0]
      });
    }
  };

  const calculateTotalFee = () => {
    // Base fee is 0.2 SOL
    let fee = 0.2;
    
    // Add 0.1 SOL for each selected option
    if (formData.revokeMint) fee += 0.1;
    if (formData.revokeFreeze) fee += 0.1;
    if (formData.revokeUpdate) fee += 0.1;
    if (formData.socialLinks) fee += 0.1;
    if (formData.creatorInfo) fee += 0.1;
    
    // Apply discount cap at 0.3 SOL (as shown in the UI)
    return Math.min(fee, 0.3);
  };

  const validateForm = () => {
    if (!formData.name) return "Token name is required";
    if (!formData.symbol) return "Token symbol is required";
    if (!formData.description) return "Description is required";
    if (!formData.logo) return "Logo image is required";
    if (formData.name.length > 32) return "Token name must be 32 characters or less";
    if (formData.decimals < 0 || formData.decimals > 18) return "Decimals must be between 0 and 18";
    if (formData.supply <= 0) return "Supply must be greater than 0";
    return null;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    
    // Validate form
    const validationError = validateForm();
    if (validationError) {
      setError(validationError);
      return;
    }
    
    // Validate wallet connection
    if (!connected || !wallet) {
      setError("Please connect your wallet first");
      return;
    }
    
    // Check balance
    try {
      const balance = await connection.getBalance(publicKey!);
      const requiredBalance = calculateTotalFee() * 1000000000; // Convert SOL to lamports
      
      if (balance < requiredBalance) {
        setError(`Insufficient SOL balance. You need at least ${calculateTotalFee()} SOL.`);
        return;
      }
      
      // Start token creation process
      setIsSubmitting(true);
      
      const result = await createTokenWithMetadata(wallet, formData);
      setTokenCreationResult(result);
      
    } catch (error) {
      console.error("Error creating token:", error);
      setError(error instanceof Error ? error.message : "An unknown error occurred");
    } finally {
      setIsSubmitting(false);
    }
  };

  // If token creation was successful, show success component
  if (tokenCreationResult) {
    return <TokenCreationSuccess result={tokenCreationResult} />;
  }

  return (
    <div id="create-token" className="opacity-100 py-8">
      <div className="title-box text-center mb-8">
        <div className="title-text text-3xl md:text-4xl font-bold text-white mb-3">
          Solana Token Creator
        </div>
        <div className="title-desc text-gray-400">
          <span className="span-1 block">Create and deploy your Solana coin effortlessly in seconds.</span>
          <span className="span-2 block">Reach the world and scale without limits!</span>
        </div>
      </div>

      {error && (
        <div className="error-alert max-w-3xl mx-auto mb-4 bg-red-500 bg-opacity-20 border border-red-500 rounded-lg p-3 text-red-500">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="token-creation-box max-w-3xl mx-auto bg-[#171717] rounded-xl p-6 shadow-xl">
        {/* Basic token information section */}
        <TokenFormBasic 
          formData={formData} 
          handleInputChange={handleInputChange} 
          handleFileChange={handleFileChange}
        />

        <div className="form-divider border-t border-gray-700 my-6"></div>

        {/* Optional features section */}
        <TokenFormOptions 
          formData={formData} 
          setFormData={setFormData} 
          handleInputChange={handleInputChange}
        />

        <div className="form-divider border-t border-gray-700 my-6"></div>

        {/* Authorities section */}
        <TokenFormAuthorities 
          formData={formData} 
          setFormData={setFormData}
        />

        {/* Submit section */}
        <div className="submit-section flex flex-col md:flex-row justify-between items-center mt-8">
          <button 
            type="submit" 
            className={`submit-btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all w-full md:w-auto mb-4 md:mb-0 ${!connected || isSubmitting ? 'opacity-50 cursor-not-allowed' : ''}`}
            disabled={!connected || isSubmitting}
          >
            {isSubmitting ? 'Creating Token...' : (connected ? 'Launch Token' : 'Connect Wallet to Launch')}
          </button>
          
          <div className="token-fees-container text-right">
            <div className="fees-label text-gray-400 text-sm">Total Fees:</div>
            <div className="flex items-center">
              <div className="fees-original text-gray-500 text-sm">0.2+<del>0.6 SOL</del></div>
              <div className="fees-discounted text-purple-500 text-xl font-semibold ml-2">{calculateTotalFee()} SOL</div>
            </div>
          </div>
        </div>
      </form>
    </div>
  );
}

// ===== src/components/token/token-creation-success.tsx =====

'use client';

import Link from 'next/link';
import React from 'react';

interface TokenCreationSuccessProps {
  result: {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  };
}

export default function TokenCreationSuccess({ result }: TokenCreationSuccessProps) {
  return (
    <div className="max-w-3xl mx-auto py-12 px-4">
      <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-green-500 border-opacity-30">
        <div className="text-center mb-6">
          <div className="w-20 h-20 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-10 h-10 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </div>
          
          <h1 className="text-3xl font-bold text-white mb-2">Token Created Successfully!</h1>
          <p className="text-gray-400 text-lg">Your Solana token has been created and is ready to use.</p>
        </div>
        
        <div className="token-info bg-[#222] rounded-lg p-5 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="token-image flex items-center justify-center">
              <img 
                src={result.imageUrl} 
                alt="Token Logo" 
                className="w-32 h-32 rounded-full border-4 border-gray-700"
              />
            </div>
            
            <div className="token-details">
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Token Address</div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.mintAddress}
                </div>
              </div>
              
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Metadata URL</div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.metadataUrl}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div className="next-steps space-y-4 mb-8">
          <h2 className="text-xl font-semibold text-white">Next Steps</h2>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">Create Liquidity</h3>
            <p className="text-gray-400 mb-2">Create a liquidity pool on a DEX like Raydium to make your token tradable.</p>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to Raydium
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">View on Explorer</h3>
            <p className="text-gray-400 mb-2">Check your token on the Solana blockchain explorer.</p>
            <a 
              href={result.explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              View on Explorer
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
        </div>
        
        <div className="buttons flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4">
          <Link 
            href="/"
            className="btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all text-center"
          >
            Back to Home
          </Link>
          
          <Link 
            href="/create-token"
            className="btn bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Create Another Token
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-authorities.tsx =====

'use client';

import React from 'react';

interface TokenFormAuthoritiesProps {
  formData: {
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
}

export default function TokenFormAuthorities({
  formData,
  setFormData
}: TokenFormAuthoritiesProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Revoke Authorities (Investor's Booster)</div>
      
      <div className="form-section-authorities space-y-4">
        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Freeze</div>
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeFreeze ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => setFormData((prev: any) => ({...prev, revokeFreeze: !prev.revokeFreeze}))}
              >
                {formData.revokeFreeze && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to freeze holders' token accounts anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Mint</div>
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeMint ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => setFormData((prev: any) => ({...prev, revokeMint: !prev.revokeMint}))}
              >
                {formData.revokeMint && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to create more tokens anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Update</div>
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeUpdate ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => setFormData((prev: any) => ({...prev, revokeUpdate: !prev.revokeUpdate}))}
              >
                {formData.revokeUpdate && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to modify token metadata anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>
      </div>
      
      <div className="form-section-description text-xs text-gray-500 mt-4">
        Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.
      </div>
    </div>
  );
}

// ===== src/components/token/social-links-form.tsx =====

'use client';

import React from 'react';

interface SocialLinksProps {
  formData: {
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SocialLinksForm({ formData, handleInputChange }: SocialLinksProps) {
  return (
    <div className="social-links-form bg-[#1e1e1e] rounded-lg p-4 mt-4">
      <h3 className="text-white text-lg mb-4">Social Links</h3>
      
      <div className="space-y-4">
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Website URL</label>
          <input 
            placeholder="https://your-website.com" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="website"
            value={formData.website}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Twitter</label>
          <input 
            placeholder="https://x.com/yourtokenname" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="twitter"
            value={formData.twitter}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Telegram</label>
          <input 
            placeholder="https://t.me/yourtokenname" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="telegram"
            value={formData.telegram}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Discord</label>
          <input 
            placeholder="https://discord.gg/yourinvite" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="discord"
            value={formData.discord}
            onChange={handleInputChange}
          />
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-basic.tsx =====

'use client';

import React from 'react';

interface TokenFormBasicProps {
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormBasic({
  formData,
  handleInputChange,
  handleFileChange
}: TokenFormBasicProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Name *</label>
        <input 
          placeholder="Ex: Moon Coin" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Max 32 characters in your name</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Symbol *</label>
        <input 
          placeholder="Ex: MOON" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="symbol"
          value={formData.symbol}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Decimals *</label>
        <input 
          placeholder="Ex: 9" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="decimals"
          value={formData.decimals}
          onChange={handleInputChange}
          min="0"
          max="18"
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Change the number of decimals for your token</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Supply *</label>
        <input 
          placeholder="Ex: 1000000000" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="supply"
          value={formData.supply}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">The initial number of available tokens that will be created in your wallet</span>
      </div>

      <div className="logo-wrapper grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
        <div className="logo-box">
          <span className="label-text block text-gray-300 mb-2">Logo *</span>
          <div className="img-input-wrapper border-2 border-dashed border-gray-700 rounded-lg p-6 text-center cursor-pointer hover:border-purple-500 transition-colors" onClick={() => document.querySelector<HTMLInputElement>('.form-img')?.click()}>
            <span className="material-symbols-rounded text-3xl mb-2 text-gray-400 block">upload</span>
            <span className="text-1 block text-gray-300 mb-1">Drag and drop here to upload</span>
            <div className="text-2 text-xs text-gray-500">.png, .jpg 1000x1000 px</div>
            <input 
              accept=".png, .jpg, .jpeg" 
              className="form-img hidden" 
              type="file"
              onChange={handleFileChange}
              required
            />
          </div>
          <span className="field-constraint text-xs text-gray-500 mt-1 block">Add logo for your token</span>
        </div>
        
        <div className="logo-preview flex items-center justify-center">
          {formData.logo ? (
            <img 
              src={URL.createObjectURL(formData.logo)} 
              alt="Token Logo Preview" 
              className="max-h-40 rounded-lg border border-gray-700"
            />
          ) : (
            <div className="text-gray-500 text-sm">Logo preview will appear here</div>
          )}
        </div>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Description *</label>
        <textarea 
          placeholder="Here you can describe your token" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white h-24" 
          name="description"
          value={formData.description}
          onChange={handleInputChange}
          required
        />
      </div>
    </div>
  );
}

// ===== src/components/ui/loading.tsx =====

'use client';

import { useState, useEffect } from 'react';

interface LoadingProps {
  message?: string;
  steps?: string[];
}

export default function Loading({ message = 'Loading...', steps }: LoadingProps) {
  const [currentStep, setCurrentStep] = useState(0);
  
  useEffect(() => {
    if (!steps || steps.length === 0) return;
    
    const interval = setInterval(() => {
      setCurrentStep((prev) => {
        if (prev >= steps.length - 1) {
          return prev;
        }
        return prev + 1;
      });
    }, 3000);
    
    return () => clearInterval(interval);
  }, [steps]);
  
  if (!steps || steps.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center p-8">
        <div className="relative w-16 h-16 mb-4">
          <div className="absolute top-0 left-0 w-full h-full rounded-full border-4 border-purple-500 border-opacity-30"></div>
          <div className="absolute top-0 left-0 w-full h-full rounded-full border-4 border-transparent border-t-purple-500 animate-spin"></div>
        </div>
        <div className="text-white text-lg">{message}</div>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col items-center justify-center p-8">
      <div className="relative w-16 h-16 mb-6">
        <div className="absolute top-0 left-0 w-full h-full rounded-full border-4 border-purple-500 border-opacity-30"></div>
        <div className="absolute top-0 left-0 w-full h-full rounded-full border-4 border-transparent border-t-purple-500 animate-spin"></div>
      </div>
      
      <div className="text-white text-lg mb-6">{message}</div>
      
      <div className="w-full max-w-md bg-[#222] rounded-lg p-4">
        <ul className="space-y-3">
          {steps.map((step, index) => (
            <li 
              key={index} 
              className={`flex items-center ${index <= currentStep ? 'text-white' : 'text-gray-500'}`}
            >
              {index < currentStep ? (
                <span className="w-6 h-6 mr-3 flex items-center justify-center bg-green-500 rounded-full text-white">
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path>
                  </svg>
                </span>
              ) : index === currentStep ? (
                <span className="w-6 h-6 mr-3 flex-shrink-0 flex items-center justify-center border-2 border-purple-500 rounded-full">
                  <span className="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></span>
                </span>
              ) : (
                <span className="w-6 h-6 mr-3 flex-shrink-0 flex items-center justify-center border-2 border-gray-600 rounded-full"></span>
              )}
              
              <span>{step}</span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}

// ===== src/components/layout/navbar.tsx =====

'use client';

import Link from 'next/link';
import WalletButton from '../wallet/wallet-button';

export default function Navbar() {
  return (
    <div className="nav-container bg-[#111] border-b border-gray-800 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <Link href="/" className="logo-container flex items-center">
            <div className="logo-img">
              <span className="text-2xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <nav className="main-nav hidden md:flex space-x-6">
            <Link href="/" className="nav-link text-gray-300 hover:text-white transition-colors">
              Home
            </Link>
            <Link href="/create-token" className="nav-link text-gray-300 hover:text-white transition-colors">
              Create Token
            </Link>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Liquidity Pool
            </a>
            <a 
              href="https://raydium.io/swap" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Manage Liquidity
            </a>
            <Link href="/guides" className="nav-link text-gray-300 hover:text-white transition-colors">
              Guides
            </Link>
          </nav>
          
          <div className="wallet-dropdown">
            <WalletButton />
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/layout/footer.tsx =====

'use client';

import Link from 'next/link';

export default function Footer() {
  return (
    <div className="footer-container bg-[#111] border-t border-gray-800 py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <Link href="/" className="logo-container mb-4 md:mb-0">
            <div className="logo-img">
              <span className="text-xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <div className="bottom-bar flex flex-col md:flex-row items-center">
            <div className="copyright-bar text-gray-500 text-sm mb-2 md:mb-0">
              <span>© SolMinter 2025</span>
            </div>
            
            <div className="policies-bar flex ml-0 md:ml-6">
              <Link href="/terms" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Terms of Service
              </Link>
              <span className="separator mx-2 text-gray-600">|</span>
              <Link href="/privacy" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Privacy Policy
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-button.tsx =====

'use client';

import { FC, useEffect, useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import dynamic from 'next/dynamic';
import '@/styles/wallet-button.css';

// Dynamically import the WalletMultiButton with ssr disabled
// This prevents hydration errors by only rendering on the client
const WalletMultiButton = dynamic(
  async () => (await import('@solana/wallet-adapter-react-ui')).WalletMultiButton,
  { ssr: false }
);

const WalletButton: FC = () => {
  const { publicKey, connected, connecting, disconnecting } = useWallet();
  const [mounted, setMounted] = useState(false);
  
  // Format public key for display
  const getFormattedAddress = () => {
    if (!publicKey) return '';
    const address = publicKey.toString();
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  };

  // Only show the component after mounting to prevent hydration errors
  useEffect(() => {
    setMounted(true);
  }, []);

  // Add some logging for debugging connection issues
  useEffect(() => {
    if (connecting) {
      console.log('Wallet connecting...');
    } else if (disconnecting) {
      console.log('Wallet disconnecting...');
    } else if (connected) {
      console.log('Wallet connected:', getFormattedAddress());
    }
  }, [connecting, disconnecting, connected, publicKey]);
  
  if (!mounted) {
    // Return a placeholder with the same dimensions to prevent layout shift
    return <div className="wallet-button-placeholder h-10 w-32"></div>;
  }
  
  return (
    <div className="wallet-button">
      <WalletMultiButton className="wallet-display hover:bg-opacity-90 transition-all" />
    </div>
  );
};

export default WalletButton;

// ===== src/components/wallet/wallet-provider.tsx =====

'use client';

import { FC, ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Default styles that can be overridden by your app
import '@solana/wallet-adapter-react-ui/styles.css';

interface WalletContextProviderProps {
  children: ReactNode;
}

export const WalletContextProvider: FC<WalletContextProviderProps> = ({ children }) => {
  // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.
  const network = WalletAdapterNetwork.Devnet;

  // You can also provide a custom RPC endpoint.
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Only include Phantom wallet adapter to minimize dependency issues
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

// ===== src/components/wallet/wallet-provider-client.tsx =====

'use client';

import { ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface ClientWalletProviderProps {
  children: ReactNode;
}

export function ClientWalletProvider({ children }: ClientWalletProviderProps) {
  // Get the network from environment variables
  const networkEnv = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';
  const network = networkEnv === 'mainnet-beta' 
    ? WalletAdapterNetwork.Mainnet
    : WalletAdapterNetwork.Devnet;

  // Set up the RPC endpoint
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Add only the wallet adapters you have individually installed
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter()
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

// ===== src/services/token-service.ts =====

// src/services/token-service.ts
import {
  Connection,
  Keypair,
  PublicKey,
  Transaction,
  SystemProgram,
  clusterApiUrl,
  SendOptions,
} from "@solana/web3.js";

import {
  createMint,
  getOrCreateAssociatedTokenAccount,
  mintTo,
  setAuthority,
  AuthorityType,
} from "@solana/spl-token";

// Metaplex Token Metadata Program ID
const TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

// Recipient wallet for fee collection
const FEE_RECIPIENT = new PublicKey(process.env.NEXT_PUBLIC_FEE_WALLET || "8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt");

// Find the metadata PDA for a mint
function findMetadataPda(mint: PublicKey): PublicKey {
  const [pda] = PublicKey.findProgramAddressSync(
    [
      Buffer.from("metadata"),
      TOKEN_METADATA_PROGRAM_ID.toBuffer(),
      mint.toBuffer(),
    ],
    TOKEN_METADATA_PROGRAM_ID
  );
  return pda;
}

// Helper function to serialize a string for the Metaplex metadata instruction
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value);
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

// Helper function to serialize metadata for the Metaplex createMetadataAccountV3 instruction
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: string; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  // Name
  const nameBuffer = serializeString(data.name);
  
  // Symbol
  const symbolBuffer = serializeString(data.symbol);
  
  // URI
  const uriBuffer = serializeString(data.uri);
  
  // Seller fee basis points (u16)
  const sellerFeeBasisPointsBuffer = Buffer.alloc(2);
  sellerFeeBasisPointsBuffer.writeUInt16LE(data.sellerFeeBasisPoints, 0);
  
  // Creators (Option<Vec<Creator>>)
  let creatorsBuffer;
  if (data.creators === null) {
    creatorsBuffer = Buffer.from([0]); // None
  } else {
    const creatorsVec = Buffer.concat(
      data.creators.map((creator) => {
        const address = new PublicKey(creator.address).toBuffer();
        const verified = Buffer.from([creator.verified ? 1 : 0]);
        const share = Buffer.from([creator.share]);
        return Buffer.concat([address, verified, share]);
      })
    );
    
    const creatorsLength = Buffer.alloc(4);
    creatorsLength.writeUInt32LE(data.creators.length, 0);
    
    creatorsBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      creatorsLength,
      creatorsVec,
    ]);
  }
  
  // Collection (Option<Collection>)
  let collectionBuffer;
  if (data.collection === null) {
    collectionBuffer = Buffer.from([0]); // None
  } else {
    collectionBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      new PublicKey(data.collection.key).toBuffer(),
      Buffer.from([data.collection.verified ? 1 : 0]),
    ]);
  }
  
  // Uses (Option<Uses>)
  let usesBuffer;
  if (data.uses === null) {
    usesBuffer = Buffer.from([0]); // None
  } else {
    // Implement if needed - for now we don't use this
    usesBuffer = Buffer.from([0]); // None
  }
  
  // Collection Details (Option<CollectionDetails>)
  // We don't use this, so set to None
  const collectionDetailsBuffer = Buffer.from([0]);
  
  // isMutable
  const isMutableBuffer = Buffer.from([data.isMutable ? 1 : 0]);
  
  // Combine all into the expected format
  return Buffer.concat([
    nameBuffer,
    symbolBuffer,
    uriBuffer,
    sellerFeeBasisPointsBuffer,
    creatorsBuffer,
    collectionBuffer,
    usesBuffer,
    collectionDetailsBuffer,
    isMutableBuffer,
  ]);
}

// Create metadata for the token
async function createMetadata(
  connection: Connection,
  wallet: any,
  mint: PublicKey,
  metadataUrl: string,
  name: string,
  symbol: string,
  isMutable: boolean
): Promise<string> {
  try {
    // Find the metadata account address (PDA)
    const metadataPDA = findMetadataPda(mint);
    console.log(`Metadata PDA: ${metadataPDA.toString()}`);
    
    // Create metadata account instruction
    const createMetadataIx = {
      programId: TOKEN_METADATA_PROGRAM_ID,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: wallet.publicKey, isSigner: true, isWritable: false },
        { pubkey: wallet.publicKey, isSigner: true, isWritable: false },
        { pubkey: wallet.publicKey, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data: Buffer.from([
        33, // createMetadataAccountV3 instruction
        ...serializeMetadataV3({
          name,
          symbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators: null,
          collection: null,
          uses: null,
          isMutable: isMutable,
        }),
      ]),
    };
    
    // Create transaction
    const transaction = new Transaction().add(createMetadataIx);
    
    // Set recent blockhash and fee payer
    transaction.feePayer = wallet.publicKey;
    const { blockhash } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    
    // Sign transaction using adapter's signTransaction
    const signedTransaction = await wallet.adapter.signTransaction(transaction);
    
    // Send transaction
    const signature = await connection.sendRawTransaction(signedTransaction.serialize());
    await connection.confirmTransaction(signature);
    
    console.log(`Metadata transaction signature: ${signature}`);
    return metadataPDA.toString();
  } catch (error) {
    console.error("Error creating metadata:", error);
    throw error;
  }
}

// Calculate fee in SOL based on selected options
export function calculateFee(options: {
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
}): number {
  let fee = 0.2; // Base fee
  
  if (options.revokeMint) fee += 0.1;
  if (options.revokeFreeze) fee += 0.1;
  if (options.revokeUpdate) fee += 0.1;
  if (options.socialLinks) fee += 0.1;
  if (options.creatorInfo) fee += 0.1;
  
  return Math.min(fee, 0.3); // Capped at 0.3 SOL as per the UI
}

// Upload image to Pinata
export async function uploadImageToPinata(imageFile: File) {
  try {
    const formData = new FormData();
    formData.append('file', imageFile);
    
    const response = await fetch('/api/upload-image', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error(`Error uploading image: ${response.statusText}`);
    }
    
    const data = await response.json();
    return `https://${process.env.NEXT_PUBLIC_PINATA_GATEWAY}/ipfs/${data.cid}`;
  } catch (error) {
    console.error("Error uploading image:", error);
    throw error;
  }
}

// Create and upload metadata
export async function createAndUploadMetadata(tokenData: {
  name: string;
  symbol: string;
  description: string;
  imageUrl: string;
  decimals: number;
  supply: number;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
}) {
  try {
    const metadata = {
      name: tokenData.name,
      symbol: tokenData.symbol,
      description: tokenData.description,
      image: tokenData.imageUrl,
      showName: true,
      website: tokenData.website || "",
      twitter: tokenData.twitter || "",
      telegram: tokenData.telegram || "",
      discord: tokenData.discord || "",
      tokenInfo: {
        chain: "Solana",
        totalSupply: tokenData.supply,
        circulatingSupply: tokenData.supply,
        decimals: tokenData.decimals
      },
      createdOn: "SolMinter"
    };
    
    // Upload metadata to Pinata
    const response = await fetch('/api/upload-metadata', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(metadata),
    });
    
    if (!response.ok) {
      throw new Error(`Error uploading metadata: ${response.statusText}`);
    }
    
    const data = await response.json();
    return `https://${process.env.NEXT_PUBLIC_PINATA_GATEWAY}/ipfs/${data.cid}`;
  } catch (error) {
    console.error("Error creating and uploading metadata:", error);
    throw error;
  }
}

// Transfer fee to recipient
async function transferFee(
  connection: Connection,
  wallet: any,
  feeInSol: number
) {
  try {
    // Log info for debugging
    console.log("Transferring fee...");
    console.log("Wallet public key:", wallet.publicKey?.toString());
    console.log("Fee recipient:", FEE_RECIPIENT.toString());
    console.log("Fee in SOL:", feeInSol);
    
    // Create a transaction to transfer SOL
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: wallet.publicKey,
        toPubkey: FEE_RECIPIENT,
        lamports: feeInSol * 1000000000, // Convert SOL to lamports
      })
    );
    
    // Set recent blockhash and fee payer
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = wallet.publicKey;
    
    try {
      // Request signing from the wallet
      console.log("Requesting wallet to sign transaction...");
      const signed = await wallet.signTransaction(transaction);
      
      // Send the transaction
      console.log("Sending signed transaction...");
      const signature = await connection.sendRawTransaction(signed.serialize());
      
      // Wait for confirmation
      console.log("Waiting for transaction confirmation...");
      await connection.confirmTransaction({
        blockhash,
        lastValidBlockHeight,
        signature
      });
      
      console.log(`Fee transfer successful: ${signature}`);
      return signature;
    } catch (signError) {
      console.error("Error during signing:", signError);
      // Try alternative approach with sendTransaction if signTransaction fails
      if (wallet.sendTransaction) {
        console.log("Trying alternative approach with sendTransaction...");
        const signature = await wallet.sendTransaction(transaction, connection);
        
        // Wait for confirmation
        await connection.confirmTransaction({
          blockhash,
          lastValidBlockHeight,
          signature
        });
        
        console.log(`Fee transfer successful (alternative method): ${signature}`);
        return signature;
      } else {
        throw signError;
      }
    }
  } catch (error) {
    console.error("Error transferring fee:", error);
    throw error;
  }
}

// Helper function for sending transactions with the wallet adapter
async function sendTransaction(
  connection: Connection,
  wallet: any,
  transaction: Transaction,
  signers: Keypair[] = []
) {
  // Add recent blockhash
  const { blockhash } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = wallet.publicKey;
  
  // If there are additional signers, sign with them first
  if (signers.length > 0) {
    transaction.partialSign(...signers);
  }
  
  // Sign with the wallet adapter
  const signedTransaction = await wallet.adapter.signTransaction(transaction);
  
  // Send and confirm transaction
  const rawTransaction = signedTransaction.serialize();
  const signature = await connection.sendRawTransaction(rawTransaction, {
    skipPreflight: false,
    preflightCommitment: 'confirmed',
  } as SendOptions);
  
  await connection.confirmTransaction(signature);
  return signature;
}

// Main function to create token - refactored to use the wallet adapter properly
export async function createToken(
  wallet: any,
  tokenData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    metadataUrl: string;
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  }
): Promise<string> {
  try {
    // Set up connection
    const network = process.env.NEXT_PUBLIC_SOLANA_NETWORK || "devnet";
    console.log(`Connecting to Solana ${network}...`);
    const connection = new Connection(
      clusterApiUrl(network as "devnet" | "mainnet-beta"), 
      "confirmed"
    );
    
    // Check wallet connection
    if (!wallet.publicKey) {
      throw new Error("Wallet not connected");
    }
    
    // Generate a keypair for the mint
    const mintKeypair = Keypair.generate();
    console.log(`Creating token mint for ${tokenData.name}...`);
    
    // Create the token mint - we need to adjust how we use the wallet adapter
    const lamportsForMint = await connection.getMinimumBalanceForRentExemption(82);
    
    // Use a separate function to handle all the transaction logic
    const createMintTransaction = new Transaction().add(
      // Create account for the mint
      SystemProgram.createAccount({
        fromPubkey: wallet.publicKey,
        newAccountPubkey: mintKeypair.publicKey,
        space: 82,
        lamports: lamportsForMint,
        programId: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") // Token Program ID
      })
    );
    
    // Send the transaction to create mint account
    await sendTransaction(connection, wallet, createMintTransaction, [mintKeypair]);
    
    // Initialize the mint
    const initMintTransaction = await createMint(
      connection, 
      {
        publicKey: wallet.publicKey,
        signTransaction: async (tx: Transaction) => wallet.adapter.signTransaction(tx),
      } as any,
      wallet.publicKey,
      wallet.publicKey,
      tokenData.decimals,
      mintKeypair
    );
    
    // Create a token account for the wallet
    console.log("Creating token account...");
    const tokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      {
        publicKey: wallet.publicKey,
        signTransaction: async (tx: Transaction) => wallet.adapter.signTransaction(tx),
      } as any,
      mintKeypair.publicKey,
      wallet.publicKey
    );
    
    // Mint initial supply
    console.log(`Minting ${tokenData.supply} tokens to your wallet...`);
    const initialSupply = tokenData.supply * Math.pow(10, tokenData.decimals);
    
    const mintToTransaction = await mintTo(
      connection,
      {
        publicKey: wallet.publicKey,
        signTransaction: async (tx: Transaction) => wallet.adapter.signTransaction(tx),
      } as any,
      mintKeypair.publicKey,
      tokenAccount.address,
      wallet.publicKey,
      initialSupply
    );
    
    // Add metadata
    console.log("Adding token metadata...");
    const metadataPDA = await createMetadata(
      connection,
      wallet,
      mintKeypair.publicKey,
      tokenData.metadataUrl,
      tokenData.name,
      tokenData.symbol,
      !tokenData.revokeUpdate
    );
    
    // Revoke authorities if configured to do so
    if (tokenData.revokeMint) {
      console.log("Revoking mint authority (supply will be fixed)...");
      await setAuthority(
        connection,
        {
          publicKey: wallet.publicKey,
          signTransaction: async (tx: Transaction) => wallet.adapter.signTransaction(tx),
        } as any,
        mintKeypair.publicKey,
        wallet.publicKey,
        AuthorityType.MintTokens,
        null
      );
    }
    
    if (tokenData.revokeFreeze) {
      console.log("Revoking freeze authority...");
      await setAuthority(
        connection,
        {
          publicKey: wallet.publicKey,
          signTransaction: async (tx: Transaction) => wallet.adapter.signTransaction(tx),
        } as any,
        mintKeypair.publicKey,
        wallet.publicKey,
        AuthorityType.FreezeAccount,
        null
      );
    }
    
    // Return the mint address
    return mintKeypair.publicKey.toString();
  } catch (error) {
    console.error("Error creating token:", error);
    throw error;
  }
}

// Main function that handles the entire token creation process
export async function createTokenWithMetadata(
  wallet: any,
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
    socialLinks: boolean;
    creatorInfo: boolean;
    website?: string;
    twitter?: string;
    telegram?: string;
    discord?: string;
  }
) {
  try {
    // Validate wallet connection
    if (!wallet || !wallet.publicKey) {
      throw new Error("Wallet not connected. Please connect your wallet and try again.");
    }
    
    console.log("Starting token creation process...");
    console.log("Connected wallet:", wallet.publicKey.toString());
    
    // Calculate fee - implement the calculation directly to ensure it matches UI
    let feeInSol = 0.2; // Base fee
    if (formData.revokeMint) feeInSol += 0.1;
    if (formData.revokeFreeze) feeInSol += 0.1;
    if (formData.revokeUpdate) feeInSol += 0.1;
    if (formData.socialLinks) feeInSol += 0.1;
    if (formData.creatorInfo) feeInSol += 0.1;
    feeInSol = Math.min(feeInSol, 0.3); // Apply discount cap
    
    // Set up connection
    const network = process.env.NEXT_PUBLIC_SOLANA_NETWORK || "devnet";
    const connection = new Connection(
      clusterApiUrl(network as "devnet" | "mainnet-beta"), 
      "confirmed"
    );
    
    // Check wallet balance before proceeding
    const balance = await connection.getBalance(wallet.publicKey);
    const balanceInSol = balance / 1000000000; // Convert lamports to SOL
    console.log(`Wallet balance: ${balanceInSol} SOL`);
    
    if (balanceInSol < feeInSol) {
      throw new Error(`Insufficient balance. You have ${balanceInSol.toFixed(4)} SOL but need at least ${feeInSol} SOL.`);
    }
    
    // 1. First upload image (before any transactions to avoid wasting gas if upload fails)
    if (!formData.logo) {
      throw new Error("Logo image is required");
    }
    
    console.log("Uploading image...");
    const imageUrl = await uploadImageToPinata(formData.logo);
    console.log("Image uploaded:", imageUrl);
    
    // 2. Create and upload metadata
    console.log("Creating and uploading metadata...");
    const metadataUrl = await createAndUploadMetadata({
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      imageUrl,
      decimals: formData.decimals,
      supply: formData.supply,
      website: formData.website,
      twitter: formData.twitter,
      telegram: formData.telegram,
      discord: formData.discord
    });
    console.log("Metadata uploaded:", metadataUrl);
    
    // 3. Transfer fee
    console.log(`Transferring fee of ${feeInSol} SOL...`);
    await transferFee(connection, wallet, feeInSol);
    console.log("Fee transferred successfully");
    
    // 4. Create token with metadata
    console.log("Creating token...");
    const mintAddress = await createToken(wallet, {
      name: formData.name,
      symbol: formData.symbol,
      decimals: formData.decimals,
      supply: formData.supply,
      description: formData.description,
      metadataUrl,
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate
    });
    console.log("Token created successfully with address:", mintAddress);
    
    return {
      success: true,
      mintAddress,
      metadataUrl,
      imageUrl,
      explorerUrl: `https://explorer.solana.com/address/${mintAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`
    };
  } catch (error) {
    console.error("Error in token creation process:", error);
    throw error;
  }
}

