// ===== next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// ===== next.config.ts =====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


// ===== src/middleware.ts =====

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// This middleware ensures CORS headers are properly set for API routes
export function middleware(request: NextRequest) {
  // Only apply to /api routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    // Handle OPTIONS requests for CORS preflight
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        },
      });
    }

    // Add CORS headers to all responses
    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return response;
  }

  return NextResponse.next();
}

// Configure which routes the middleware applies to
export const config = {
  matcher: '/api/:path*',
};

// ===== src/types/env.d.ts =====

// src/types/env.d.ts

declare namespace NodeJS {
  interface ProcessEnv {
    // Solana Network settings
    NEXT_PUBLIC_SOLANA_NETWORK: "devnet" | "mainnet-beta";

    // Fee recipient wallet address
    NEXT_PUBLIC_FEE_WALLET: string;

    // Pinata IPFS settings
    NEXT_PUBLIC_PINATA_GATEWAY: string;
    PINATA_JWT: string;

    // Solana network fee
    NEXT_PUBLIC_SOLANA_NETWORK_FEE: string;

    REVOKE_UPDATE_PRIVATE_KEY: string;
  }
}


// ===== src/types/token.ts =====

// Update or create this in a shared location like src/types/token.ts

export interface FormDataType {
  name: string;
  symbol: string;
  decimals: number;
  supply: number;
  description: string;
  logo: File | null;
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
  creatorName: string; // Added for Creator's Info
  website: string;
  twitter: string;
  telegram: string;
  discord: string;
}

export interface TokenResult {
  mintAddress: string;
  metadataUrl: string;
  imageUrl: string;
  explorerUrl: string;
}

// New interface for minted token information retrieved from Pinata/IPFS
export interface MintedTokenInfo {
  name: string;
  symbol: string;
  description?: string;
  image?: string;
  imageUrl?: string; // Alternative property name for image
  mintAddress: string;
  mint?: string;     // Alternative property name for mintAddress
  creator?: string;
  metadataUrl?: string;
  pinHash?: string;
  
  // Social links
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  
  // Token information
  tokenInfo?: {
    chain?: string;
    totalSupply: number;
    circulatingSupply?: number;
    decimals: number;
  };
  
  // Authority status
  authorities?: {
    mintRevoked: boolean;
    freezeRevoked: boolean;
    updateRevoked: boolean;
  };
  
  // Session tracking
  sessionUuid?: string;
  createdOn?: string;
}

// ===== src/app/privacy/page.tsx =====

// src/app/privacy/page.tsx

import Link from 'next/link';

export default function PrivacyPolicy() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <h1 className="text-4xl font-bold text-center mb-8">
          <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
            Privacy Policy
          </span>
        </h1>
        
        <div className="bg-[#171717] rounded-xl p-8 shadow-lg mb-8">
          <p className="text-gray-400 mb-6">
            Last Updated: April 23, 2025
          </p>
          
          <div className="space-y-6 text-gray-300">
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">1. Introduction</h2>
              <p>
                SolMinter ("we," "our," or "us") respects your privacy and is committed to protecting your personal data. This privacy policy explains how we collect, use, and protect information when you use our website and services.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">2. Information We Collect</h2>
              <p>
                When you use SolMinter, we may collect the following information:
              </p>
              <ul className="list-disc pl-5 mt-2 space-y-1">
                <li>Wallet address and public blockchain data</li>
                <li>Token creation details, including names, symbols, and metadata</li>
                <li>Images and content uploaded for token creation</li>
                <li>Transaction data related to token creation and management</li>
                <li>Technical information such as browser type, IP address, and device information</li>
                <li>Usage data to understand how you interact with our service</li>
              </ul>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">3. How We Use Your Information</h2>
              <p>
                We use the information we collect for the following purposes:
              </p>
              <ul className="list-disc pl-5 mt-2 space-y-1">
                <li>To provide and maintain our services</li>
                <li>To process token creation transactions</li>
                <li>To store and display your created tokens and associated metadata</li>
                <li>To improve and optimize our platform</li>
                <li>To respond to your requests and provide support</li>
                <li>To detect and prevent fraud and unauthorized access</li>
              </ul>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">4. Blockchain Data</h2>
              <p>
                Please be aware that any information you submit to the Solana blockchain via our service will be publicly available. The nature of blockchain technology means this information cannot be changed or deleted. This includes your wallet address, transaction details, and token metadata.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">5. IPFS Storage</h2>
              <p>
                We use IPFS (InterPlanetary File System) through Pinata to store token metadata and images. Content uploaded to IPFS is distributed across the network and is publicly accessible by anyone with the content identifier (CID). Once uploaded to IPFS, content may remain available even if deleted from our servers.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">6. Cookies and Similar Technologies</h2>
              <p>
                We use cookies and similar tracking technologies to track activity on our service and hold certain information. You can instruct your browser to refuse all cookies or to indicate when a cookie is being sent.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">7. Data Sharing and Disclosure</h2>
              <p>
                We do not sell or rent your personal information to third parties. We may share your information in the following circumstances:
              </p>
              <ul className="list-disc pl-5 mt-2 space-y-1">
                <li>With service providers who help us operate our platform (such as hosting and IPFS pinning services)</li>
                <li>When required by law or to respond to legal process</li>
                <li>To protect our rights, privacy, safety or property</li>
                <li>In connection with a business transaction such as a merger or acquisition</li>
              </ul>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">8. Security</h2>
              <p>
                We implement reasonable security measures to protect your information. However, no method of transmission over the internet or electronic storage is 100% secure, and we cannot guarantee absolute security.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">9. Your Rights</h2>
              <p>
                Depending on your location, you may have rights regarding your personal data, such as the right to access, correct, or delete your data. Please note that due to the nature of blockchain technology, we may not be able to delete information that has been recorded on the blockchain.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">10. Changes to This Privacy Policy</h2>
              <p>
                We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Last Updated" date.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">11. Contact Us</h2>
              <p>
                If you have any questions about this Privacy Policy, please contact us at support@solminter.com.
              </p>
            </div>
          </div>
        </div>
        
        <div className="flex justify-center">
          <Link 
            href="/"
            className="bg-transparent border border-purple-500 text-purple-500 hover:bg-purple-500 hover:text-white text-lg font-medium py-2 px-8 rounded-full transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/app/terms/page.tsx =====

// src/app/terms/page.tsx

import Link from 'next/link';

export default function TermsOfService() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <h1 className="text-4xl font-bold text-center mb-8">
          <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
            Terms of Service
          </span>
        </h1>
        
        <div className="bg-[#171717] rounded-xl p-8 shadow-lg mb-8">
          <p className="text-gray-400 mb-6">
            Last Updated: April 23, 2025
          </p>
          
          <div className="space-y-6 text-gray-300">
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">1. Acceptance of Terms</h2>
              <p>
                By accessing or using SolMinter's services, you agree to be bound by these Terms of Service. If you do not agree to these terms, please do not use our services.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">2. Description of Service</h2>
              <p>
                SolMinter provides a platform for creating and managing tokens on the Solana blockchain. Our services allow users to create, customize, and revoke authorities for Solana tokens, as well as add metadata and social links.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">3. User Responsibilities</h2>
              <p>
                You are responsible for maintaining the security of your wallet and for all activities that occur under your account. You agree not to use the service for any illegal purposes or to create tokens that infringe upon the intellectual property rights of others.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">4. Fees and Payments</h2>
              <p>
                Creating tokens with SolMinter requires payment of fees in SOL. Fees vary based on the features selected during token creation. All fees are non-refundable once a transaction has been confirmed on the blockchain.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">5. Blockchain Transactions</h2>
              <p>
                All transactions initiated through SolMinter are executed on the Solana blockchain and are irreversible. We cannot reverse, cancel, or refund transactions once they have been confirmed on the blockchain. You acknowledge that blockchain transactions may be subject to network congestion and variable fees.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">6. Token Creation and Management</h2>
              <p>
                SolMinter facilitates the creation of tokens on the Solana blockchain. We do not endorse, guarantee, or take responsibility for any tokens created using our service. You are solely responsible for your token's compliance with applicable laws and regulations. Revoking authorities is permanent and cannot be reversed.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">7. Intellectual Property</h2>
              <p>
                You retain all rights to the content you create using SolMinter, including token names, symbols, descriptions, and logos. By uploading content to our service, you grant us a non-exclusive, worldwide license to store, display, and use such content solely for the purpose of providing the service.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">8. Limitation of Liability</h2>
              <p>
                SolMinter provides its services on an "as is" and "as available" basis. We make no warranties, expressed or implied, regarding the reliability, availability, or suitability of our services. We shall not be liable for any indirect, incidental, special, consequential, or punitive damages.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">9. Modifications to the Service</h2>
              <p>
                We reserve the right to modify, suspend, or discontinue any part of our service at any time without prior notice. We may also update these Terms of Service from time to time. Your continued use of the service after such changes constitutes your acceptance of the new terms.
              </p>
            </div>
            
            <div>
              <h2 className="text-xl font-semibold text-white mb-2">10. Governing Law</h2>
              <p>
                These Terms shall be governed by and construed in accordance with the laws of the jurisdiction in which SolMinter operates, without regard to its conflict of law provisions.
              </p>
            </div>
          </div>
        </div>
        
        <div className="flex justify-center">
          <Link 
            href="/"
            className="bg-transparent border border-purple-500 text-purple-500 hover:bg-purple-500 hover:text-white text-lg font-medium py-2 px-8 rounded-full transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/app/my-tokens/page.tsx =====

// src/app/my-tokens/page.tsx

"use client";

import { useEffect, useState, useCallback } from "react";
import { useWallet } from "@solana/wallet-adapter-react";
import WalletRequired from "@/components/wallet/wallet-required";
import TokenList from "@/components/token/token-list";
import Loading from "@/components/ui/loading";
import NoTokensFound from "@/components/token/no-tokens-found";
import TokenErrorState from "@/components/token/token-error-state";
import { TokenSkeletonList } from "@/components/token/token-skeleton";
import { getUserMintedTokens } from "@/services/token-discovery-service";
import { MintedTokenInfo } from "@/types/token";

export default function MyTokensPage() {
  const { connected, publicKey } = useWallet();
  const [tokens, setTokens] = useState<MintedTokenInfo[]>([]);
  const [initialLoading, setInitialLoading] = useState<boolean>(true);
  const [backgroundLoading, setBackgroundLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [hasSearchedAllPages, setHasSearchedAllPages] = useState<boolean>(false);

  const fetchTokensPage = useCallback(async (pageOffset: number, isInitialLoad: boolean) => {
    if (!connected || !publicKey) return { tokens: [], hasMorePages: false };

    try {
      if (isInitialLoad) {
        setInitialLoading(true);
      } else {
        setBackgroundLoading(true);
      }
      
      setError(null);

      const response = await fetch(`/api/user-tokens?publicKey=${publicKey.toString()}&pageOffset=${pageOffset}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API error: ${errorText}`);
      }
      
      const data = await response.json();
      return {
        tokens: data.tokens || [],
        hasMorePages: data.hasMorePages,
        nextPageOffset: data.nextPageOffset
      };
    } catch (err) {
      console.error(`Error fetching user tokens page ${pageOffset}:`, err);
      setError("Failed to fetch your minted tokens. Please try again later.");
      return { tokens: [], hasMorePages: false };
    } finally {
      if (isInitialLoad) {
        setInitialLoading(false);
      }
    }
  }, [connected, publicKey]);

  const fetchAllUserTokens = useCallback(async () => {
    if (!connected || !publicKey) return;
    
    // Start with the first page (initial load)
    const firstPageResult = await fetchTokensPage(0, true);
    setTokens(firstPageResult.tokens);
    
    // If there are no more pages or we got tokens, we're done with initial load
    if (!firstPageResult.hasMorePages) {
      setHasSearchedAllPages(true);
      setBackgroundLoading(false);
      return;
    }
    
    // Continue loading in the background
    setBackgroundLoading(true);
    
    // Function to recursively fetch all pages
    const fetchRemainingPages = async (nextOffset: number, accumulatedTokens: MintedTokenInfo[]) => {
      const result = await fetchTokensPage(nextOffset, false);
      
      // Combine new tokens with existing ones
      const updatedTokens = [...accumulatedTokens, ...result.tokens];
      setTokens(updatedTokens);
      
      if (result.hasMorePages && result.nextPageOffset) {
        // Continue to next page
        return fetchRemainingPages(result.nextPageOffset, updatedTokens);
      } else {
        // All pages loaded
        setHasSearchedAllPages(true);
        setBackgroundLoading(false);
        return updatedTokens;
      }
    };
    
    // Start background loading from the second page
    if (firstPageResult.nextPageOffset) {
      fetchRemainingPages(firstPageResult.nextPageOffset, firstPageResult.tokens)
        .catch(error => {
          console.error("Error during background loading:", error);
          // Even if background loading fails, we still show what we found initially
          setBackgroundLoading(false);
          setHasSearchedAllPages(true);
        });
    }
  }, [connected, publicKey, fetchTokensPage]);

  useEffect(() => {
    fetchAllUserTokens();
  }, [fetchAllUserTokens]);

  if (!connected) {
    return (
      <div className="min-h-screen">
        <WalletRequired message="Connect your wallet to see your minted tokens" />
      </div>
    );
  }

  if (initialLoading) {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16 text-center">
          <h1 className="text-4xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Discovering Your Tokens
            </span>
          </h1>
          <TokenSkeletonList />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          <TokenErrorState message={error} onRetry={fetchAllUserTokens} />
        </div>
      </div>
    );
  }

  if (tokens.length === 0 && !backgroundLoading && hasSearchedAllPages) {
    return <NoTokensFound />;
  }

  if (tokens.length === 0 && backgroundLoading) {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16 text-center">
          <h1 className="text-4xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Searching Deeper For Your Tokens
            </span>
          </h1>
          <p className="text-gray-400 mb-8">
            We're still looking for your tokens. This might take a bit longer if you minted tokens a while ago.
          </p>
          <div className="flex justify-center mb-8">
            <div className="w-12 h-12 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin"></div>
          </div>
          <NoTokensFound isStillSearching={true} />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <h1 className="text-4xl font-bold text-center mb-6">
          <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
            My Minted Tokens
          </span>
        </h1>
        <p className="text-center text-gray-400 mb-6">
          View and manage all tokens you've created with SolMinter
        </p>
        
        {backgroundLoading && (
          <div className="text-center mb-6 p-2 bg-purple-900/20 rounded-lg border border-purple-500/30">
            <p className="text-purple-300 flex items-center justify-center">
              <svg className="animate-spin h-5 w-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Still searching for more of your tokens...
            </p>
          </div>
        )}
        
        <TokenList tokens={tokens} />
      </div>
    </div>
  );
}

// ===== src/app/guides/page.tsx =====

import GuideHeader from "@/components/guides/guide-header";
import GuidesList from "@/components/guides/guides-list";
import ResourcesList from "@/components/guides/resources-list";

export default function Guides() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <GuideHeader />
        <GuidesList />
        <ResourcesList />
      </div>
    </div>
  );
}

// ===== src/app/create-token/page.tsx =====

import TokenForm from '@/components/token/token-form';

export default function CreateToken() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <TokenForm />
    </div>
  );
}

// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Navbar from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SolMinter - Create Solana Tokens Easily",
  description: "Create, launch, and manage Solana tokens with ease. Your one-stop solution for Solana meme coin creation.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link 
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" 
          rel="stylesheet"
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0a0a0a] text-white`}
      >
        <Providers>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            {/* Add padding-top to main content to account for the fixed navbar */}
            <main className="flex-grow pt-24">{children}</main>
            <Footer />
          </div>
        </Providers>
      </body>
    </html>
  );
}

// ===== src/app/api/upload-metadata/route.ts =====

// src/app/api/upload-metadata/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the metadata from the request body
    const { metadata, fileName, pinataMetadata: customPinataMetadata } = await request.json();
    
    // Use the provided filename or create a default one
    const actualFileName = fileName || 'metadata.json';
    
    console.log("Received metadata for:", metadata.name);
    console.log("Using filename:", actualFileName);
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Prepare pinata options and metadata
      const options = {
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      };
      
      // Create pinata metadata - either use the custom one passed or create a default
      const pinataMetadata = customPinataMetadata || {
        name: actualFileName,
        keyvalues: {
          app: "SolMinter",
          type: "token_metadata",
          symbol: metadata.symbol,
          timestamp: Date.now().toString()
        }
      };
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: JSON.stringify({
          pinataOptions: options,
          pinataMetadata: pinataMetadata,
          pinataContent: metadata
        })
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway,
        fileName: actualFileName
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud',
      fileName: actualFileName
    });
  } catch (error) {
    console.error('Error uploading metadata:', error);
    return NextResponse.json(
      { error: 'Failed to upload metadata' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/update-authority/route.ts =====

// src/app/api/update-authority/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Keypair } from '@solana/web3.js';

/**
 * API route that securely provides the public key of the update authority
 * This keeps the private key on the server side
 */
export async function GET(request: NextRequest) {
  try {
    // Get the private key from environment variables
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updateAuthorityPrivateKey) {
      console.error("REVOKE_UPDATE_PRIVATE_KEY is not set in environment variables");
      return NextResponse.json(
        { 
          success: false, 
          error: "Update authority not configured",
          message: "Server environment is not properly configured for update authority revocation."
        },
        { status: 500 }
      );
    }
    
    try {
      // Decode the base58-encoded private key to generate keypair
      const secretKey = bs58.decode(updateAuthorityPrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      
      // Return only the public key
      return NextResponse.json({
        success: true,
        updateAuthorityPublicKey: updateAuthorityKeypair.publicKey.toString()
      });
    } catch (error) {
      console.error("Error creating update authority keypair:", error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid update authority key format",
          message: "Server has an invalid private key format."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error accessing update authority:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Server error", 
        message: "An unexpected error occurred while accessing the update authority."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/sign-transaction/route.ts =====

// src/app/api/sign-transaction/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import {
  Transaction,
  Keypair,
  PublicKey,
  SystemProgram,
  Connection,
  clusterApiUrl
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  createInitializeMintInstruction,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint
} from "@solana/spl-token";
import { TOKEN_METADATA_PROGRAM_ID, SOLANA_NETWORK } from '@/config';

/** Helper: serialize a UTF‑8 string with u32‑length prefix (LE) */
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/** Helper: serialize metadata for Metaplex createMetadataAccountV3 */
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: PublicKey; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  const nameBuff   = serializeString(data.name);
  const symbolBuff = serializeString(data.symbol);
  const uriBuff    = serializeString(data.uri);

  const feeBuff = Buffer.alloc(2);
  feeBuff.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  let creatorsBuff: Buffer;
  if (!data.creators) {
    creatorsBuff = Buffer.from([0]);
  } else {
    const vec = Buffer.concat(
      data.creators.map(c => Buffer.concat([
        c.address.toBuffer(),
        Buffer.from([c.verified ? 1 : 0]),
        Buffer.from([c.share])
      ]))
    );
    const len = Buffer.alloc(4);
    len.writeUInt32LE(data.creators.length, 0);
    creatorsBuff = Buffer.concat([Buffer.from([1]), len, vec]);
  }

  const collectionBuff = data.collection
    ? Buffer.concat([
        Buffer.from([1]),
        new PublicKey(data.collection.key).toBuffer(),
        Buffer.from([data.collection.verified ? 1 : 0])
      ])
    : Buffer.from([0]);

  const usesBuff              = Buffer.from([0]);
  const collectionDetailsBuff = Buffer.from([0]);
  const isMutableBuff         = Buffer.from([data.isMutable ? 1 : 0]);

  return Buffer.concat([
    nameBuff,
    symbolBuff,
    uriBuff,
    feeBuff,
    creatorsBuff,
    collectionBuff,
    usesBuff,
    collectionDetailsBuff,
    isMutableBuff,
  ]);
}

export async function POST(request: NextRequest) {
  try {
    const {
      mintPrivateKey,
      metadataUrl,
      tokenName,
      tokenSymbol,
      tokenDecimals,
      tokenSupply,
      payerPublicKey,
      hasCreators,
      revokeUpdate,
      revokeMint,
      revokeFreeze,
      recentBlockhash,
      feeWalletPubkey,
      feeAmountInLamports,
      includeFeeTx = false
    } = await request.json();

    // Validate required fields...
    if (!mintPrivateKey || !metadataUrl || !tokenName || !tokenSymbol || !payerPublicKey) {
      return NextResponse.json({ error: "Missing required transaction data" }, { status: 400 });
    }

    // Server‐side update authority key
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    if (revokeUpdate && !updateAuthorityPrivateKey) {
      return NextResponse.json({ error: "Update authority not configured on server" }, { status: 500 });
    }

    const network    = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
    const connection = new Connection(clusterApiUrl(network));

    // Reconstruct the mint keypair
    const mintSecret  = Buffer.from(mintPrivateKey, 'base64');
    const mintKeypair = Keypair.fromSecretKey(new Uint8Array(mintSecret));

    // Choose update authority keypair
    let updateAuthorityKeypair: Keypair;
    if (revokeUpdate) {
      const serverSecret = bs58.decode(updateAuthorityPrivateKey!);
      updateAuthorityKeypair = Keypair.fromSecretKey(serverSecret);
    } else {
      updateAuthorityKeypair = mintKeypair;
    }

    const payer = new PublicKey(payerPublicKey);

    // Build the transaction
    const transaction = new Transaction();
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer       = payer;

    // Optional fee transfer
    if (includeFeeTx && feeWalletPubkey && feeAmountInLamports > 0) {
      transaction.instructions.unshift(
        SystemProgram.transfer({
          fromPubkey: payer,
          toPubkey: new PublicKey(feeWalletPubkey),
          lamports: feeAmountInLamports,
        })
      );
    }

    // Rent‐exempt mint account creation & initialization
    const rentExempt = await getMinimumBalanceForRentExemptMint(connection);
    transaction.add(
      SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: mintKeypair.publicKey,
        space: MINT_SIZE,
        lamports: rentExempt,
        programId: TOKEN_PROGRAM_ID,
      })
    );
    transaction.add(
      createInitializeMintInstruction(
        mintKeypair.publicKey,
        tokenDecimals,
        payer,
        payer,
        TOKEN_PROGRAM_ID
      )
    );

    // Associated Token Account & minting
    const ata = await getAssociatedTokenAddress(mintKeypair.publicKey, payer);
    transaction.add(
      createAssociatedTokenAccountInstruction(
        payer,
        ata,
        payer,
        mintKeypair.publicKey
      )
    );
    const mintAmount = BigInt(tokenSupply) * BigInt(10 ** tokenDecimals);
    transaction.add(
      createMintToInstruction(
        mintKeypair.publicKey,
        ata,
        payer,
        mintAmount
      )
    );

    // Metadata PDA
    const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        metadataProgramId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      metadataProgramId
    );

    // **1.** Prepare creators array - IMPORTANT FIX: Always include creators
    // The payer (wallet owner) must be the creator, but with verified=false
    // They will sign the transaction later, which implicitly verifies them
    const creators = [
      {
        address: payer,
        verified: false,  // CRITICAL FIX: Set verified to false since the server can't verify on behalf of the user
        share: 100,
      }
    ];

    // **2.** Create Metadata instruction
    transaction.add({
      programId: metadataProgramId,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
        { pubkey: payer, isSigner: true, isWritable: false },                // mint authority
        { pubkey: payer, isSigner: true, isWritable: false },                // payer
        { pubkey: updateAuthorityKeypair.publicKey, isSigner: true, isWritable: false }, // update authority
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data: Buffer.concat([
        Buffer.from([33]), // createMetadataAccountV3 discriminator
        serializeMetadataV3({
          name: tokenName,
          symbol: tokenSymbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators,  // Always include creators
          collection: null,
          uses: null,
          isMutable: !revokeUpdate,
        }),
      ]),
    });

    // **3.** Optional authority revocations
    if (revokeMint) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.MintTokens,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }
    if (revokeFreeze) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.FreezeAccount,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    // **4.** Sign with server key if revoking update authority
    if (revokeUpdate) {
      console.log("Signing with server update authority:", updateAuthorityKeypair.publicKey.toString());
      transaction.partialSign(updateAuthorityKeypair);
    }

    // Always sign with the mint keypair
    console.log("Signing with mint keypair:", mintKeypair.publicKey.toString());
    transaction.partialSign(mintKeypair);

    // **5.** Serialize and return for wallet to sign & send
    const serialized = transaction.serialize({ requireAllSignatures: false });
    const b64 = Buffer.from(serialized).toString('base64');

    return NextResponse.json({
      success: true,
      signedTransaction: b64,
      updateAuthority: updateAuthorityKeypair.publicKey.toString(),
      mintAddress: mintKeypair.publicKey.toString(),
    });

  } catch (error) {
    console.error("Error in sign-transaction:", error);
    return NextResponse.json(
      { error: `Failed to sign transaction: ${error instanceof Error ? error.message : error}` },
      { status: 500 }
    );
  }
}

// ===== src/app/api/upload-image/route.ts =====

// src/app/api/upload-image/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const fileName = formData.get('fileName') as string; // Get the custom file name
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    console.log("Received file:", fileName || file.name, "Size:", file.size, "Type:", file.type);
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Create a FormData object to send to Pinata
      const pinataFormData = new FormData();
      
      // If we have a custom fileName, create a new File object with that name
      if (fileName) {
        const newFile = new File([file], fileName, { type: file.type });
        pinataFormData.append('file', newFile);
      } else {
        pinataFormData.append('file', file);
      }
      
      // Add pin options as metadata
      const pinOptions = JSON.stringify({
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      });
      pinataFormData.append('pinataOptions', pinOptions);
      
      // Add metadata
      const metadata = JSON.stringify({
        name: fileName || file.name,
        keyvalues: {
          app: "SolMinter",
          type: "token_image",
          timestamp: Date.now().toString()
        }
      });
      pinataFormData.append('pinataMetadata', metadata);
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: pinataFormData
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway,
        fileName: fileName || file.name // Return the filename used
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud',
      fileName: fileName || file.name // Return the filename used
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/create-token/route.ts =====

// src/app/api/create-token/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Connection, Keypair, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// This API endpoint is for validating the environment is correctly set up
// We don't actually create tokens here - that happens client-side
// But we confirm the update authority keypair is valid
export async function GET(request: NextRequest) {
  try {
    // Check if the required environment variable is present
    const updatePrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updatePrivateKey) {
      return NextResponse.json(
        { 
          ok: false, 
          error: "Update authority private key is not configured",
          message: "The server is not properly configured for revoking update authority. Please check server configuration."
        },
        { status: 500 }
      );
    }
    
    // Try to create a keypair from the private key
    try {
      const secretKey = bs58.decode(updatePrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      const updateAuthorityPublicKey = updateAuthorityKeypair.publicKey.toString();
      
      // Return a redacted version of the public key for confirmation
      const redactedPublicKey = `${updateAuthorityPublicKey.substring(0, 4)}...${updateAuthorityPublicKey.substring(updateAuthorityPublicKey.length - 4)}`;
      
      return NextResponse.json({ 
        ok: true, 
        message: "Update authority configuration is valid", 
        updateAuthority: redactedPublicKey,
        network: SOLANA_NETWORK
      });
    } catch (error) {
      console.error("Error validating update authority keypair:", error);
      return NextResponse.json(
        { 
          ok: false, 
          error: "Invalid update authority key format",
          message: "The server has an incorrectly formatted update authority key."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error in update authority validation:", error);
    return NextResponse.json(
      { 
        ok: false, 
        error: "Server error", 
        message: "An unexpected error occurred while validating the server configuration."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/delete-pinata-files/route.ts =====

// src/app/api/delete-pinata-files/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { uuid } = await request.json();
    
    if (!uuid) {
      return NextResponse.json(
        { error: 'UUID parameter is required' },
        { status: 400 }
      );
    }
    
    console.log(`Attempting to delete Pinata files with UUID: ${uuid}`);
    
    // Get Pinata credentials from environment variables
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    if (!pinataJWT) {
      console.warn('No Pinata JWT found in environment variables');
      return NextResponse.json(
        { error: 'Pinata API credentials not configured' },
        { status: 500 }
      );
    }
    
    // First, we need to get a list of all files
    const searchResponse = await fetch('https://api.pinata.cloud/data/pinList?status=pinned', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${pinataJWT}`
      }
    });
    
    if (!searchResponse.ok) {
      const searchError = await searchResponse.text();
      console.error('Error fetching pin list from Pinata:', searchError);
      return NextResponse.json(
        { error: `Failed to fetch file list from Pinata: ${searchError}` },
        { status: 500 }
      );
    }
    
    const pinListData = await searchResponse.json();
    
    // Find pins containing the UUID in their keyvalues metadata
    // @ts-ignore
    const pinsToDelete = pinListData.rows.filter(pin => {
      // Look for UUID in Pinata metadata keyvalues.sessionUuid
      const metadataMatch = pin.metadata?.keyvalues?.sessionUuid === uuid;
      // Also check in the name as a fallback in case keyvalues aren't used
      const nameMatch = pin.metadata?.name && pin.metadata.name.includes(uuid);
      
      return metadataMatch || nameMatch;
    });
    
    console.log(`Found ${pinsToDelete.length} files containing UUID: ${uuid}`);
    
    // Track deletion results
    const deletionResults = [];
    
    // Delete each matching pin
    for (const pin of pinsToDelete) {
      try {
        const deleteResponse = await fetch(`https://api.pinata.cloud/pinning/unpin/${pin.ipfs_pin_hash}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${pinataJWT}`
          }
        });
        
        if (deleteResponse.ok) {
          console.log(`Successfully deleted: ${pin.ipfs_pin_hash} (${pin.metadata?.name || 'unnamed'})`);
          deletionResults.push({
            cid: pin.ipfs_pin_hash,
            name: pin.metadata?.name || 'unnamed',
            status: 'deleted'
          });
        } else {
          const deleteError = await deleteResponse.text();
          console.error(`Failed to delete ${pin.ipfs_pin_hash}:`, deleteError);
          deletionResults.push({
            cid: pin.ipfs_pin_hash,
            name: pin.metadata?.name || 'unnamed',
            status: 'error',
            error: deleteError
          });
        }
      } catch (error) {
        console.error(`Error deleting ${pin.ipfs_pin_hash}:`, error);
        deletionResults.push({
          cid: pin.ipfs_pin_hash,
          name: pin.metadata?.name || 'unnamed',
          status: 'error',
          error: String(error)
        });
      }
    }
    
    return NextResponse.json({ 
      success: true, 
      message: `Deletion process completed for UUID: ${uuid}`,
      deletedCount: deletionResults.filter(r => r.status === 'deleted').length,
      errorCount: deletionResults.filter(r => r.status === 'error').length,
      details: deletionResults
    });
    
  } catch (error) {
    console.error('Error in delete-pinata-files endpoint:', error);
    return NextResponse.json(
      { error: 'Failed to process deletion request', details: String(error) },
      { status: 500 }
    );
  }
}

// ===== src/app/api/user-tokens/route.ts =====

// src/app/api/user-tokens/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { MintedTokenInfo } from '@/types/token';

export async function GET(request: NextRequest) {
  try {
    // Get the wallet public key from the query parameters
    const url = new URL(request.url);
    const publicKey = url.searchParams.get('publicKey');
    const pageOffset = parseInt(url.searchParams.get('pageOffset') || '0', 10);
    const initialLoad = pageOffset === 0;
    
    if (!publicKey) {
      return NextResponse.json(
        { error: 'Public key is required' },
        { status: 400 }
      );
    }
    
    console.log(`Searching for tokens minted by: ${publicKey}, pageOffset: ${pageOffset}`);
    
    // Get Pinata credentials from environment variables
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    if (!pinataJWT) {
      console.warn('No Pinata JWT found in environment variables');
      return NextResponse.json(
        { error: 'Pinata API credentials not configured' },
        { status: 500 }
      );
    }
    
    // Fetch one page of pins
    const pageLimit = 1000; // Max allowed by Pinata
    
    try {
      console.log(`Fetching pins page with offset: ${pageOffset}, limit: ${pageLimit}`);
      const response = await fetch(
        `https://api.pinata.cloud/data/pinList?status=pinned&pageLimit=${pageLimit}&pageOffset=${pageOffset}`, 
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${pinataJWT}`
          }
        }
      );
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Error fetching pin list from Pinata:', errorText);
        return NextResponse.json(
          { error: `Failed to search Pinata: ${errorText}` },
          { status: 500 }
        );
      }
      
      const data = await response.json();
      console.log(`Fetched ${data.rows?.length || 0} pins for page offset ${pageOffset}`);
      
      // Check if we have more pages to fetch
      const hasMorePages = data.rows && data.rows.length === pageLimit;
      
      // Filter pins to find the token metadata files that belong to this user
      const userTokenPins = (data.rows || []).filter((pin: any) => {
        const nameContainsPublicKey = pin.metadata?.name && pin.metadata.name.includes(publicKey);
        
        // Skip temporary files or files with specific patterns in the name
        const isNotTempFile = pin.metadata?.name && 
          !pin.metadata.name.includes('_metadata.json') && 
          !pin.metadata.name.includes('_image.');
        
        return nameContainsPublicKey && isNotTempFile;
      });
      
      console.log(`Found ${userTokenPins.length} tokens for wallet in this page: ${publicKey}`);
      
      // For each pin, fetch and parse the token metadata
      const tokens: MintedTokenInfo[] = await Promise.all(
        userTokenPins.map(async (pin: any) => {
          try {
            const ipfsUrl = `https://${pinataGateway}/ipfs/${pin.ipfs_pin_hash}`;
            const response = await fetch(ipfsUrl);
            
            if (!response.ok) {
              console.error(`Failed to fetch metadata from ${ipfsUrl}`);
              return null;
            }
            
            const metadata = await response.json();
            
            // Fix for image URL - make sure we preserve the actual image URL
            const imageUrl = metadata.image || null;
            
            // Structure the token data
            return {
              name: metadata.name,
              symbol: metadata.symbol,
              description: metadata.description,
              mintAddress: metadata.mint || '',
              imageUrl: imageUrl, // Use the actual image URL 
              creator: metadata.creator,
              tokenInfo: metadata.tokenInfo,
              authorities: metadata.authorities,
              website: metadata.website,
              twitter: metadata.twitter,
              telegram: metadata.telegram,
              discord: metadata.discord,
              metadataUrl: ipfsUrl,
              pinHash: pin.ipfs_pin_hash,
            } as MintedTokenInfo;
          } catch (err) {
            console.error(`Error processing pin ${pin.ipfs_pin_hash}:`, err);
            return null;
          }
        })
      );
      
      // Filter out any null entries from errors
      const validTokens = tokens.filter(token => token !== null) as MintedTokenInfo[];
      
      return NextResponse.json({
        success: true,
        count: validTokens.length,
        tokens: validTokens,
        hasMorePages,
        nextPageOffset: hasMorePages ? pageOffset + pageLimit : null
      });
      
    } catch (error) {
      console.error('Error during pin fetching:', error);
      return NextResponse.json(
        { error: 'Failed to retrieve user tokens', details: String(error) },
        { status: 500 }
      );
    }
    
  } catch (error) {
    console.error('Error in user-tokens API:', error);
    return NextResponse.json(
      { error: 'Failed to retrieve user tokens', details: String(error) },
      { status: 500 }
    );
  }
}

// ===== src/app/page.tsx =====

import CTASection from "@/components/home/cta-section";
import FeaturesSection from "@/components/home/features-section";
import HeroSection from "@/components/home/hero-section";
import HowItWorksSection from "@/components/home/how-it-works-section";
import TokenCountSection from "@/components/home/token-count-section";

export default function Home() {
  return (
    <div className="bg-[#0a0a0a] overflow-hidden">
      <HeroSection />
      <FeaturesSection />
      <HowItWorksSection />
      <TokenCountSection />
      <CTASection />
    </div>
  );
}

// ===== src/app/providers.tsx =====

'use client';

import { ReactNode, useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Create a client-only wrapper component
const WalletConnectionProvider = ({ children }: { children: ReactNode }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return <>{children}</>;
};

// Dynamically import the wallet components with ssr: false
const ClientWalletProvider = dynamic(
  () => import('../components/wallet/wallet-provider-client').then(module => module.ClientWalletProvider),
  {
    ssr: false,
    loading: () => <WalletConnectionProvider><div>{/* Loading placeholder */}</div></WalletConnectionProvider>
  }
);

export function Providers({ children }: { children: ReactNode }) {
  return (
    <ClientWalletProvider>
      {children}
    </ClientWalletProvider>
  );
}

// ===== src/config/ipfs.ts =====

// src/config/ipfs.ts

/**
 * Configuration for IPFS and Pinata services
 */

// IPFS Gateway configuration
export const IPFS_CONFIG = {
    // Default gateway to use (fallback if environment variable is not set)
    DEFAULT_GATEWAY: 'gateway.pinata.cloud',
    
    // The gateway to use from environment variables or fallback
    GATEWAY: process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud',
    
    // Whether we have proper Pinata credentials (JWT token)
    HAS_PINATA_CREDENTIALS: !!process.env.PINATA_JWT,
    
    // Pinata API endpoints
    PINATA_API: {
      UPLOAD_FILE: 'https://api.pinata.cloud/pinning/pinFileToIPFS',
      UPLOAD_JSON: 'https://api.pinata.cloud/pinning/pinJSONToIPFS',
      REMOVE_PIN: 'https://api.pinata.cloud/pinning/unpin',
    },
    
    // Default pin policy for geographical redundancy
    DEFAULT_PIN_POLICY: {
      regions: [
        {
          id: 'FRA1',
          desiredReplicationCount: 1
        },
        {
          id: 'NYC1',
          desiredReplicationCount: 1
        }
      ]
    }
  };
  
  /**
   * Get the complete IPFS URL with gateway
   * @param cid The IPFS CID
   * @returns Full gateway URL
   */
  export function getIpfsUrl(cid: string): string {
    return `https://${IPFS_CONFIG.GATEWAY}/ipfs/${cid}`;
  }
  
  /**
   * Check if we have proper Pinata credentials
   */
  export function hasPinataCredentials(): boolean {
    return IPFS_CONFIG.HAS_PINATA_CREDENTIALS;
  }

// ===== src/config/index.ts =====

// src/config/index.ts

// Solana network configuration
export const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

// Fee recipient wallet - address that will receive token creation fees
export const FEE_RECIPIENT_WALLET = process.env.NEXT_PUBLIC_FEE_WALLET || '8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt';

// Solana network fee in SOL - this amount is subtracted from the total fee
export const SOLANA_NETWORK_FEE = parseFloat(process.env.NEXT_PUBLIC_SOLANA_NETWORK_FEE || '0.01862');

// IPFS/Pinata configuration
export const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
export const PINATA_API_KEY = process.env.NEXT_PUBLIC_PINATA_API_KEY;
export const PINATA_SECRET_KEY = process.env.NEXT_PUBLIC_PINATA_SECRET_KEY;

// Token creation fees (in SOL)
export const TOKEN_FEES = {
  BASE_FEE: 0.2,  // Base fee for token creation
  AUTHORITY_FEE: 0.1, // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MAX_FEE: 0.3 // Maximum fee (capped for discount)
};

// Default token configuration
export const DEFAULT_TOKEN_CONFIG = {
  decimals: 9,
  supply: 1000000000, // 1 billion
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true
};

// Explorer URL generator
export const getExplorerUrl = (address: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK;
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${address}${network === 'devnet' ? '?cluster=devnet' : ''}`;
};

// Metaplex Token Metadata Program ID (constant across all Solana networks)
// UPDATED: This is the correct Metaplex Token Metadata Program ID
export const TOKEN_METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Program ID for the SPL Token Program
export const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';

// ===== src/utils/ipfs-utils.ts =====

// src/utils/ipfs-utils.ts

/**
 * Utility functions for working with IPFS and Pinata
 */

/**
 * Extracts the CID from an IPFS URL
 */
export function extractCidFromUrl(ipfsUrl: string): string | null {
    try {
      if (ipfsUrl.includes('/ipfs/')) {
        // Format: https://gateway.domain/ipfs/CID
        return ipfsUrl.split('/ipfs/')[1];
      } else if (ipfsUrl.startsWith('ipfs://')) {
        // Format: ipfs://CID
        return ipfsUrl.replace('ipfs://', '');
      }
      return null;
    } catch (error) {
      console.error('Error extracting CID from URL:', error);
      return null;
    }
  }
  
  /**
   * Converts an IPFS URL to use a specific gateway
   */
  export function convertToGatewayUrl(
    ipfsUrl: string, 
    gateway: string = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud'
  ): string {
    const cid = extractCidFromUrl(ipfsUrl);
    if (!cid) return ipfsUrl; // Return original if we can't extract CID
    
    // Make sure gateway doesn't have protocol or trailing slash
    const cleanGateway = gateway.replace(/^https?:\/\//, '').replace(/\/$/, '');
    return `https://${cleanGateway}/ipfs/${cid}`;
  }
  
  /**
   * Logs IPFS operation details for debugging
   */
  export function logIpfsOperation(operation: string, details: any): void {
    console.log(`==== IPFS ${operation.toUpperCase()} ====`);
    console.table(details);
    console.log('==============================');
  }

// ===== src/utils/update-authority-utils.ts =====

// src/utils/update-authority-utils.ts

/**
 * Utility functions for handling update authority operations
 */

/**
 * Validates that the server is properly configured for update authority revocation
 * returns Promise resolving to true if configuration is valid, false otherwise
 */
export async function validateUpdateAuthorityConfig(): Promise<boolean> {
    try {
      const response = await fetch('/api/update-authority', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        console.error("Server configuration check failed:", await response.text());
        return false;
      }
  
      const data = await response.json();
      return data.success === true;
    } catch (error) {
      console.error("Error validating update authority configuration:", error);
      return false;
    }
  }
  
  /**
   * Checks the update authority configuration when the form loads or when
   * the user toggles the revokeUpdate option
   * @param enabled Whether revoke update is enabled
   * @param onWarning Callback for showing a warning to the user
   */
  export async function checkUpdateAuthorityStatus(
    enabled: boolean,
    onWarning: (message: string) => void
  ): Promise<void> {
    // Only check if the feature is enabled
    if (enabled) {
      const isValid = await validateUpdateAuthorityConfig();
      
      if (!isValid) {
        onWarning(
          "Warning: The server is not properly configured for revoking update authority. " +
          "This feature might not work correctly. Please contact support."
        );
      } else {
        // Clear any previous warnings if valid
        onWarning("");
      }
    }
  }
  
  /**
   * Gets the update authority public key from the server
   * @returns Promise resolving to the update authority public key
   */
  export async function getUpdateAuthorityPublicKey(): Promise<string | null> {
    try {
      const response = await fetch('/api/update-authority');
      
      if (!response.ok) {
        console.error("Failed to get update authority:", await response.text());
        return null;
      }
      
      const data = await response.json();
      
      if (!data.success || !data.updateAuthorityPublicKey) {
        console.error("Invalid response from update authority endpoint:", data);
        return null;
      }
      
      return data.updateAuthorityPublicKey;
    } catch (error) {
      console.error("Error getting update authority public key:", error);
      return null;
    }
  }

// ===== src/utils/wallet-debug.ts =====

// src/utils/wallet-debug.ts

/**
 * Helper function to debug wallet connection status
 */
export function debugWallet(wallet: any) {
    const connection = {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      publicKeyValue: wallet && wallet.publicKey ? wallet.publicKey.toString() : 'none',
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false,
      walletName: wallet?.adapter?.name || 'unknown'
    };
    
    console.log("===== WALLET DEBUG INFO =====");
    console.table(connection);
    console.log("=============================");
    
    return connection;
  }
  
  /**
   * Helper function to debug wallet adapter capabilities
   */
  export function debugWalletCapabilities(wallet: any) {
    if (!wallet || !wallet.adapter) {
      console.log("No wallet adapter found");
      return;
    }
    
    const adapter = wallet.adapter;
    
    const capabilities = {
      name: adapter.name,
      icon: !!adapter.icon,
      connected: !!adapter.connected,
      publicKey: !!adapter.publicKey,
      connecting: !!adapter.connecting,
      ready: !!adapter.ready,
      supportedTransactionVersions: adapter.supportedTransactionVersions ? 
        Array.from(adapter.supportedTransactionVersions) : [],
      hasConnect: typeof adapter.connect === 'function',
      hasDisconnect: typeof adapter.disconnect === 'function',
      hasSignTransaction: typeof adapter.signTransaction === 'function',
      hasSignAllTransactions: typeof adapter.signAllTransactions === 'function',
      hasSignMessage: typeof adapter.signMessage === 'function',
      hasSendTransaction: typeof adapter.sendTransaction === 'function',
    };
    
    console.log("===== WALLET CAPABILITIES =====");
    console.table(capabilities);
    console.log("===============================");
    
    return capabilities;
  }

// ===== src/utils/error-utils.ts =====

// src/utils/error-utils.ts

/**
 * Formats Solana errors into user-friendly messages
 */
export function formatSolanaError(error: any): string {
    // If it's already a string, just return it
    if (typeof error === 'string') return error;
    
    // Extract error message from Error object
    const errorMessage = error.message || 'Unknown error occurred';
    
    // Handle specific Solana error messages
    if (errorMessage.includes('0x1')) {
      return 'Insufficient funds for transaction. Please make sure you have enough SOL to cover the fees.';
    }
    
    if (errorMessage.includes('Blockhash not found')) {
      return 'Network congestion detected. Please try again in a few moments.';
    }
    
    if (errorMessage.includes('Transaction simulation failed')) {
      return 'Transaction simulation failed. This could be due to network congestion or insufficient SOL.';
    }
    
    if (errorMessage.includes('User rejected')) {
      return 'Transaction was rejected by wallet. You must approve the transaction to continue.';
    }
    
      // Handle wallet connection errors
    if (errorMessage.includes('wallet disconnected') || errorMessage.includes('wallet not connected')) {
      return 'Wallet disconnected. Please reconnect your wallet and try again.';
    }
    
    if (errorMessage.includes('timeout')) {
      return 'Transaction timed out. The Solana network might be congested, please try again.';
    }
    
    // Handle metadata errors
    if (errorMessage.includes('metadata')) {
      return 'Error with token metadata. Please ensure your token information is valid.';
    }
    
    // Handle Pinata/IPFS errors
    if (errorMessage.includes('Pinata') || errorMessage.includes('IPFS')) {
      return 'Error uploading to IPFS. Please try again or check if your image file is valid.';
    }
  
    // Fall back to the original error message
    return errorMessage;
  }
  
  /**
   * Logs detailed error information
   */
  export function logError(error: any, context: string): void {
    console.error(`Error in ${context}:`, error);
    
    // Log additional information if available
    if (error.code) {
      console.error(`Error code: ${error.code}`);
    }
    
    if (error.stack) {
      console.error(`Stack trace: ${error.stack}`);
    }
    
    // For Solana-specific errors
    if (error.logs) {
      console.error('Solana logs:', error.logs);
    }
  }
  
  /**
   * Creates a user-friendly error message for validation errors
   */
  export function getValidationErrorMessage(field: string, message: string): string {
    return `${field}: ${message}`;
  }
  
  /**
   * Checks common token validation rules
   */
  export function validateTokenData(data: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
  }): string | null {
    if (!data.name || data.name.trim() === '') {
      return 'Token name is required';
    }
    
    if (data.name.length > 32) {
      return 'Token name must be 32 characters or less';
    }
    
    if (!data.symbol || data.symbol.trim() === '') {
      return 'Token symbol is required';
    }
    
    if (data.symbol.length > 10) {
      return 'Token symbol must be 10 characters or less';
    }
    
    if (data.decimals < 0 || data.decimals > 18) {
      return 'Decimals must be between 0 and 18';
    }
    
    if (data.supply <= 0) {
      return 'Supply must be greater than 0';
    }
    
    if (data.supply > Number.MAX_SAFE_INTEGER) {
      return 'Supply is too large';
    }
    
    return null;
  }

// ===== src/utils/token-utils.ts =====

// src/utils/token-utils.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length < 2 || symbol.length > 10) {
      return false;
    }
    
    // Most token symbols are uppercase alphanumeric
    const validSymbolRegex = /^[A-Z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Formats a wallet address for display 
   */
  export function formatWalletAddress(address: string): string {
    if (!address || address.length < 10) return address;
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  }
  
  /**
   * Generates a token explorer URL
   */
  export function getTokenExplorerUrl(tokenAddress: string, network: string = 'devnet'): string {
    return `https://explorer.solana.com/address/${tokenAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`;
  }

// ===== src/utils/token-validation.ts =====

// src/utils/token-validation.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters - allow more flexibility than the original
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length > 10) {
      return false;
    }
    
    // Allow more flexibility in symbol format
    const validSymbolRegex = /^[A-Za-z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token description
   */
  export function isValidTokenDescription(description: string): boolean {
    // Description should exist
    if (!description || description.trim() === '') {
      return false;
    }
    
    // Reasonable length limit
    if (description.length > 1000) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits - allow bigger supply than original
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates token decimals
   */
  export function isValidTokenDecimals(decimals: number): boolean {
    // Decimals must be in the valid range for Solana tokens
    return Number.isInteger(decimals) && decimals >= 0 && decimals <= 9;
  }
  
  /**
   * Validates an image file for token logo
   */
  export function isValidTokenImage(file: File | null): boolean {
    if (!file) {
      return false;
    }
    
    // Check file type
    const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!validTypes.includes(file.type)) {
      return false;
    }
    
    // Check file size (max 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Validates the entire token form data
   * @returns string error message or null if valid
   */
  export function validateTokenForm(formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  }): string | null {
    if (!isValidTokenName(formData.name)) {
      return "Token name is required and must be up to 32 alphanumeric characters";
    }
    
    if (!isValidTokenSymbol(formData.symbol)) {
      return "Token symbol is required and must be 2-10 alphanumeric characters";
    }
    
    if (!isValidTokenDescription(formData.description)) {
      return "Description is required and must be less than 1000 characters";
    }
    
    if (!isValidTokenDecimals(formData.decimals)) {
      return "Decimals must be a whole number between 0 and 9";
    }
    
    if (!isValidTokenSupply(formData.supply)) {
      return "Supply must be a positive whole number";
    }
    
    if (!isValidTokenImage(formData.logo)) {
      return "Logo image is required (PNG or JPG, max 5MB)";
    }
    
    return null;
  }

// ===== src/components/token/token-form-options.tsx =====

'use client';

import React from 'react';
import SocialLinksForm from './social-links-form';

interface TokenFormOptionsProps {
  formData: {
    socialLinks: boolean;
    creatorInfo: boolean;
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
}

export default function TokenFormOptions({
  formData,
  setFormData,
  handleInputChange
}: TokenFormOptionsProps) {
  // Toggle function that also updates the input checkbox
  const toggleOption = (option: 'socialLinks' | 'creatorInfo') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev, 
      [option]: !prev[option]
    }));
    
    // Also simulate changing the checkbox by dispatching an event
    const checkbox = document.getElementById(option) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[option];
      const event = new Event('change', { bubbles: true });
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="creatorInfo" 
                type="checkbox" 
                name="creatorInfo"
                checked={formData.creatorInfo}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.creatorInfo ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('creatorInfo')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.creatorInfo ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Creator's Info (Optional)</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Change the information of the creator in the metadata. By default, it is SolMinter.
        </div>
      </div>

      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="socialLinks" 
                type="checkbox" 
                name="socialLinks"
                checked={formData.socialLinks}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.socialLinks ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('socialLinks')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.socialLinks ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Add Social Links & Tags</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Add links to your token metadata.
        </div>
      </div>
      
      {formData.socialLinks && (
        <SocialLinksForm formData={formData} handleInputChange={handleInputChange} />
      )}
    </div>
  );
}

// ===== src/components/token/token-form.tsx =====

// src/components/token/token-form.tsx

"use client"

import { useState, useCallback, useEffect, useRef } from "react"
import { useWallet, useConnection } from "@solana/wallet-adapter-react"
import { useRouter, usePathname } from "next/navigation"
import {
  createTokenWithMetadata,
} from "@/services/token-service"
import { calculateFee, formatFee } from "@/services/fee-service"
import TokenCreationSuccess from "./token-creation-success"
import Loading from "../ui/loading"
import TokenFormBasic from "./token-form-basic"
import TokenFormOptions from "./token-form-options"
import TokenFormAuthorities from "./token-form-authorities"
import TokenFormCreator from "./token-form-creator"
import WalletRequired from "../wallet/wallet-required"
import { FormDataType, TokenResult } from "@/types/token"
import { SOLANA_NETWORK_FEE } from "@/config"
import { resetSessionUuid } from "@/services/ipfs-service"

// Enhanced steps with more concise and user-friendly messages
const STEPS = [
  "Uploading token image...",
  "Creating token metadata...",
  "Preparing transaction...",
  "Processing on blockchain...",
  "Finalizing token details...",
  "Almost done...",
  "Completing token creation...",
]

const DEFAULT_FORM_DATA: FormDataType = {
  name: "",
  symbol: "",
  decimals: 9,
  supply: 1_000_000_000,
  description: "",
  logo: null,
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true,
  socialLinks: false,
  creatorInfo: false,
  creatorName: "SolMinter", // Default creator name
  website: "",
  twitter: "",
  telegram: "",
  discord: "",
};

export default function TokenForm() {
  const walletAdapter = useWallet()
  const { connection } = useConnection()
  const router = useRouter()
  const pathname = usePathname()
  const formRef = useRef<HTMLDivElement>(null)

  const [formData, setFormData] = useState<FormDataType>(DEFAULT_FORM_DATA)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [progressStep, setProgressStep] = useState(0)
  const [tokenResult, setTokenResult] = useState<TokenResult | null>(null)
  const [totalFee, setTotalFee] = useState<number>(0.4) // Initial fee calculation with all defaults
  const [formSubmitAttempted, setFormSubmitAttempted] = useState(false) // Track form submission attempts
  const [cancelled, setCancelled] = useState(false) // Track if token creation was cancelled

  // Register all useEffects before any conditional rendering

  // Check if we're on the success page and add window event listener for navigation
  useEffect(() => {
    // Handle clicks on "Create Token" when on success page
    if (tokenResult) {
      const handleCreateTokenClick = (e: MouseEvent) => {
        // Check if the clicked element or its parent is the "Create Token" link
        const target = e.target as HTMLElement;
        const link = target.closest('a[href="/create-token"]');
        
        if (link) {
          e.preventDefault();
          window.location.href = '/create-token';
        }
      };
      
      window.addEventListener('click', handleCreateTokenClick);
      return () => window.removeEventListener('click', handleCreateTokenClick);
    }
  }, [tokenResult]);

  // Reset form when navigating to this page
  useEffect(() => {
    if (pathname === '/create-token') {
      // Reset the session UUID to ensure clean state
      resetSessionUuid();
      setFormData(DEFAULT_FORM_DATA)
      setTokenResult(null)
      setError(null)
      setCancelled(false)
      setFormSubmitAttempted(false)
      setIsSubmitting(false)
    }
  }, [pathname])

  // Force reset form state completely when coming directly to the create-token page
  useEffect(() => {
    // Check if we're accessing the page directly (through URL or refresh)
    const isDirectNavigation = window.performance
      ?.getEntriesByType('navigation')
      .some((nav: any) => ['reload', 'navigate'].includes(nav.type));

    if (isDirectNavigation && pathname === '/create-token') {
      // Reset all state
      resetSessionUuid();
      setFormData(DEFAULT_FORM_DATA)
      setTokenResult(null)
      setError(null)
      setCancelled(false)
      setFormSubmitAttempted(false)
      setIsSubmitting(false)
    }
  }, [pathname])

  // Calculate fee whenever relevant form options change
  useEffect(() => {
    const fee = calculateFee({
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    console.log("Calculated fee:", fee, "with options:", {
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    setTotalFee(fee)
  }, [
    formData.revokeMint,
    formData.revokeFreeze,
    formData.revokeUpdate,
    formData.socialLinks,
    formData.creatorInfo,
  ])

  // Scroll to top effect for success and loading states
  useEffect(() => {
    if (isSubmitting || tokenResult) {
      window.scrollTo(0, 0);
      document.body.scrollTop = 0; // For Safari
    }
  }, [isSubmitting, tokenResult]);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target as HTMLInputElement
    const checked = type === 'checkbox' ? (e.target as HTMLInputElement).checked : undefined
    
    console.log(`Input changed: ${name} = ${type === 'checkbox' ? checked : value}`)
    
    setFormData((prev) => ({
      ...prev,
      [name]:
        type === "checkbox"
          ? checked
          : type === "number"
          ? parseInt(value)
          : value,
    }))
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFormData((prev) => ({ ...prev, logo: e.target.files![0] }))
    }
  }

  // Function to validate form data before submission
  const validateForm = (): string | null => {
    if (!walletAdapter.connected) {
      return "Please connect your wallet first";
    }
    if (!formData.logo) {
      return "Please upload a logo image";
    }
    if (!formData.name || formData.name.trim() === '') {
      return "Token name is required";
    }
    if (!formData.symbol || formData.symbol.trim() === '') {
      return "Token symbol is required";
    }
    if (!formData.description || formData.description.trim() === '') {
      return "Token description is required";
    }
    return null;
  };

  // Handle cancellation from the loading screen
  const handleCancel = useCallback(() => {
    console.log("Cancel button clicked by user");
    setCancelled(true);
    setIsSubmitting(false);
    setError("Token creation was cancelled.");
    resetSessionUuid(); // Make sure to reset session UUID
    
    // Scroll back to the form
    setTimeout(() => {
      formRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, 100);
  }, []);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      
      // Reset from any previous canceled state
      setCancelled(false);
      
      // Mark that a submission attempt was made
      setFormSubmitAttempted(true)
      
      // Clear previous errors and reset cancellation state
      setError(null)
      
      // Validate form
      const validationError = validateForm();
      if (validationError) {
        setError(validationError);
        return;
      }

      try {
        // Ensure we have a clean session before starting
        resetSessionUuid();
        
        setIsSubmitting(true)
        setProgressStep(0)
        
        // Force scroll to top when starting the loading process
        window.scrollTo(0, 0);
        document.body.scrollTop = 0; // For Safari

        const result = await createTokenWithMetadata(
          walletAdapter,
          formData,
          totalFee, // Pass the calculated total fee
          (step) => {
            // Skip progress updates if cancelled
            if (!cancelled) {
              setProgressStep(step);
              // Keep ensuring we're at the top for each step
              window.scrollTo(0, 0);
            }
          }
        )
        setTokenResult(result)
        // Ensure we're at the top for the success screen too
        window.scrollTo(0, 0);
      } catch (err: any) {
        console.error("Token creation error:", err)
        setError(err.message || "Unknown error occurred during token creation")
        
        // Scroll back to the form on error
        setTimeout(() => {
          formRef.current?.scrollIntoView({ behavior: 'smooth' });
        }, 100);
      } finally {
        if (!cancelled) {
          setIsSubmitting(false)
        }
      }
    },
    [walletAdapter, formData, totalFee, cancelled]
  )

  // Render based on current state
  if (tokenResult) {
    return <TokenCreationSuccess result={tokenResult} />
  }

  if (isSubmitting) {
    return (
      <Loading
        message="Creating Your Token"
        steps={STEPS}
        currentStepIndex={progressStep}
        onCancel={handleCancel}
      />
    )
  }

  // If wallet is not connected, use the shared WalletRequired component
  if (!walletAdapter.connected) {
    return <WalletRequired message="Please connect your wallet to create a new Solana token" />;
  }

  // Calculate net fee after Solana network fee
  const netFee = Math.max(totalFee - SOLANA_NETWORK_FEE, 0);

  return (
    <div ref={formRef}>
      <form
        onSubmit={handleSubmit}
        className="max-w-3xl mx-auto space-y-6 p-6 bg-[#171717] rounded-xl my-12"
      >
        {error && (
          <div className="text-red-400 bg-red-800/30 p-3 rounded mb-4">{error}</div>
        )}

        <TokenFormBasic
          formData={formData}
          handleInputChange={handleInputChange}
          handleFileChange={handleFileChange}
          formSubmitted={formSubmitAttempted}
        />

        <TokenFormOptions
          formData={formData}
          setFormData={setFormData}
          handleInputChange={handleInputChange}
        />

        {formData.creatorInfo && (
          <TokenFormCreator
            formData={formData}
            handleInputChange={handleInputChange}
          />
        )}

        <TokenFormAuthorities
          formData={formData}
          setFormData={setFormData}
        />

        {/* Display dynamic feature‐fee total */}
        <div className="flex justify-between items-center text-gray-300">
          <span>Total fee:</span>
          <span className="text-purple-500 font-semibold">
            {formatFee(totalFee)}
          </span>
        </div>

        <button
          type="submit"
          className="w-full py-3 rounded-full text-white font-medium transition cursor-pointer bg-gradient-to-r from-purple-600 to-blue-500 hover:opacity-90"
        >
          Launch Token
        </button>
      </form>
    </div>
  )
}

// ===== src/components/token/token-detail-view.tsx =====

'use client';

import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { MintedTokenInfo } from '@/types/token';
import { SOLANA_NETWORK } from '@/config';
import { formatNumberWithCommas } from '@/utils/token-utils';

interface TokenDetailViewProps {
  token: MintedTokenInfo;
  onClose: () => void;
}

export default function TokenDetailView({ token, onClose }: TokenDetailViewProps) {
  const [activeTab, setActiveTab] = useState<'details' | 'social' | 'explorer'>('details');
  const modalRef = useRef<HTMLDivElement>(null);
  
  const networkParam = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const explorerUrl = `https://explorer.solana.com/address/${token.mintAddress}${networkParam}`;
  const raydiumLiquidityUrl = `https://raydium.io/liquidity/create-pool${networkParam.replace('?', '#')}`;
  const raydiumSwapUrl = `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${token.mintAddress}${networkParam.replace('?', '&')}`;

  // Check if social links exist
  const hasSocialLinks = !!(token.website || token.twitter || token.telegram || token.discord);

  // Handle click outside to close modal
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {
        onClose();
      }
    }
    
    // Add event listener when the component mounts
    document.addEventListener('mousedown', handleClickOutside);
    
    // Prevent body scrolling while modal is open
    document.body.style.overflow = 'hidden';
    
    // Clean up
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.body.style.overflow = 'auto';
    };
  }, [onClose]);

  return (
    <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50 p-4 overflow-auto">
      <div 
        ref={modalRef}
        className="relative bg-[#171717] rounded-xl shadow-xl border border-gray-800 max-w-2xl w-full max-h-[90vh] flex flex-col"
      >
        {/* Header - Fixed position */}
        <div className="flex justify-between items-center p-6 border-b border-gray-800">
          <h3 className="text-2xl font-bold text-white truncate pr-4">{token.name} ({token.symbol})</h3>
          <button 
            onClick={onClose}
            className="text-gray-400 hover:text-white flex-shrink-0 hover:cursor-pointer"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        
        {/* Tabs - Fixed position */}
        <div className="flex border-b border-gray-800 sticky top-0 bg-[#171717] z-10">
          <button 
            onClick={() => setActiveTab('details')}
            className={`flex-1 py-3 px-4 text-center ${activeTab === 'details' 
              ? 'text-purple-500 border-b-2 border-purple-500'
              : 'text-gray-400 hover:text-gray-200 hover:cursor-pointer'}`}
          >
            Token Details
          </button>
          {hasSocialLinks && (
            <button 
              onClick={() => setActiveTab('social')}
              className={`flex-1 py-3 px-4 text-center ${activeTab === 'social' 
                ? 'text-purple-500 border-b-2 border-purple-500'
                : 'text-gray-400 hover:text-gray-200 hover:cursor-pointer'}`}
            >
              Social Links
            </button>
          )}
          <button 
            onClick={() => setActiveTab('explorer')}
            className={`flex-1 py-3 px-4 text-center ${activeTab === 'explorer' 
              ? 'text-purple-500 border-b-2 border-purple-500'
              : 'text-gray-400 hover:text-gray-200 hover:cursor-pointer'}`}
          >
            Explorer
          </button>
        </div>
        
        {/* Content - Scrollable area */}
        <div className="p-6 overflow-y-auto flex-grow">
          {activeTab === 'details' && (
            <div className="space-y-6">
              <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="w-32 h-32 rounded-full bg-gradient-to-r from-purple-900/20 to-blue-900/20 flex items-center justify-center flex-shrink-0">
                  {token.imageUrl || token.image ? (
                    <img 
                      src={token.imageUrl || token.image} 
                      alt={token.name} 
                      className="w-28 h-28 object-contain rounded-full"
                      onError={(e) => {
                        (e.target as HTMLImageElement).style.display = 'none';
                        (e.target as HTMLImageElement).parentElement!.innerHTML = `
                          <div class="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
                            <span class="text-3xl font-bold text-gray-600">${token.symbol.substring(0, 2)}</span>
                          </div>
                        `;
                      }}
                    />
                  ) : (
                    <div className="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
                      <span className="text-3xl font-bold text-gray-600">{token.symbol.substring(0, 2)}</span>
                    </div>
                  )}
                </div>
                
                <div className="flex-1 text-center md:text-left">
                  <h4 className="text-xl font-bold text-white">{token.name}</h4>
                  <p className="text-purple-400 font-mono">{token.symbol}</p>
                  
                  <div className="mt-2 space-y-1">
                    <div className="text-gray-300">
                      <span className="text-gray-500">Total Supply:</span> {formatNumberWithCommas(token.tokenInfo?.totalSupply || 0)}
                    </div>
                    <div className="text-gray-300">
                      <span className="text-gray-500">Decimals:</span> {token.tokenInfo?.decimals || 9}
                    </div>
                    <div className="text-gray-300">
                      <span className="text-gray-500">Creator:</span> {token.creator || 'Unknown'}
                    </div>
                  </div>
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Description</h5>
                <p className="text-gray-300 bg-[#222] p-3 rounded-lg">
                  {token.description || "No description provided"}
                </p>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Token Address</h5>
                <div className="font-mono text-gray-300 bg-[#222] p-3 rounded-lg text-sm overflow-x-auto">
                  {token.mintAddress || token.mint}
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Authorities</h5>
                <div className="bg-[#222] p-3 rounded-lg">
                  <ul className="space-y-2">
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.mintRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Mint Authority: {token.authorities?.mintRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.freezeRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Freeze Authority: {token.authorities?.freezeRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                    <li className="flex items-center">
                      <div className={`w-4 h-4 rounded-full mr-2 ${token.authorities?.updateRevoked ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className="text-gray-300">Update Authority: {token.authorities?.updateRevoked ? 'Revoked' : 'Active'}</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          )}
          
          {activeTab === 'social' && hasSocialLinks && (
            <div className="space-y-6">
              {token.website && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Website</h5>
                  <a 
                    href={token.website}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                    </svg>
                    <span className="break-all">{token.website}</span>
                  </a>
                </div>
              )}
              
              {token.twitter && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Twitter</h5>
                  <a 
                    href={token.twitter}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-400 hover:text-blue-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                    </svg>
                    <span className="break-all">{token.twitter}</span>
                  </a>
                </div>
              )}
              
              {token.telegram && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Telegram</h5>
                  <a 
                    href={token.telegram}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-500 hover:text-blue-400"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                    </svg>
                    <span className="break-all">{token.telegram}</span>
                  </a>
                </div>
              )}
              
              {token.discord && (
                <div>
                  <h5 className="text-white text-lg font-medium mb-2">Discord</h5>
                  <a 
                    href={token.discord}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-indigo-400 hover:text-indigo-300"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    <span className="break-all">{token.discord}</span>
                  </a>
                </div>
              )}
            </div>
          )}
          
          {activeTab === 'explorer' && (
            <div className="space-y-6">
              <div>
                <h5 className="text-white text-lg font-medium mb-2">Explorer Links</h5>
                <div className="space-y-3">
                  <a 
                    href={explorerUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                    </svg>
                    <span>View on Solana Explorer</span>
                  </a>
                  
                  <a 
                    href={raydiumLiquidityUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-400 hover:text-blue-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span>Create Liquidity Pool on Raydium</span>
                  </a>
                  
                  <a 
                    href={raydiumSwapUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-green-400 hover:text-green-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                    </svg>
                    <span>Swap on Raydium</span>
                  </a>
                </div>
              </div>
              
              <div>
                <h5 className="text-white text-lg font-medium mb-2">IPFS Links</h5>
                <div className="space-y-3">
                  <a 
                    href={token.metadataUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-purple-400 hover:text-purple-300 bg-[#222] p-3 rounded-lg"
                    onClick={(e) => e.stopPropagation()}
                  >
                    <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <span>View Metadata on IPFS</span>
                  </a>
                  
                  {(token.image || token.imageUrl) && (
                    <a 
                      href={token.image || token.imageUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="flex items-center text-blue-400 hover:text-blue-300 bg-[#222] p-3 rounded-lg"
                      onClick={(e) => e.stopPropagation()}
                    >
                      <svg className="w-5 h-5 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                      </svg>
                      <span>View Image on IPFS</span>
                    </a>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
        
        {/* Footer - Fixed at bottom */}
        <div className="border-t border-gray-800 p-6 flex justify-between items-center">
          <div className="text-sm text-gray-500">
            Created with SolMinter
          </div>
          
          <button 
            onClick={onClose}
            className="bg-purple-600 hover:bg-purple-700 text-white py-2 px-6 rounded-full transition-colors hover:cursor-pointer"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-creation-success.tsx =====

'use client';

import Link from 'next/link';
import React, { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import CheckmarkAnimation from '../ui/checkmark-animation';
import CopyButton from '../ui/copy-button';
import '../../styles/checkmark.css';

interface TokenCreationSuccessProps {
  result: {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  };
}

export default function TokenCreationSuccess({ result }: TokenCreationSuccessProps) {
  const router = useRouter();

  // Ensure we're at the top of the page when this component mounts
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []);

  // Function to handle creating another token
  const handleCreateAnother = () => {
    // Force a hard navigation to reset the page
    window.location.href = '/create-token';
  };

  return (
    <div className="max-w-3xl mx-auto py-12 px-4">
      <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-purple-500/30 border-opacity-30">
        <div className="text-center mb-8">
          <CheckmarkAnimation />
          
          <h1 className="text-3xl font-bold text-white mb-2">Token Created Successfully!</h1>
          <p className="text-gray-400 text-lg">Your Solana token has been created and is ready to use.</p>
        </div>
        
        <div className="token-info bg-[#222] rounded-lg p-5 mb-8">
          <div className="flex items-center justify-center mb-6">
            <img 
              src={result.imageUrl} 
              alt="Token Logo" 
              className="w-24 h-24 rounded-full border-4 border-gray-700"
            />
          </div>
          
          <div className="mb-6 relative">
            <div className="text-gray-500 text-sm flex items-center justify-between">
              <span>Token Address</span>
              <CopyButton textToCopy={result.mintAddress} />
            </div>
            <div className="font-mono text-white text-sm bg-[#333] p-3 rounded mt-1 overflow-x-auto">
              {result.mintAddress}
            </div>
            <div className="flex justify-end mt-2">
              <a 
                href={result.explorerUrl} 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-purple-400 text-sm hover:text-purple-300 flex items-center"
              >
                View on Explorer
                <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                </svg>
              </a>
            </div>
          </div>
        </div>
        
        <div className="next-steps space-y-4 mb-8">
          <h2 className="text-xl font-semibold text-white mb-4">Next Steps</h2>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">Create Liquidity</h3>
            <p className="text-gray-400 mb-2">Create a liquidity pool on a DEX like Raydium to make your token tradable.</p>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to Raydium
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
        </div>
        
        <div className="buttons flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4">
          <Link 
            href="/my-tokens"
            className="btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all text-center"
          >
            View My Tokens
          </Link>
          
          <button
            onClick={handleCreateAnother}
            className="btn bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Create Another Token
          </button>
          
          <Link 
            href="/"
            className="btn bg-transparent border border-gray-700 text-gray-400 font-medium py-3 px-8 rounded-full hover:bg-gray-700 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-analytics.tsx =====

'use client';

import React from 'react';
import { MintedTokenInfo } from '@/types/token';
import { formatNumberWithCommas } from '@/utils/token-utils';

interface TokenAnalyticsProps {
  tokens: MintedTokenInfo[];
}

export default function TokenAnalytics({ tokens }: TokenAnalyticsProps) {
  if (!tokens || tokens.length === 0) return null;

  // Calculate total token count
  const tokenCount = tokens.length;

  // Calculate total supply across all tokens
  const totalSupply = tokens.reduce((sum, token) => 
    sum + (token.tokenInfo?.totalSupply || 0), 0);

  // Count revoked authorities across all tokens
  const revokedAuthoritiesCount = {
    mint: tokens.filter(token => token.authorities?.mintRevoked).length,
    freeze: tokens.filter(token => token.authorities?.freezeRevoked).length,
    update: tokens.filter(token => token.authorities?.updateRevoked).length
  };

  // Count tokens with social links
  const tokensWithSocialLinks = tokens.filter(token => 
    token.website || token.twitter || token.telegram || token.discord
  ).length;

  return (
    <div className="bg-[#171717] rounded-xl p-6 shadow-lg mb-8">
      <h2 className="text-xl font-semibold text-white mb-4">Token Analytics</h2>
      
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-purple-400 text-sm mb-1">Total Tokens</div>
          <div className="text-white text-2xl font-bold">{tokenCount}</div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-blue-400 text-sm mb-1">Total Supply</div>
          <div className="text-white text-2xl font-bold">{formatNumberWithCommas(totalSupply)}</div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-green-400 text-sm mb-1">Revoked Authorities</div>
          <div className="flex space-x-2 mt-2">
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Mint: {revokedAuthoritiesCount.mint}
            </div>
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Freeze: {revokedAuthoritiesCount.freeze}
            </div>
            <div className="bg-green-900/30 text-green-300 text-xs px-2 py-1 rounded">
              Update: {revokedAuthoritiesCount.update}
            </div>
          </div>
        </div>
        
        <div className="bg-[#222] p-4 rounded-lg">
          <div className="text-yellow-400 text-sm mb-1">Social Links</div>
          <div className="text-white">
            <span className="text-2xl font-bold">{tokensWithSocialLinks}</span>
            <span className="text-gray-400 text-sm ml-1">/ {tokenCount}</span>
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Overview of your created tokens and their configuration.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-creator.tsx =====

'use client';

import React from 'react';

interface TokenFormCreatorProps {
  formData: {
    creatorName: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormCreator({ 
  formData, 
  handleInputChange 
}: TokenFormCreatorProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Creator Information</div>
      
      <div className="bg-[#1e1e1e] rounded-lg p-4">
        <div className="form-field mb-4">
          <label className="field-label block text-gray-300 mb-2">Creator Name</label>
          <input 
            placeholder="Enter creator name" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="creatorName"
            value={formData.creatorName}
            onChange={handleInputChange}
          />
          <span className="field-constraint text-xs text-gray-500 mt-1 block">
            This name will appear as the creator in token metadata
          </span>
        </div>
      </div>
      
      <div className="text-xs text-gray-500 mt-2">
        Customize the creator information instead of using the default SolMinter.
      </div>
    </div>
  );
}

// ===== src/components/token/token-list.tsx =====

'use client';

import { MintedTokenInfo } from '@/types/token';
import TokenCard from './token-card';

interface TokenListProps {
  tokens: MintedTokenInfo[];
}

export default function TokenList({ tokens }: TokenListProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
      {tokens.map((token) => (
        <TokenCard key={token.mintAddress} token={token} />
      ))}
    </div>
  );
}

// ===== src/components/token/token-error-state.tsx =====

'use client';

import Link from 'next/link';

interface TokenErrorStateProps {
  message: string;
  onRetry?: () => void;
}

export default function TokenErrorState({ message, onRetry }: TokenErrorStateProps) {
  return (
    <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-red-800 max-w-2xl mx-auto">
      <div className="text-center mb-6">
        <div className="w-20 h-20 bg-red-500 bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
          <svg className="w-10 h-10 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-2">Something Went Wrong</h2>
        <p className="text-gray-400 mb-6">
          {message || "We couldn't load your token information. Please try again later."}
        </p>
        
        <div className="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
          {onRetry && (
            <button 
              onClick={onRetry}
              className="bg-red-700 hover:bg-red-600 text-white font-medium py-2 px-6 rounded-full transition-colors"
            >
              Try Again
            </button>
          )}
          
          <Link 
            href="/create-token"
            className="bg-purple-700 hover:bg-purple-600 text-white font-medium py-2 px-6 rounded-full transition-colors"
          >
            Create New Token
          </Link>
          
          <Link 
            href="/"
            className="bg-transparent border border-gray-600 text-gray-300 hover:border-gray-400 hover:text-white font-medium py-2 px-6 rounded-full transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-authorities.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import { checkUpdateAuthorityStatus } from '@/utils/update-authority-utils';

interface TokenFormAuthoritiesProps {
  formData: {
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
}

export default function TokenFormAuthorities({
  formData,
  setFormData
}: TokenFormAuthoritiesProps) {
  const [updateAuthorityWarning, setUpdateAuthorityWarning] = useState<string>("");
  const [isCheckingConfig, setIsCheckingConfig] = useState<boolean>(false);

  // Check update authority configuration on initial load and when toggled
  useEffect(() => {
    async function checkConfig() {
      if (formData.revokeUpdate) {
        setIsCheckingConfig(true);
        await checkUpdateAuthorityStatus(
          formData.revokeUpdate, 
          (message) => setUpdateAuthorityWarning(message)
        );
        setIsCheckingConfig(false);
      } else {
        setUpdateAuthorityWarning("");
      }
    }
    
    checkConfig();
  }, [formData.revokeUpdate]);

  // Handle checkbox click with proper event simulation
  const handleCheckboxClick = (field: 'revokeMint' | 'revokeFreeze' | 'revokeUpdate') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev,
      [field]: !prev[field]
    }));
    
    // Find the related hidden checkbox and simulate a change event
    const checkbox = document.getElementById(field) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[field];
      // Create a proper change event
      const event = new Event('change', { bubbles: true });
      
      // Add properties to the event object using Object.defineProperty
      Object.defineProperty(event, 'target', {
        writable: false,
        value: {
          name: field,
          type: 'checkbox',
          checked: !formData[field]
        }
      });
      
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Revoke Authorities (Investor's Booster)</div>
      
      <div className="form-section-authorities space-y-4">
        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Freeze</div>
              <input 
                id="revokeFreeze" 
                type="checkbox" 
                name="revokeFreeze"
                checked={formData.revokeFreeze}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeFreeze: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeFreeze ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeFreeze')}
              >
                {formData.revokeFreeze && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to freeze holders' token accounts anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Mint</div>
              <input 
                id="revokeMint" 
                type="checkbox" 
                name="revokeMint"
                checked={formData.revokeMint}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeMint: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeMint ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeMint')}
              >
                {formData.revokeMint && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to create more tokens anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Update</div>
              <input 
                id="revokeUpdate" 
                type="checkbox" 
                name="revokeUpdate"
                checked={formData.revokeUpdate}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeUpdate: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeUpdate ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeUpdate')}
              >
                {formData.revokeUpdate && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to modify token metadata anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
          
          {/* Display warning if there's an issue with update authority configuration */}
          {updateAuthorityWarning && (
            <div className="mt-2 text-xs text-amber-500 bg-amber-950/40 p-2 rounded">
              <div className="flex items-center">
                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                {updateAuthorityWarning}
              </div>
            </div>
          )}
          
          {/* Show loading spinner when checking server configuration */}
          {isCheckingConfig && (
            <div className="mt-2 text-xs text-blue-500 flex items-center">
              <svg className="animate-spin h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Checking server configuration...
            </div>
          )}
        </div>
      </div>
      
      <div className="form-section-description text-xs text-gray-500 mt-4">
        Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.
      </div>
    </div>
  );
}

// ===== src/components/token/token-skeleton.tsx =====

'use client';

export default function TokenSkeleton() {
  return (
    <div className="bg-[#171717] rounded-xl overflow-hidden shadow-lg border border-gray-800 animate-pulse">
      {/* Image Skeleton */}
      <div className="h-48 bg-gray-800 relative flex items-center justify-center">
        <div className="w-20 h-20 bg-gray-700 rounded-full"></div>
      </div>
      
      {/* Content Skeleton */}
      <div className="p-6">
        <div className="flex justify-between items-start mb-4">
          <div>
            <div className="h-6 bg-gray-700 rounded w-32 mb-2"></div>
            <div className="h-4 bg-gray-700 rounded w-16"></div>
          </div>
          <div className="h-6 bg-gray-700 rounded w-20"></div>
        </div>
        
        <div className="h-4 bg-gray-700 rounded w-full mb-2"></div>
        <div className="h-4 bg-gray-700 rounded w-3/4 mb-4"></div>
        
        <div className="mb-4">
          <div className="h-3 bg-gray-700 rounded w-24 mb-2"></div>
          <div className="h-8 bg-gray-700 rounded w-full"></div>
        </div>
        
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div>
            <div className="h-3 bg-gray-700 rounded w-20 mb-2"></div>
            <div className="h-5 bg-gray-700 rounded w-24"></div>
          </div>
          
          <div>
            <div className="h-3 bg-gray-700 rounded w-32 mb-2"></div>
            <div className="h-5 bg-gray-700 rounded w-28"></div>
          </div>
        </div>
        
        <div className="flex space-x-3 mb-4">
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
          <div className="h-5 w-5 bg-gray-700 rounded-full"></div>
        </div>
        
        <div className="flex justify-between space-x-2 mt-6">
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
          <div className="flex-1 h-10 bg-gray-700 rounded-full"></div>
        </div>
      </div>
    </div>
  );
}

export function TokenSkeletonList() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
      <TokenSkeleton />
      <TokenSkeleton />
      <TokenSkeleton />
    </div>
  );
}

// ===== src/components/token/social-links-form.tsx =====

'use client';

import React from 'react';

interface SocialLinksFormProps {
  formData: {
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SocialLinksForm({ formData, handleInputChange }: SocialLinksFormProps) {
  return (
    <div className="social-links-form bg-[#1e1e1e] rounded-lg p-4 mt-4">
      <h3 className="text-white text-lg mb-4">Social Links</h3>
      
      <div className="space-y-4">
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Website URL</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
              </svg>
            </span>
            <input 
              placeholder="https://your-website.com" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="website"
              value={formData.website}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Twitter</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://x.com/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="twitter"
              value={formData.twitter}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Telegram</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
            </span>
            <input 
              placeholder="https://t.me/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="telegram"
              value={formData.telegram}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Discord</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://discord.gg/yourinvite" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="discord"
              value={formData.discord}
              onChange={handleInputChange}
            />
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Adding social links helps your community find and connect with your project. All fields are optional.
      </div>
    </div>
  );
}

// ===== src/components/token/token-card.tsx =====

'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';
import { MintedTokenInfo } from '@/types/token';
import { SOLANA_NETWORK } from '@/config';
import { formatNumberWithCommas } from '@/utils/token-utils';
import TokenDetailView from './token-detail-view';

interface TokenCardProps {
  token: MintedTokenInfo;
}

export default function TokenCard({ token }: TokenCardProps) {
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [showDetailView, setShowDetailView] = useState(false);

  const networkParam = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const explorerUrl = `https://explorer.solana.com/address/${token.mintAddress}${networkParam}`;
  const raydiumLiquidityUrl = `https://raydium.io/liquidity/create-pool${networkParam.replace('?', '#')}`;
  const raydiumSwapUrl = `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${token.mintAddress}${networkParam.replace('?', '&')}`;

  // Determine the image URL - might be in imageUrl or image property
  const actualImageUrl = token.imageUrl || token.image || '';

  useEffect(() => {
    // Reset image states when token changes
    setImageLoaded(false);
    setImageError(false);
    
    // Preload the image to check if it's valid
    if (actualImageUrl) {
      const img = new Image();
      img.onload = () => setImageLoaded(true);
      img.onerror = () => setImageError(true);
      img.src = actualImageUrl;
    } else {
      setImageError(true);
    }
  }, [token, actualImageUrl]);

  const handleImageLoad = () => {
    setImageLoaded(true);
  };

  const handleImageError = () => {
    setImageError(true);
  };

  const openDetailView = () => {
    setShowDetailView(true);
  };

  const closeDetailView = () => {
    setShowDetailView(false);
  };

  return (
    <>
      <div 
        className="bg-[#171717] rounded-xl overflow-hidden shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all cursor-pointer"
        onClick={openDetailView}
      >
        {/* Token Image Header */}
        <div className="h-48 bg-gradient-to-r from-purple-900/20 to-blue-900/20 relative flex items-center justify-center">
          {!imageLoaded && !imageError && (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="w-12 h-12 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin"></div>
            </div>
          )}
          
          {!imageError ? (
            <img 
              src={actualImageUrl} 
              alt={`${token.name} logo`}
              className={`object-contain max-h-40 mx-auto ${imageLoaded ? 'opacity-100' : 'opacity-0'}`}
              style={{ transition: 'opacity 0.3s ease-in-out' }}
              onLoad={handleImageLoad}
              onError={handleImageError}
            />
          ) : (
            <div className="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center">
              <span className="text-2xl font-bold text-gray-600">{token.symbol.substring(0, 2)}</span>
            </div>
          )}
        </div>
        
        {/* Token Info */}
        <div className="p-6">
          <div className="flex justify-between items-start mb-4">
            <div>
              <h3 className="text-xl font-bold text-white">{token.name}</h3>
              <p className="text-purple-400 font-mono">{token.symbol}</p>
            </div>
            <span className="bg-purple-900/30 text-purple-300 text-xs px-2 py-1 rounded-full">
              {token.tokenInfo?.decimals || 9} decimals
            </span>
          </div>
          
          <p className="text-gray-400 text-sm mb-4 line-clamp-2">
            {token.description || 'No description provided'}
          </p>
          
          <div className="mb-4">
            <div className="text-gray-500 text-xs mb-1">Token Address</div>
            <div className="font-mono text-xs bg-[#222] p-2 rounded overflow-hidden text-ellipsis">
              {token.mintAddress}
            </div>
          </div>
          
          <div className="grid grid-cols-2 gap-4 mb-4">
            <div>
              <div className="text-gray-500 text-xs">Total Supply</div>
              <div className="text-white font-medium">
                {formatNumberWithCommas(token.tokenInfo?.totalSupply || 0)}
              </div>
            </div>
            
            <div>
              <div className="text-gray-500 text-xs">Revoked Authorities</div>
              <div className="flex space-x-1">
                {token.authorities?.mintRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Mint</span>
                )}
                {token.authorities?.freezeRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Freeze</span>
                )}
                {token.authorities?.updateRevoked && (
                  <span className="text-xs px-1 bg-green-900/30 text-green-300 rounded">Update</span>
                )}
              </div>
            </div>
          </div>

          {/* Social Links (if available) */}
          {(token.website || token.twitter || token.telegram || token.discord) && (
            <div className="flex space-x-3 mb-4">
              {token.website && (
                <a 
                  href={token.website} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-purple-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                  </svg>
                </a>
              )}
              
              {token.twitter && (
                <a 
                  href={token.twitter} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-blue-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                  </svg>
                </a>
              )}
              
              {token.telegram && (
                <a 
                  href={token.telegram} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-blue-500"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                  </svg>
                </a>
              )}
              
              {token.discord && (
                <a 
                  href={token.discord} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-gray-400 hover:text-indigo-400"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                  </svg>
                </a>
              )}
            </div>
          )}
          
          {/* Action Links */}
          <div className="flex justify-between space-x-2 mt-6">
            <a 
              href={explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-purple-500 text-purple-500 hover:bg-purple-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Explorer
            </a>
            
            <a 
              href={raydiumLiquidityUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-blue-500 text-blue-500 hover:bg-blue-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Create Pool
            </a>
            
            <a 
              href={raydiumSwapUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="flex-1 text-center bg-transparent border border-green-500 text-green-500 hover:bg-green-500 hover:text-white text-sm font-medium py-2 px-3 rounded-full transition-colors"
              onClick={(e) => e.stopPropagation()}
            >
              Swap
            </a>
          </div>
        </div>
      </div>

      {/* Detail Modal */}
      {showDetailView && (
        <TokenDetailView 
          token={token} 
          onClose={closeDetailView} 
        />
      )}
    </>
  );
}

// ===== src/components/token/token-form-basic.tsx =====

'use client';

import React, { useRef } from 'react';

interface TokenFormBasicProps {
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  formSubmitted?: boolean; // New prop to track if form was submitted
}

export default function TokenFormBasic({
  formData,
  handleInputChange,
  handleFileChange,
  formSubmitted = false // Default to false
}: TokenFormBasicProps) {
  // Create a ref for the file input
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Function to trigger file input click
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Name *</label>
        <input 
          placeholder="Ex: Moon Coin" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Max 32 characters in your name</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Symbol *</label>
        <input 
          placeholder="Ex: MOON" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="symbol"
          value={formData.symbol}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Decimals *</label>
        <input 
          placeholder="Ex: 9" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="decimals"
          value={formData.decimals}
          onChange={handleInputChange}
          min="0"
          max="18"
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Change the number of decimals for your token</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Supply *</label>
        <input 
          placeholder="Ex: 1000000000" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="supply"
          value={formData.supply}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">The initial number of available tokens that will be created in your wallet</span>
      </div>

      <div className="logo-wrapper grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
        <div className="logo-box">
          <span className="label-text block text-gray-300 mb-2">Logo *</span>
          <div 
            className="img-input-wrapper border-2 border-dashed border-gray-700 rounded-lg p-6 text-center cursor-pointer hover:border-purple-500 transition-colors" 
            onClick={triggerFileInput}
          >
            <span className="material-symbols-rounded text-3xl mb-2 text-gray-400 block">upload</span>
            <span className="text-1 block text-gray-300 mb-1">Drag and drop here to upload</span>
            <div className="text-2 text-xs text-gray-500">.png, .jpg 1000x1000 px</div>
            <input 
              ref={fileInputRef}
              accept=".png, .jpg, .jpeg" 
              className="form-img hidden" 
              type="file"
              onChange={handleFileChange}
              // Remove required from hidden input
            />
          </div>
          <span className="field-constraint text-xs text-gray-500 mt-1 block">Add logo for your token</span>
          {formSubmitted && !formData.logo && (
            <span className="text-red-400 text-xs mt-1 block">
              Logo image is required
            </span>
          )}
        </div>
        
        <div className="logo-preview flex items-center justify-center">
          {formData.logo ? (
            <img 
              src={URL.createObjectURL(formData.logo)} 
              alt="Token Logo Preview" 
              className="max-h-40 rounded-lg border border-gray-700"
            />
          ) : (
            <div className="text-gray-500 text-sm">Logo preview will appear here</div>
          )}
        </div>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Description *</label>
        <textarea 
          placeholder="Here you can describe your token" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white h-24" 
          name="description"
          value={formData.description}
          onChange={handleInputChange}
          required
        />
      </div>
    </div>
  );
}

// ===== src/components/token/no-tokens-found.tsx =====

'use client';

import Link from 'next/link';

interface NoTokensFoundProps {
  isStillSearching?: boolean;
}

export default function NoTokensFound({ isStillSearching = false }: NoTokensFoundProps) {
  return (
    <div className="min-h-screen bg-[#0a0a0a] flex items-center justify-center">
      <div className="max-w-3xl w-full mx-auto p-10 bg-[#171717] rounded-xl text-center">
        <div className="w-20 h-20 bg-purple-900/20 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg className="w-10 h-10 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-4">No Tokens Found</h2>
        <p className="text-gray-400 mb-8">
          {isStillSearching 
            ? "We haven't found any tokens in our initial search. We're still looking deeper in our database."
            : "You haven't created any tokens with SolMinter yet. Get started by creating your first token!"}
        </p>
        
        <Link 
          href="/create-token" 
          className="inline-block bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all"
        >
          Create Your First Token
        </Link>
      </div>
    </div>
  );
}

// ===== src/components/ui/copy-button.tsx =====

'use client';

import { useState } from 'react';

interface CopyButtonProps {
  textToCopy: string;
  className?: string;
}

export default function CopyButton({ textToCopy, className = '' }: CopyButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(textToCopy);
      setCopied(true);
      
      // Reset the copied state after 2 seconds
      setTimeout(() => {
        setCopied(false);
      }, 2000);
      
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  };

  return (
    <div className="relative inline-flex items-center">
      <button 
        onClick={handleCopy} 
        className={`copy-button flex items-center justify-center p-2 ${className}`}
        title="Copy to clipboard"
        style={{ width: '30px', height: '30px' }} // Fixed dimensions for better hitbox
      >
        <svg 
          className="w-5 h-5" 
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24" 
          xmlns="http://www.w3.org/2000/svg"
          style={{ pointerEvents: 'none' }} // Prevent SVG from intercepting clicks
        >
          {copied ? (
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth="2" 
              d="M5 13l4 4L19 7"
              style={{ pointerEvents: 'none' }}
            />
          ) : (
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth="2" 
              d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"
              style={{ pointerEvents: 'none' }}
            />
          )}
        </svg>
      </button>
      <div className={`copy-success ${copied ? 'show' : ''}`}>
        Copied!
      </div>
    </div>
  );
}

// ===== src/components/ui/loading.tsx =====

// src/components/ui/loading.tsx

"use client";

import React, { useState, useEffect } from "react";
import { cleanupSessionFiles } from "@/services/pinata-cleanup";
import "@/styles/loading.css";

interface LoadingProps {
  message?: string;
  steps?: string[];
  /** If provided, controls which step is active; disables auto-advance */
  currentStepIndex?: number;
  /** Optional cancel handler */
  onCancel?: () => void;
}

export default function Loading({
  message = "Loading...",
  steps = [],
  currentStepIndex,
  onCancel,
}: LoadingProps) {
  const stepIndex = currentStepIndex != null ? currentStepIndex : 0;
  const [isCancelling, setIsCancelling] = useState(false);

  // Force scroll to top when the component mounts and whenever the step changes
  useEffect(() => {
    window.scrollTo(0, 0);
    document.body.scrollTop = 0; // For Safari
  }, []);
  
  // Separate effect for step changes to avoid flashing
  useEffect(() => {
    window.scrollTo(0, 0);
    document.body.scrollTop = 0; // For Safari
  }, [currentStepIndex]);

  // Handle cancel button click
  const handleCancel = async () => {
    if (isCancelling) return;
    setIsCancelling(true);

    console.log("Cancellation initiated by user. Cleaning up resources...");
    
    // Clean up Pinata files
    await cleanupSessionFiles();

    // Call the parent's onCancel handler if provided
    if (onCancel) {
      onCancel();
    }
  };

  // Determine if we should show wallet notification based on step
  const showWalletNotification = () => {
    // For client-side flow (revoke update off), wallet appears during step 5 ("Almost done...")
    // For server-side flow (revoke update on), wallet appears during step 3 ("Processing on blockchain...")
    return stepIndex === 3 || stepIndex === 5;
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-[70vh] p-8 max-w-md mx-auto">
      <div className="relative mb-8">
        {/* New wave loader */}
        <div className="wave-loader"></div>
      </div>

      <div className="w-full mb-8">
        <div className="mt-2 text-gray-400 text-sm text-center">
          {steps[stepIndex]}
          {showWalletNotification() && (
            <div className="text-xs text-yellow-400 mt-1 wallet-notification">
              Please approve the transaction in your wallet
            </div>
          )}
        </div>
      </div>

      {/* Cancel button */}
      <button
        onClick={handleCancel}
        disabled={isCancelling}
        className="px-6 py-2 rounded-full bg-transparent border border-gray-600 text-gray-300 hover:border-red-500 hover:text-red-400 transition-colors"
      >
        {isCancelling ? "Cancelling..." : "Cancel"}
      </button>
    </div>
  );
}

// ===== src/components/ui/checkmark-animation.tsx =====

'use client';

import { useEffect, useRef } from 'react';
import '../../styles/checkmark.css';

export default function CheckmarkAnimation() {
  const animationRef = useRef<HTMLDivElement>(null);
  
  // Ensure the animation restarts when component mounts
  useEffect(() => {
    if (animationRef.current) {
      const checkmark = animationRef.current.querySelector('.checkmark') as HTMLElement;
      
      if (checkmark) {
        // Reset animations
        checkmark.style.animation = 'none';
        
        // Force reflow
        void checkmark.offsetWidth;
        
        // Restart animations
        checkmark.style.animation = '';
        
        // SVG elements need a different approach for animation reset
        const svgElements = animationRef.current.querySelectorAll('circle, path');
        svgElements.forEach(el => {
          // Remove and re-add the element to force animation restart
          const parent = el.parentNode;
          if (parent) {
            const clone = el.cloneNode(true);
            parent.removeChild(el);
            setTimeout(() => parent.appendChild(clone), 0);
          }
        });
      }
    }
  }, []);

  return (
    <div className="checkmark-container">
      <div className="success-checkmark" ref={animationRef}>
        <svg 
          className="checkmark" 
          xmlns="http://www.w3.org/2000/svg" 
          viewBox="0 0 52 52"
        >
          <circle 
            className="checkmark__circle" 
            cx="26" 
            cy="26" 
            r="25" 
            fill="none"
          />
          <path 
            className="checkmark__check" 
            fill="none" 
            d="M14.1 27.2l7.1 7.2 16.7-16.8"
          />
        </svg>
      </div>
    </div>
  );
}

// ===== src/components/home/hero-section.tsx =====

'use client';
import { useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';

export default function HeroSection() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    // Enhanced particle background effect
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let particles: { x: number; y: number; vx: number; vy: number; size: number; color: string }[] = [];
    
    const createParticles = () => {
      particles = Array.from({ length: 120 }).map(() => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 3 + 1,
        color: `rgba(${Math.floor(Math.random() * 100 + 100)}, ${Math.floor(Math.random() * 50 + 50)}, ${Math.floor(Math.random() * 200 + 55)}, ${Math.random() * 0.2 + 0.1})`
      }));
    };
    
    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      createParticles();
    };
    
    resize();
    window.addEventListener('resize', resize);

    const animate = () => {
      if (!ctx) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        
        // Boundary check with smoother transition
        if (p.x < 0) p.x = canvas.width;
        if (p.x > canvas.width) p.x = 0;
        if (p.y < 0) p.y = canvas.height;
        if (p.y > canvas.height) p.y = 0;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
      });
      
      requestAnimationFrame(animate);
    };
    
    animate();
    return () => window.removeEventListener('resize', resize);
  }, []);

  return (
    <section className="relative min-h-screen flex items-center justify-center overflow-hidden pt-16">
      <canvas ref={canvasRef} className="absolute inset-0" />
      
      <motion.div
        initial={{ y: 50, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{ duration: 0.7, ease: "easeOut" }}
        className="relative text-center px-4 pt-10 md:pt-0 z-10"
      >
        <motion.h1 
          className="text-5xl md:text-6xl lg:text-7xl font-bold bg-gradient-to-r from-purple-500 via-purple-400 to-blue-500 bg-clip-text text-transparent"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ delay: 0.2, duration: 0.8 }}
        >
          Create Solana Tokens In Seconds
        </motion.h1>
        
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.5, duration: 0.8 }}
          className="mt-6 text-gray-300 text-lg md:text-xl max-w-2xl mx-auto"
        >
          The easiest way to mint, launch, and manage tokens on the Solana blockchain.
          No coding required.
        </motion.p>
        
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.7, duration: 0.5 }}
          className="mt-10 flex flex-col sm:flex-row justify-center gap-4"
        >
          <Link
            href="/create-token"
            className="bg-gradient-to-r from-purple-600 to-blue-500 py-4 px-8 rounded-full text-white font-medium hover:shadow-lg hover:shadow-purple-500/20 transition-all"
          >
            Create Your Token
          </Link>
          <Link
            href="/guides"
            className="border border-purple-500 py-4 px-8 rounded-full text-purple-400 font-medium hover:bg-purple-500/10 transition-all"
          >
            Learn How It Works
          </Link>
        </motion.div>
        
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 1, duration: 0.8 }}
          className="mt-8 text-gray-500 text-sm"
        >
          Trusted by hundreds of token creators on Solana
        </motion.div>
      </motion.div>
    </section>
  );
}

// ===== src/components/home/how-it-works-section.tsx =====

'use client';
import { motion } from 'framer-motion';
import Image from 'next/image';

const steps = [
  { 
    number: 1, 
    title: 'Connect Your Wallet', 
    description: 'Connect your Solana wallet to get started with the token creation process.',
    icon: (
      <svg className="w-6 h-6 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>
    )
  },
  { 
    number: 2, 
    title: 'Customize Your Token', 
    description: 'Set name, symbol, supply, and upload a logo. Configure token authorities and social links.',
    icon: (
      <svg className="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
      </svg>
    )
  },
  { 
    number: 3, 
    title: 'Launch & Manage', 
    description: 'Confirm transaction in your wallet and access tools to create liquidity and promote your token.',
    icon: (
      <svg className="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
      </svg>
    )
  },
];

export default function HowItWorksSection() {
  return (
    <section className="py-24 bg-[#0c0c0c] relative">
      {/* Decorative elements */}
      <div className="absolute inset-0 overflow-hidden">
        <div className="absolute right-0 top-0 w-64 h-64 bg-purple-900/5 rounded-full blur-3xl"></div>
        <div className="absolute left-0 bottom-0 w-64 h-64 bg-blue-900/5 rounded-full blur-3xl"></div>
      </div>
      
      <div className="max-w-6xl mx-auto px-4 relative z-10">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.7 }}
          className="text-center mb-16"
        >
          <h2 className="text-4xl font-bold text-white mb-4">How It Works</h2>
          <p className="text-gray-400 max-w-2xl mx-auto">
            Creating your own Solana token is simple and straightforward with our easy-to-use platform
          </p>
        </motion.div>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 relative">
          {/* Connecting line between steps */}
          <div className="hidden md:block absolute top-1/2 left-0 right-0 h-0.5 bg-gradient-to-r from-purple-600/20 via-blue-500/20 to-purple-600/20 transform -translate-y-1/2 z-0"></div>
          
          {steps.map((step, index) => (
            <motion.div
              key={step.number}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ duration: 0.5, delay: index * 0.2 }}
              className="bg-[#171717] p-8 rounded-2xl shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all relative z-10"
            >
              <div className="absolute -top-5 left-1/2 transform -translate-x-1/2 w-10 h-10 rounded-full bg-gradient-to-r from-purple-600 to-blue-500 flex items-center justify-center text-white font-bold">
                {step.number}
              </div>
              
              <div className="bg-[#222] p-4 rounded-xl mb-6 mt-4 inline-block">
                {step.icon}
              </div>
              
              <h3 className="text-xl font-semibold text-white mb-3">{step.title}</h3>
              <p className="text-gray-400">{step.description}</p>
              
              {index < steps.length - 1 && (
                <div className="md:hidden mt-8 mb-2 text-center text-purple-500">
                  <svg className="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                  </svg>
                </div>
              )}
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  );
}

// ===== src/components/home/features-section.tsx =====

"use client";
import { motion } from "framer-motion";

const features = [
  {
    title: "Easy Token Creation",
    description: "Create Solana tokens in just minutes without any coding knowledge. Our simple form guides you through the entire process.",
    icon: (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        className="w-10 h-10 text-purple-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth="1.5"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
        />
      </svg>
    ),
  },
  {
    title: "Revocable Authorities",
    description: "Increase investor trust by revoking mint, freeze, and update authorities. Full control over your token's security features.",
    icon: (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        className="w-10 h-10 text-blue-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth="1.5"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
        />
      </svg>
    ),
  },
  {
    title: "Social Integration",
    description: "Add your social media links and custom creator information directly to your token's metadata for better community building.",
    icon: (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        className="w-10 h-10 text-green-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth="1.5"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
        />
      </svg>
    ),
  },
  {
    title: "Liquidity Management",
    description: "Direct integrations with Raydium DEX for creating liquidity pools and managing your token's marketplace presence.",
    icon: (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        className="w-10 h-10 text-yellow-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth="1.5"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M13 10V3L4 14h7v7l9-11h-7z"
        />
      </svg>
    ),
  },
];

export default function FeaturesSection() {
  return (
    <section className="py-24 bg-[#0a0a0a] relative overflow-hidden">
      {/* Background elements */}
      <div className="absolute inset-0 overflow-hidden">
        <div className="absolute -left-64 top-20 w-96 h-96 bg-purple-900/10 rounded-full blur-3xl"></div>
        <div className="absolute right-0 bottom-0 w-80 h-80 bg-blue-900/10 rounded-full blur-3xl"></div>
      </div>
      
      <div className="max-w-7xl mx-auto px-4 text-center relative z-10">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.7 }}
          className="mb-16"
        >
          <h2 className="text-4xl font-bold text-white mb-4">
            Why Choose <span className="text-purple-500">SolMinter</span>?
          </h2>
          <p className="text-gray-400 max-w-2xl mx-auto">
            Our platform provides everything you need to launch your Solana token project with confidence and security.
          </p>
        </motion.div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
          {features.map((feature, index) => (
            <motion.div
              key={feature.title}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ 
                duration: 0.5,
                delay: index * 0.1
              }}
              whileHover={{ y: -8, transition: { duration: 0.2 } }}
              className="bg-[#171717] p-8 rounded-2xl shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all h-full flex flex-col"
            >
              <div className="mb-6 flex justify-center bg-opacity-20 bg-gradient-to-br from-purple-500/10 to-blue-500/10 p-4 rounded-full w-20 h-20 mx-auto">
                {feature.icon}
              </div>
              <h3 className="text-xl font-semibold text-white mb-3">
                {feature.title}
              </h3>
              <p className="text-gray-400 flex-grow">
                {feature.description}
              </p>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  );
}

// ===== src/components/home/token-count-section.tsx =====

'use client';
import { motion } from 'framer-motion';
import { useEffect, useState } from 'react';

export default function TokenCountSection() {
  const [count, setCount] = useState(0);
  
  // Simulate a count-up animation for demonstration
  useEffect(() => {
    const targetCount = 1250; // Example number of tokens created
    const duration = 2000; // 2 seconds
    const step = targetCount / (duration / 16); // 60fps
    let current = 0;
    
    const timer = setInterval(() => {
      current += step;
      if (current >= targetCount) {
        setCount(targetCount);
        clearInterval(timer);
      } else {
        setCount(Math.floor(current));
      }
    }, 16);
    
    return () => clearInterval(timer);
  }, []);

  return (
    <section className="py-16 bg-[#0a0a0a]">
      <div className="max-w-5xl mx-auto px-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.7 }}
          className="bg-[#171717] rounded-2xl p-8 shadow-lg border border-gray-800 text-center"
        >
          <h2 className="text-2xl font-semibold text-white mb-2">Trusted by Solana Creators</h2>
          <p className="text-gray-400 mb-8">Join our growing community of token creators</p>
          
          <div className="flex flex-col md:flex-row justify-center items-center gap-8">
            <div className="flex-1">
              <div className="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-500 to-blue-500">
                {count.toLocaleString()}+
              </div>
              <div className="text-gray-400 mt-2">Tokens Created</div>
            </div>
            
            <div className="h-16 w-px bg-gray-800 hidden md:block"></div>
            
            <div className="flex-1">
              <div className="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-500 to-blue-500">
                100%
              </div>
              <div className="text-gray-400 mt-2">Client Satisfaction</div>
            </div>
            
            <div className="h-16 w-px bg-gray-800 hidden md:block"></div>
            
            <div className="flex-1">
              <div className="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-500 to-blue-500">
                Easy
              </div>
              <div className="text-gray-400 mt-2">Token Creation</div>
            </div>
          </div>
        </motion.div>
      </div>
    </section>
  );
}

// ===== src/components/home/cta-section.tsx =====

'use client';
import { motion } from 'framer-motion';
import Link from 'next/link';
import { useEffect, useRef } from 'react';

export default function CTASection() {
  const particlesRef = useRef<HTMLDivElement>(null);
  
  // Create animated particles when component mounts
  useEffect(() => {
    if (!particlesRef.current) return;
    
    // Clear any existing particles
    while (particlesRef.current.firstChild) {
      particlesRef.current.removeChild(particlesRef.current.firstChild);
    }
    
    // Create new particles
    for (let i = 0; i < 20; i++) {
      const particle = document.createElement('div');
      
      // Random styles for each particle
      const size = Math.random() * 20 + 5;
      particle.style.position = 'absolute';
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      particle.style.top = `${Math.random() * 100}%`;
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.borderRadius = '50%';
      particle.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
      particle.style.opacity = `${Math.random() * 0.5}`;
      
      // Animation
      particle.style.animation = `float-particle ${Math.random() * 10 + 10}s linear infinite`;
      particle.style.animationDelay = `${Math.random() * 5}s`;
      
      particlesRef.current.appendChild(particle);
    }
    
    // Add the animation keyframes to the document if they don't exist
    if (!document.getElementById('particle-animation-keyframes')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'particle-animation-keyframes';
      styleElement.textContent = `
        @keyframes float-particle {
          0% {
            transform: translateY(0) translateX(0);
          }
          25% {
            transform: translateY(-20px) translateX(10px);
          }
          50% {
            transform: translateY(-10px) translateX(20px);
          }
          75% {
            transform: translateY(10px) translateX(5px);
          }
          100% {
            transform: translateY(0) translateX(0);
          }
        }
      `;
      document.head.appendChild(styleElement);
    }
  }, []);

  return (
    <section className="py-20 bg-gradient-to-r from-purple-900/90 to-blue-900/90 relative overflow-hidden">
      {/* Background particle effect */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div ref={particlesRef} className="absolute top-0 left-0 w-full h-full">
          {/* Particles will be dynamically added here */}
        </div>
      </div>
      
      <motion.div
        initial={{ scale: 0.9, opacity: 0 }}
        whileInView={{ scale: 1, opacity: 1 }}
        viewport={{ once: true }}
        transition={{ duration: 0.6 }}
        className="max-w-4xl mx-auto text-center px-4 relative z-10"
      >
        <motion.h2 
          className="text-4xl sm:text-5xl font-bold text-white mb-6"
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.2 }}
        >
          Ready to Launch Your Token?
        </motion.h2>
        
        <motion.p 
          className="text-gray-200 text-lg mb-10 max-w-2xl mx-auto"
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.3 }}
        >
          Join hundreds of creators who have already launched their tokens on Solana using SolMinter. 
          Start building your project today with just a few clicks.
        </motion.p>
        
        <motion.div
          className="flex flex-col sm:flex-row gap-4 justify-center"
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.4 }}
        >
          <Link
            href="/create-token"
            className="bg-white text-purple-900 font-semibold py-4 px-8 rounded-full hover:shadow-xl hover:bg-gray-100 transition-all"
          >
            Create Token Now
          </Link>
          
          <Link
            href="/my-tokens"
            className="bg-transparent text-white border border-white font-semibold py-4 px-8 rounded-full hover:bg-white/10 transition-all"
          >
            View My Tokens
          </Link>
        </motion.div>
        
        <motion.div
          className="mt-10 text-sm text-white/60"
          initial={{ opacity: 0 }}
          whileInView={{ opacity: 1 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.6 }}
        >
          Need help? Check out our <Link href="/guides" className="text-white underline hover:text-purple-300">guides and resources</Link>.
        </motion.div>
      </motion.div>
    </section>
  );
}

// ===== src/components/layout/navbar.tsx =====

// src/components/layout/navbar.tsx

"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { usePathname } from "next/navigation";
import WalletButton from "../wallet/wallet-button";

export default function Navbar() {
  const [scrolled, setScrolled] = useState(false);
  const pathname = usePathname();
  const isCreateTokenPage = pathname === "/create-token";

  // Track scroll position to add shadow and background when scrolled
  useEffect(() => {
    const handleScroll = () => {
      const isScrolled = window.scrollY > 10;
      if (isScrolled !== scrolled) {
        setScrolled(isScrolled);
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [scrolled]);

  // Function to handle direct navigation to create-token
  const handleCreateTokenClick = (e: React.MouseEvent) => {
    // Only force refresh if we're already on the create-token page
    if (isCreateTokenPage) {
      e.preventDefault();
      window.location.href = "/create-token";
    }
  };

  return (
    <div
      className={`fixed top-4 left-0 right-0 z-50 transition-all duration-300 ${
        scrolled ? "top-2" : "top-4"
      }`}
    >
      <div className="max-w-6xl mx-auto px-4">
        <div
          className={`nav-container rounded-full py-3 px-6 transition-all duration-300 ${
            scrolled
              ? "bg-black/50 backdrop-blur-md shadow-lg shadow-black/20"
              : "bg-transparent"
          }`}
        >
          <div className="flex justify-between items-center">
            <Link href="/" className="logo-container flex items-center">
              <div className="logo-img">
                <span className="text-2xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
                  SolMinter
                </span>
              </div>
            </Link>

            <nav className="main-nav hidden md:flex space-x-6">
              <Link
                href="/"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                Home
              </Link>
              <Link
                href="/create-token"
                className="nav-link text-gray-300 hover:text-white transition-colors"
                onClick={handleCreateTokenClick}
              >
                Create Token
              </Link>
              <Link
                href="/my-tokens"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                My Tokens
              </Link>
              <a
                href="https://raydium.io/liquidity/create-pool"
                className="nav-link text-gray-300 hover:text-white transition-colors"
                rel="noopener noreferrer"
                target="_blank"
              >
                Liquidity Pool
              </a>
              <a
                href="https://raydium.io/swap"
                className="nav-link text-gray-300 hover:text-white transition-colors"
                rel="noopener noreferrer"
                target="_blank"
              >
                Manage Liquidity
              </a>
              <Link
                href="/guides"
                className="nav-link text-gray-300 hover:text-white transition-colors"
              >
                Guides
              </Link>
            </nav>

            <div className="wallet-dropdown">
              <WalletButton />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


// ===== src/components/layout/footer.tsx =====

// src/components/layout/footer.tsx

'use client';

import Link from 'next/link';

export default function Footer() {
  const year = new Date().getFullYear();

  return (
    <div className="footer-container bg-[#111] border-t border-gray-800 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <Link href="/" className="logo-container mb-6 md:mb-0">
            <div className="logo-img">
              <span className="text-xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <div className="flex flex-col md:flex-row items-center gap-4 md:gap-0">
            <div className="links-container flex space-x-6 mb-4 md:mb-0 md:mr-8">
              <Link 
                href="/guides" 
                className="text-gray-400 hover:text-white text-sm transition-colors"
              >
                Guides
              </Link>
              <Link 
                href="/my-tokens" 
                className="text-gray-400 hover:text-white text-sm transition-colors"
              >
                My Tokens
              </Link>
              <a 
                href="https://raydium.io/swap" 
                target="_blank" 
                rel="noopener noreferrer" 
                className="text-gray-400 hover:text-white text-sm transition-colors"
              >
                Raydium
              </a>
            </div>
            
            <div className="legal-container flex items-center">
              <span className="text-gray-500 text-sm mr-4">© SolMinter {year}</span>
              <div className="flex items-center">
                <Link href="/terms" className="text-gray-400 hover:text-white text-sm transition-colors">
                  Terms
                </Link>
                <span className="text-gray-600 mx-2">|</span>
                <Link href="/privacy" className="text-gray-400 hover:text-white text-sm transition-colors">
                  Privacy
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/guides/guides-list.tsx =====

'use client';

import { motion } from 'framer-motion';
import GuideCard from './guide-card';
// Guide data
const guides = [
  {
    id: 'token-creation',
    title: 'How to Create a Solana Token',
    description: 'A step-by-step guide to create your own token on the Solana blockchain with SolMinter.',
    icon: (
      <svg className="w-10 h-10 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    ),
    steps: [
      {
        title: 'Connect Your Wallet',
        description: 'Click the "Connect Wallet" button in the top right corner and connect your Phantom, Solflare, or other compatible Solana wallet.',
      },
      {
        title: 'Fill in Token Details',
        description: 'Enter your token\'s name, symbol, supply, and other details. Upload a logo image (1000x1000px recommended) to give your token a unique identity.',
      },
      {
        title: 'Configure Token Options',
        description: 'Choose whether to include social links and creator information. Select which authorities to revoke (recommended for investor trust).',
      },
      {
        title: 'Launch Your Token',
        description: 'Review your token details, then click "Launch Token" and approve the transaction in your wallet. Your token will be created on the Solana blockchain.',
      },
      {
        title: 'Create Liquidity',
        description: 'After creating your token, set up a liquidity pool on Raydium or another Solana DEX to make your token tradable on the open market.',
      },
    ],
  },
  {
    id: 'token-authorities',
    title: 'Token Authorities Explained',
    description: 'Learn about the different types of authorities in Solana tokens and how they affect your token\'s security and credibility.',
    icon: (
      <svg className="w-10 h-10 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
      </svg>
    ),
    content: [
      {
        title: 'Mint Authority',
        description: 'Controls the ability to create (mint) new tokens. Revoking this authority creates a fixed supply token that cannot be inflated, building trust with your community.',
      },
      {
        title: 'Freeze Authority',
        description: 'Controls the ability to freeze token accounts, preventing transfers. Revoking this ensures no one can freeze holders\' tokens, increasing security for token holders.',
      },
      {
        title: 'Update Authority',
        description: 'Controls the ability to modify token metadata (name, symbol, image, etc.). Revoking makes the token\'s metadata immutable, preventing future changes.',
      },
    ],
    recommendation: 'For maximum credibility with your community, we recommend revoking all authorities.',
  },
  {
    id: 'liquidity-pools',
    title: 'Setting Up Liquidity Pools',
    description: 'Learn how to create liquidity pools for your newly minted token on Raydium DEX.',
    icon: (
      <svg className="w-10 h-10 text-green-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
        <path strokeLinecap="round" strokeLinejoin="round" d="M20 12a8 8 0 01-8 8v0a8 8 0 01-8-8v0a8 8 0 018-8v0a8 8 0 018 8v0z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M8 12h8m-4-4v8" />
      </svg>
    ),
    steps: [
      {
        title: 'Prepare Your Token',
        description: 'Make sure your token is created and you have the necessary token amount and SOL for creating the liquidity pool.',
      },
      {
        title: 'Visit Raydium Liquidity',
        description: 'Go to Raydium\'s liquidity pool creation page. You can find a direct link in your "My Tokens" section after token creation.',
      },
      {
        title: 'Select Token Pair',
        description: 'Choose your token and a pairing token (usually SOL or USDC) to create the liquidity pair.',
      },
      {
        title: 'Set Initial Price',
        description: 'Determine the initial price of your token by depositing the appropriate ratio of your token and the paired asset.',
      },
      {
        title: 'Create Pool',
        description: 'Review the details, confirm the transaction in your wallet, and your token will be available for trading.',
      },
    ],
  },
];

export default function GuidesList() {
  return (
    <div className="space-y-12 mb-16">
      <h2 className="text-2xl font-bold text-white mb-8">Step-by-Step Guides</h2>
      
      <div className="space-y-12">
        {guides.map((guide, index) => (
          <motion.div
            key={guide.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: index * 0.1 }}
          >
            <GuideCard guide={guide} />
          </motion.div>
        ))}
      </div>
    </div>
  );
}

// ===== src/components/guides/guide-card.tsx =====

'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface Step {
  title: string;
  description: string;
}

interface Content {
  title: string;
  description: string;
}

interface Guide {
  id: string;
  title: string;
  description: string;
  icon: React.ReactNode;
  steps?: Step[];
  content?: Content[];
  recommendation?: string;
}

interface GuideCardProps {
  guide: Guide;
}

export default function GuideCard({ guide }: GuideCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div className="bg-[#171717] rounded-xl p-6 shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all">
      <div 
        className="flex items-start cursor-pointer" 
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex-shrink-0 bg-opacity-20 bg-gradient-to-br from-purple-500/10 to-blue-500/10 p-3 rounded-lg mr-4">
          {guide.icon}
        </div>
        
        <div className="flex-grow">
          <h3 className="text-2xl font-semibold text-white mb-2">{guide.title}</h3>
          <p className="text-gray-400">{guide.description}</p>
        </div>
        
        <div className="flex-shrink-0 ml-4">
          <svg 
            className={`w-6 h-6 text-purple-500 transform transition-transform ${isExpanded ? 'rotate-180' : ''}`} 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
          </svg>
        </div>
      </div>
      
      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="overflow-hidden"
          >
            <div className="mt-6 pt-6 border-t border-gray-800">
              {guide.steps && (
                <ol className="list-decimal pl-5 space-y-4">
                  {guide.steps.map((step, index) => (
                    <li key={index}>
                      <div className="text-white font-semibold mb-1">{step.title}</div>
                      <p className="text-gray-400">{step.description}</p>
                    </li>
                  ))}
                </ol>
              )}
              
              {guide.content && (
                <ul className="space-y-4">
                  {guide.content.map((item, index) => (
                    <li key={index} className="bg-[#222] p-4 rounded-lg">
                      <div className="text-white font-semibold mb-1">{item.title}</div>
                      <p className="text-gray-400">{item.description}</p>
                    </li>
                  ))}
                </ul>
              )}
              
              {guide.recommendation && (
                <div className="mt-4 p-4 bg-purple-900/20 border border-purple-500/30 rounded-lg">
                  <p className="text-purple-300">{guide.recommendation}</p>
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

// ===== src/components/guides/guide-header.tsx =====

'use client';

import { motion } from 'framer-motion';

export default function GuideHeader() {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="text-center mb-16"
    >
      <h1 className="text-4xl md:text-5xl font-bold text-center mb-6">
        <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
          Guides & Resources
        </span>
      </h1>
      <p className="text-gray-400 text-lg max-w-3xl mx-auto">
        Learn how to create, launch, and manage your Solana tokens with our comprehensive guides and resources. 
        Follow the step-by-step instructions to bring your token project to life.
      </p>
    </motion.div>
  );
}

// ===== src/components/guides/resources-list.tsx =====

'use client';

import { motion } from 'framer-motion';
import Link from 'next/link';

const resources = [
  {
    id: 'solana-docs',
    title: 'Solana Documentation',
    description: 'Official documentation for the Solana blockchain.',
    icon: (
      <svg className="w-6 h-6 text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>
    ),
    url: 'https://docs.solana.com/',
  },
  {
    id: 'raydium-docs',
    title: 'Raydium DEX Guide',
    description: 'Learn how to use Raydium DEX to create liquidity pools.',
    icon: (
      <svg className="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" />
      </svg>
    ),
    url: 'https://raydium.gitbook.io/raydium/',
  },
  {
    id: 'token-marketing',
    title: 'Token Marketing Strategies',
    description: 'Learn effective marketing strategies for your new token.',
    icon: (
      <svg className="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z" />
      </svg>
    ),
    url: 'https://solana.com/developers',
  },
  {
    id: 'community-building',
    title: 'Building a Token Community',
    description: 'Guide to building and growing your token community.',
    icon: (
      <svg className="w-6 h-6 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
      </svg>
    ),
    url: 'https://solana.com/ecosystem',
  },
];

export default function ResourcesList() {
  return (
    <div>
      <h2 className="text-2xl font-bold text-white mb-8">External Resources</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {resources.map((resource, index) => (
          <motion.div
            key={resource.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: index * 0.1 }}
            className="h-full"
          >
            <Link 
              href={resource.url} 
              target="_blank" 
              rel="noopener noreferrer" 
              className="block bg-[#171717] rounded-xl p-4 shadow-lg border border-gray-800 hover:border-purple-500/30 transition-all h-full"
            >
              <div className="flex items-start h-full">
                <div className="flex-shrink-0 bg-opacity-20 bg-gradient-to-br from-purple-500/10 to-blue-500/10 p-3 rounded-lg mr-4">
                  {resource.icon}
                </div>
                
                <div className="flex-grow">
                  <h3 className="text-lg font-semibold text-white mb-1">{resource.title}</h3>
                  <p className="text-gray-400 text-sm">{resource.description}</p>
                </div>
                
                <div className="ml-3 flex-shrink-0">
                  <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                  </svg>
                </div>
              </div>
            </Link>
          </motion.div>
        ))}
      </div>
      
      <div className="mt-10 p-4 bg-[#171717] rounded-xl border border-gray-800">
        <p className="text-gray-400 text-center">
          Need more help? Join our <a href="https://discord.gg/solana" target="_blank" rel="noopener noreferrer" className="text-purple-500 hover:text-purple-400 underline">Discord community</a> for support and updates.
        </p>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-button.tsx =====

'use client';

import { useCallback, useEffect, useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { formatWalletAddress, getWalletBalance, saveWalletPublicKey } from '@/services/wallet-service';
import { debugWallet } from '@/utils/wallet-debug';

export default function WalletButton() {
  const { publicKey, connected, connecting, disconnecting, wallet } = useWallet();
  const [mounted, setMounted] = useState(false);
  const [balance, setBalance] = useState<number | null>(null);
  
  // Load balance when connected
  const loadBalance = useCallback(async () => {
    if (connected && publicKey) {
      try {
        const sol = await getWalletBalance(publicKey);
        setBalance(sol);
      } catch (error) {
        console.error('Error fetching balance:', error);
      }
    } else {
      setBalance(null);
    }
  }, [connected, publicKey]);

  // Only show the component after mounting to prevent hydration errors
  useEffect(() => {
    setMounted(true);
  }, []);

  // Fetch balance when connected
  useEffect(() => {
    if (connected && publicKey) {
      loadBalance();
      
      // Save the public key to localStorage for use in IPFS naming
      saveWalletPublicKey(publicKey.toString());
    }
  }, [connected, publicKey, loadBalance]);

  // Format public key for display
  const getFormattedAddress = () => {
    if (!publicKey) return '';
    return formatWalletAddress(publicKey.toString());
  };

  // Add logging for debugging connection issues
  useEffect(() => {
    if (connecting) {
      console.log('Wallet connecting...');
    } else if (disconnecting) {
      console.log('Wallet disconnecting...');
    } else if (connected) {
      console.log('Wallet connected:', getFormattedAddress());
      debugWallet(wallet);
    }
  }, [connecting, disconnecting, connected, publicKey, wallet]);
  
  if (!mounted) {
    // Return a placeholder with the same dimensions to prevent layout shift
    return <div className="wallet-button-placeholder"></div>;
  }
  
  return (
    <div className="wallet-button relative">
      <WalletMultiButton 
        className="wallet-adapter-button-trigger !bg-gradient-to-r from-purple-600 to-blue-500 !rounded-full transition-all hover:shadow-lg" 
      />
      
      {connected && balance !== null && (
        <div className="wallet-balance absolute -bottom-6 right-0 text-xs text-gray-300 bg-black/50 backdrop-blur-sm px-2 py-1 rounded-full">
          {balance.toFixed(2)} SOL
        </div>
      )}
    </div>
  );
}

// ===== src/components/wallet/wallet-provider.tsx =====

'use client';

import { FC, ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Default styles that can be overridden by your app
import '@solana/wallet-adapter-react-ui/styles.css';

interface WalletContextProviderProps {
  children: ReactNode;
}

export const WalletContextProvider: FC<WalletContextProviderProps> = ({ children }) => {
  // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.
  const network = WalletAdapterNetwork.Devnet;

  // You can also provide a custom RPC endpoint.
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Only include Phantom wallet adapter to minimize dependency issues
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

// ===== src/components/wallet/wallet-required.tsx =====

'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

interface WalletRequiredProps {
  message?: string;
}

export default function WalletRequired({ message = 'Please connect your wallet to continue' }: WalletRequiredProps) {
  const { connected } = useWallet();

  if (connected) {
    return null;
  }

  return (
    <div className="min-h-[80vh] bg-[#0a0a0a] flex items-center justify-center p-4">
      <div className="max-w-3xl w-full mx-auto p-10 bg-[#171717] rounded-xl text-center">
        <div className="w-20 h-20 bg-purple-900/20 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg className="w-10 h-10 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
          </svg>
        </div>
        
        <h2 className="text-2xl font-bold text-white mb-4">Connect Your Wallet</h2>
        <p className="text-gray-400 mb-8">
          {message}
        </p>
        
        <div className="flex justify-center">
          <WalletMultiButton className="wallet-adapter-button-trigger !bg-gradient-to-r from-purple-600 to-blue-500 !rounded-full transition-all hover:shadow-lg" />
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-provider-client.tsx =====

'use client';

import { ReactNode, useEffect, useMemo, useState } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare';

import { LedgerWalletAdapter } from '@solana/wallet-adapter-ledger';
// Removed the TorusWalletAdapter as it's causing dependency issues
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface ClientWalletProviderProps {
  children: ReactNode;
}

export function ClientWalletProvider({ children }: ClientWalletProviderProps) {
  // Track component mounting state to prevent hydration issues
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  // Set the network from environment variables
  const networkEnv = SOLANA_NETWORK || 'devnet';
  const network = networkEnv === 'mainnet-beta' 
    ? WalletAdapterNetwork.Mainnet
    : WalletAdapterNetwork.Devnet;

  // Set up the RPC endpoint
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Add a more comprehensive list of wallet adapters (except Torus which causes issues)
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),

      new LedgerWalletAdapter()
    ],
    [network]
  );

  // Only render the provider once the component is mounted to avoid hydration errors
  if (!mounted) return null;

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect={false}>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

// ===== src/services/ipfs-service.ts =====

// src/services/ipfs-service.ts

/**
 * Service for handling IPFS uploads via Pinata
 */

import { FormDataType } from "@/types/token";
import { v4 as uuidv4 } from "uuid"; // Need to add this dependency
import { setCurrentSessionUuid } from "./pinata-cleanup";

// Store the current UUID for the token creation session
let currentSessionUuid: string | null = null;

// Helper function to get the current wallet's public key
function getCurrentWalletPublicKey(): string {
  // Check if we're in a browser environment and window is defined
  if (typeof window !== "undefined") {
    // Try to get the public key from local storage if it's been saved there
    const savedPublicKey = localStorage.getItem("walletPublicKey");
    if (savedPublicKey) {
      return savedPublicKey;
    }
  }
  // Fallback if we can't get the actual public key
  return "unknown_wallet";
}

// Helper function to get the current session UUID or create a new one
function getSessionUuid(): string {
  if (!currentSessionUuid) {
    currentSessionUuid = uuidv4();
    console.log(`Created new session UUID: ${currentSessionUuid}`);

    // Sync with cleanup service
    setCurrentSessionUuid(currentSessionUuid);
  }
  return currentSessionUuid;
}

// Helper function to reset the session UUID (call this at the start of a new token creation)
export function resetSessionUuid(): void {
  console.log("Reset session UUID for new token creation");
  currentSessionUuid = null;

  // Sync with cleanup service
  setCurrentSessionUuid(null);
}

// Helper function to generate a unique file name based on wallet, UUID, and type
function generateUniqueFileName(
  type: "image" | "metadata" | "final_metadata",
  tokenKey?: string
): string {
  const walletPublicKey = getCurrentWalletPublicKey();

  // For the initial uploads, use the same UUID for both image and metadata
  if (type === "image" || type === "metadata") {
    // Use the current session UUID
    const uuid = getSessionUuid();

    if (type === "image") {
      return `${walletPublicKey}_${uuid}_image`;
    } else {
      return `${walletPublicKey}_${uuid}_metadata`;
    }
  }

  // For the final metadata after minting, use the token key
  if (type === "final_metadata" && tokenKey) {
    return `${walletPublicKey}_${tokenKey}`;
  }

  // Fallback name with timestamp
  const timestamp = Date.now();
  return `${walletPublicKey}_${timestamp}_${type}`;
}

/**
 * Uploads an image file to IPFS via Pinata
 * @returns IPFS URL for the uploaded image
 */
export async function uploadImageToIPFS(
  file: File,
  tokenName: string,
  tokenSymbol: string
): Promise<string> {
  try {
    // Reset the session UUID at the start of a new token creation
    resetSessionUuid();

    // Generate a unique filename using our new naming convention
    const uniqueFileName = generateUniqueFileName("image");
    const fileExtension = file.name.split(".").pop() || "png";
    const newFileName = `${uniqueFileName}.${fileExtension}`;

    // Create a new file with the unique name
    const uniqueFile = new File([file], newFileName, { type: file.type });

    // Create FormData to send to the API
    const formData = new FormData();
    formData.append("file", uniqueFile);

    // Add the unique filename as metadata
    formData.append("fileName", newFileName);

    console.log(`Uploading image as: ${newFileName}`);

    const res = await fetch("/api/upload-image", {
      method: "POST",
      body: formData,
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Image upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const imageUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(`Image uploaded successfully: ${imageUrl}`);
    return imageUrl;
  } catch (error) {
    console.error("Error uploading image to IPFS:", error);
    throw error;
  }
}

export interface MetadataPayload {
  name: string;
  symbol: string;
  description: string;
  image: string;
  mint?: string; // Optional mint address (added after token creation)
  creator?: string;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  // Additional fields from your non-Next.js implementation
  showName?: boolean;
  tokenInfo?: {
    chain: string;
    totalSupply: number;
    circulatingSupply: number;
    decimals: number;
  };
  createdOn?: string;
  // New metadata fields for authority status
  authorities?: {
    mintRevoked: boolean;
    freezeRevoked: boolean;
    updateRevoked: boolean;
  };
  // Removed sessionUuid from the interface as we don't want it in customer-facing metadata
}

/**
 * Uploads token metadata to IPFS via Pinata
 * @returns IPFS URL for the uploaded metadata
 */
export async function uploadMetadataToIPFS(
  payload: MetadataPayload
): Promise<string> {
  try {
    // Generate a unique filename based on our new naming convention
    // This will use the same UUID as the image since we're using the session UUID
    const uniqueFileName = generateUniqueFileName("metadata");

    // Construct the complete metadata object similar to your non-Next.js version
    const metadata: any = {
      // Core token information
      name: payload.name,
      symbol: payload.symbol,
      description: payload.description,
      image: payload.image,

      // Display preference
      showName: true,

      // Token information
      tokenInfo: {
        chain: "Solana",
        totalSupply: payload.tokenInfo?.totalSupply || 0,
        circulatingSupply: payload.tokenInfo?.circulatingSupply || 0,
        decimals: payload.tokenInfo?.decimals || 9,
      },

      // Add mint address if available (could be added later)
      ...(payload.mint && { mint: payload.mint }),

      // Add creator if provided
      ...(payload.creator && { creator: payload.creator }),

      // Add social links if provided
      ...(payload.website && { website: payload.website }),
      ...(payload.twitter && { twitter: payload.twitter }),
      ...(payload.telegram && { telegram: payload.telegram }),
      ...(payload.discord && { discord: payload.discord }),

      // Origin
      createdOn: "SolMinter",

      // Add authority status if provided
      ...(payload.authorities && { authorities: payload.authorities }),

      // Removed sessionUuid from the actual metadata
    };

    // In Pinata metadata (separate from the token metadata)
    const pinataMetadata = {
      name: `${uniqueFileName}.json`,
      keyvalues: {
        app: "SolMinter",
        type: "token_metadata",
        symbol: payload.symbol,
        timestamp: Date.now().toString(),
        sessionUuid: getSessionUuid(), // Keep tracking the session UUID in Pinata metadata
      }
    };

    console.log(
      `Uploading metadata for: ${payload.name} (${payload.symbol}) as ${uniqueFileName}`
    );

    const res = await fetch("/api/upload-metadata", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        metadata,
        fileName: `${uniqueFileName}.json`,
        pinataMetadata, // Pass the Pinata metadata separately
      }),
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Metadata upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const metadataUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(`Metadata uploaded successfully: ${metadataUrl}`);
    return metadataUrl;
  } catch (error) {
    console.error("Error uploading metadata to IPFS:", error);
    throw error;
  }
}

/**
 * Update token metadata with mint address after token creation
 * @returns IPFS URL for the updated metadata
 */
export async function updateMetadataWithMintAddress(
  originalMetadataUrl: string,
  mintAddress: string,
  formData: FormDataType,
  imageUrl: string // Add imageUrl parameter to ensure we use the correct image URL
): Promise<string> {
  try {
    // Create updated metadata payload with mint address and use the token key in the filename
    const payload: MetadataPayload = {
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      image: imageUrl, // Use the actual image URL instead of the metadata URL
      mint: mintAddress,
      creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
      tokenInfo: {
        chain: "Solana",
        totalSupply: formData.supply,
        circulatingSupply: formData.supply,
        decimals: formData.decimals,
      },
      // Add authority status information
      authorities: {
        mintRevoked: formData.revokeMint,
        freezeRevoked: formData.revokeFreeze,
        updateRevoked: formData.revokeUpdate,
      },
      // Removed sessionUuid from the payload
    };

    // Add social links if enabled
    if (formData.socialLinks) {
      payload.website = formData.website || undefined;
      payload.twitter = formData.twitter || undefined;
      payload.telegram = formData.telegram || undefined;
      payload.discord = formData.discord || undefined;
    }

    // Generate the final metadata filename using the token mint address
    const uniqueFileName = generateUniqueFileName(
      "final_metadata",
      mintAddress
    );
    
    // In Pinata metadata (separate from the token metadata)
    const pinataMetadata = {
      name: `${uniqueFileName}.json`,
      keyvalues: {
        app: "SolMinter",
        type: "token_metadata",
        symbol: formData.symbol,
        mintAddress: mintAddress,
        timestamp: Date.now().toString(),
        sessionUuid: currentSessionUuid || "unknown", // Keep tracking in Pinata metadata only
      }
    };

    // Upload the updated metadata with the new filename
    const res = await fetch("/api/upload-metadata", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        metadata: payload,
        fileName: `${uniqueFileName}.json`,
        pinataMetadata, // Pass the Pinata metadata separately
      }),
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(
        `Updated metadata upload failed: ${errorData.error || res.statusText}`
      );
    }

    const { cid, gateway } = await res.json();
    const metadataUrl = `https://${gateway}/ipfs/${cid}`;

    console.log(
      `Updated metadata uploaded successfully as ${uniqueFileName}: ${metadataUrl}`
    );

    // Reset the session UUID after the token is fully created
    resetSessionUuid();

    return metadataUrl;
  } catch (error) {
    console.error("Error updating metadata with mint address:", error);
    throw error;
  }
}

/**
 * Gets the current session UUID
 * Useful for cleanup operations
 */
export function getCurrentSessionUuid(): string | null {
  return currentSessionUuid;
}

// ===== src/services/pinata-cleanup.ts =====

// src/services/pinata-cleanup.ts

/**
 * Utility functions for cleaning up Pinata IPFS files
 * Used when a token creation transaction is canceled
 */

let currentSessionUuid: string | null = null;

/**
 * Gets the current session UUID
 * This UUID is used to track files uploaded during a token creation attempt
 */
export function getCurrentSessionUuid(): string | null {
  return currentSessionUuid;
}

/**
 * Sets the current session UUID from the IPFS service
 * Should be called when the IPFS service generates a new UUID
 */
export function setCurrentSessionUuid(uuid: string | null): void {
  currentSessionUuid = uuid;
  console.log(`Session UUID ${uuid ? `set to: ${uuid}` : 'cleared'}`);
}

/**
 * Deletes all Pinata files associated with the current session UUID
 * Called when a token creation transaction fails or is canceled
 * This function is exported for use by the Cancel button in the Loading component
 */
export async function cleanupSessionFiles(): Promise<boolean> {
  if (!currentSessionUuid) {
    console.log('No session UUID to cleanup');
    return false;
  }
  
  try {
    console.log(`Cleaning up Pinata files for session: ${currentSessionUuid}`);
    
    const response = await fetch('/api/delete-pinata-files', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        uuid: currentSessionUuid
      }),
    });
    
    if (!response.ok) {
      console.error('Failed to cleanup Pinata files:', await response.text());
      return false;
    }
    
    const result = await response.json();
    console.log('Pinata cleanup result:', result);
    
    // Clear the session UUID after successful cleanup
    setCurrentSessionUuid(null);
    
    return true;
  } catch (error) {
    console.error('Error cleaning up Pinata files:', error);
    return false;
  }
}

/**
 * Handles error by cleaning up any uploaded files if the error matches known patterns
 * for user cancellation or transaction failure
 * 
 * @param error The error object or string
 * @returns The original error for further handling
 */
export async function handleErrorWithCleanup(error: unknown): Promise<unknown> {
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  // Check if the error is a user cancellation or transaction failure
  if (
    errorMessage.includes('Transaction was canceled by the user') ||
    errorMessage.includes('User rejected') ||
    errorMessage.includes('Wallet adapter error') ||
    errorMessage.includes('Failed to process transaction')
  ) {
    console.log('Transaction was canceled. Cleaning up Pinata files...');
    await cleanupSessionFiles();
  }
  
  // Return the original error for further handling
  return error;
}

// ===== src/services/token-service.ts =====

// src/services/token-service.ts
// Main orchestration of token creation process

import { WalletContextState } from "@solana/wallet-adapter-react";
import { Connection } from "@solana/web3.js";
import { FormDataType, TokenResult } from "@/types/token";
import { SOLANA_NETWORK_FEE } from "@/config";
import { uploadImageToIPFS, uploadMetadataToIPFS } from "./ipfs-service";
import { getSolanaConnection, saveWalletPublicKey } from "./wallet-service";
import { createTokenClientSide } from "./token-creation/client-side-creation";
import { createTokenServerSide } from "./token-creation/server-side-creation";
import { handleErrorWithCleanup } from "./pinata-cleanup";

/**
 * Orchestrates token creation with a single transaction
 * Network fees are deducted from the fee recipient amount, so the user pays EXACTLY the displayed fee
 */
export async function createTokenWithMetadata(
  walletAdapter: WalletContextState,
  formData: FormDataType,
  totalFee: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, connected } = walletAdapter;
  if (!connected || !publicKey) {
    throw new Error("Wallet not connected. Please connect your wallet first.");
  }
  const connection: Connection = getSolanaConnection();

  // Ensure public key is saved for IPFS naming
  saveWalletPublicKey(publicKey.toString());

  // Validate inputs
  if (!formData.logo) {
    throw new Error("Please upload a logo image");
  }
  if (!formData.name || formData.name.trim() === "") {
    throw new Error("Token name is required");
  }
  if (!formData.symbol || formData.symbol.trim() === "") {
    throw new Error("Token symbol is required");
  }
  if (!formData.description || formData.description.trim() === "") {
    throw new Error("Token description is required");
  }

  // Ensure minimum fee
  const minimumFeeInSOL = 0.1;
  if (totalFee < minimumFeeInSOL) {
    console.warn(
      `Fee is too low (${totalFee}), using minimum fee of ${minimumFeeInSOL} SOL`
    );
    totalFee = minimumFeeInSOL;
  }

  // Calculate the net fee after subtracting the Solana network fee
  const networkFee = SOLANA_NETWORK_FEE;
  const netFeeAmount = Math.max(totalFee - networkFee, 0);

  console.log("Creating token with displayed fee:", totalFee, "SOL");
  console.log("Solana network fee:", networkFee, "SOL");
  console.log("Net fee to fee recipient:", netFeeAmount, "SOL");
  console.log("Token options:", {
    revokeMint: formData.revokeMint,
    revokeFreeze: formData.revokeFreeze,
    revokeUpdate: formData.revokeUpdate,
    socialLinks: formData.socialLinks,
    creatorInfo: formData.creatorInfo,
  });

  try {
    // STEP 0: IPFS image with unique name (now using {public_key}_{random_uuid}_image pattern)
    onProgress?.(0);
    const imageUrl = await uploadImageToIPFS(formData.logo, formData.name, formData.symbol);

    // STEP 1: IPFS metadata JSON (now using {public_key}_{random_uuid}_metadata pattern)
    onProgress?.(1);
    const metadataUrl = await uploadMetadataToIPFS({
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      image: imageUrl,
      creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
      showName: true,
      tokenInfo: {
        chain: "Solana",
        totalSupply: formData.supply,
        circulatingSupply: formData.supply,
        decimals: formData.decimals,
      },
      createdOn: "SolMinter",
      // Add authorities status for initial metadata as well
      authorities: {
        mintRevoked: formData.revokeMint,
        freezeRevoked: formData.revokeFreeze,
        updateRevoked: formData.revokeUpdate
      },
      ...(formData.socialLinks && {
        website: formData.website,
        twitter: formData.twitter,
        telegram: formData.telegram,
        discord: formData.discord,
      }),
    });

    // STEP 2: Choose flow based on whether we need to revoke update authority
    onProgress?.(2);
    
    // Check whether to use server-side update authority (only when revoking update)
    if (formData.revokeUpdate) {
      return createTokenServerSide(
        walletAdapter,
        connection,
        formData,
        metadataUrl,
        imageUrl,
        netFeeAmount,
        onProgress
      );
    } else {
      return createTokenClientSide(
        walletAdapter,
        connection,
        formData,
        metadataUrl,
        imageUrl,
        netFeeAmount,
        onProgress
      );
    }
  } catch (error) {
    // Handle error with Pinata cleanup
    console.error("Error in token creation process:", error);
    await handleErrorWithCleanup(error);
    
    // Rethrow the error for the UI to handle
    throw error;
  }
}

// ===== src/services/token-discovery-service.ts =====

// src/services/token-discovery-service.ts
// Service to discover tokens minted by the user

import { MintedTokenInfo } from '@/types/token';
import { PINATA_GATEWAY } from '@/config';

/**
 * Fetches tokens minted by a user from Pinata IPFS
 * @param publicKey - The public key of the user's wallet
 * @returns Array of minted token information
 */
export async function getUserMintedTokens(publicKey: string): Promise<MintedTokenInfo[]> {
  try {
    console.log(`Fetching tokens for wallet: ${publicKey}`);
    
    // Call our API endpoint that will search Pinata for user tokens
    const response = await fetch(`/api/user-tokens?publicKey=${encodeURIComponent(publicKey)}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user tokens: ${response.statusText}`);
    }

    const data = await response.json();
    return data.tokens;
  } catch (error) {
    console.error('Error in getUserMintedTokens:', error);
    throw error;
  }
}

/**
 * Fetches individual token data from IPFS URL
 * @param ipfsUrl - The IPFS URL to the token metadata
 * @returns Parsed token metadata
 */
export async function getTokenMetadata(ipfsUrl: string): Promise<MintedTokenInfo> {
  try {
    const response = await fetch(ipfsUrl);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch token metadata: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching token metadata:', error);
    throw error;
  }
}

/**
 * Fetches token metadata for multiple tokens
 * @param cidList - List of CIDs to fetch
 * @returns Mapped token information
 */
export async function getTokensMetadata(cidList: string[]): Promise<MintedTokenInfo[]> {
  try {
    const gateway = PINATA_GATEWAY || 'gateway.pinata.cloud';
    
    // Fetch all token metadata in parallel
    const tokenPromises = cidList.map(async (cid) => {
      const url = `https://${gateway}/ipfs/${cid}`;
      return getTokenMetadata(url);
    });
    
    return await Promise.all(tokenPromises);
  } catch (error) {
    console.error('Error in getTokensMetadata:', error);
    throw error;
  }
}

// ===== src/services/fee-service.ts =====

// src/services/fee-service.ts

export interface FeeOptions {
  revokeMint: boolean
  revokeFreeze: boolean
  revokeUpdate: boolean
  socialLinks: boolean
  creatorInfo: boolean
}

// Base fee plus optional feature fees
export function calculateFee(options: FeeOptions): number {
  let fee = 0.1; // Base fee for token creation - corrected to 0.1

  // Add fee for each enabled feature
  if (options.revokeMint)    fee += 0.1;
  if (options.revokeFreeze)  fee += 0.1;
  if (options.revokeUpdate)  fee += 0.1;
  if (options.socialLinks)   fee += 0.1;
  if (options.creatorInfo)   fee += 0.1;

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

// Format the fee for display
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

// ===== src/services/token-creation/server-side-creation.ts =====

// src/services/token-creation/server-side-creation.ts
// Handles server-side token creation flow (when revokeUpdate is true)

import {
  Connection,
  Transaction,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import type { WalletContextState } from "@solana/wallet-adapter-react";
import { FormDataType, TokenResult } from "@/types/token";
import { updateMetadataWithMintAddress } from "../ipfs-service";
import { handleErrorWithCleanup } from "../pinata-cleanup";

/**
 * Creates a token using server-side signing for update authority
 * Used when revokeUpdate is true
 */
export async function createTokenServerSide(
  walletAdapter: WalletContextState,
  connection: Connection,
  formData: FormDataType,
  metadataUrl: string,
  imageUrl: string,
  netFeeAmount: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction } = walletAdapter;

  // Validate that publicKey and signTransaction are available
  if (!publicKey) {
    throw new Error("Public key is null. Wallet must be connected.");
  }

  if (!signTransaction) {
    throw new Error("Wallet does not support transaction signing");
  }

  try {
    // Generate mint keypair client-side
    const mintKeypair = Keypair.generate();
    const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);
    const mintPrivateKey = Buffer.from(mintKeypair.secretKey).toString(
      "base64"
    );
    const { blockhash } = await connection.getLatestBlockhash();

    // Request server-side signing
    const response = await fetch("/api/sign-transaction", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        mintPrivateKey,
        metadataUrl,
        tokenName: formData.name,
        tokenSymbol: formData.symbol,
        tokenDecimals: formData.decimals,
        tokenSupply: formData.supply,
        payerPublicKey: publicKey.toString(), // Safe to call toString() now
        hasCreators: true, // IMPORTANT FIX: Always include creators
        revokeUpdate: formData.revokeUpdate,
        revokeMint: formData.revokeMint,
        revokeFreeze: formData.revokeFreeze,
        recentBlockhash: blockhash,
        feeWalletPubkey: process.env.NEXT_PUBLIC_FEE_WALLET,
        feeAmountInLamports,
        includeFeeTx: netFeeAmount > 0,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        errorData.error || "Failed to sign transaction on server"
      );
    }

    const { signedTransaction, mintAddress } = await response.json();
    const transaction = Transaction.from(
      Buffer.from(signedTransaction, "base64")
    );
    console.log(
      "Transaction constructed and signed by server for update authority"
    );

    onProgress?.(3);

    // Properly handle wallet rejection
    let walletSignedTransaction;
    try {
      walletSignedTransaction = await signTransaction(transaction);
    } catch (walletError) {
      console.error("Wallet signature rejected by user:", walletError);
      // Handle the error with cleanup
      await handleErrorWithCleanup(
        new Error("Transaction was canceled by the user")
      );
      throw new Error("Transaction was canceled by the user");
    }

    if (!walletSignedTransaction) {
      // Handle the error with cleanup
      await handleErrorWithCleanup(new Error("Transaction signing failed"));
      throw new Error("Transaction signing failed");
    }

    // Send and confirm transaction
    const txSignature = await connection.sendRawTransaction(
      walletSignedTransaction.serialize()
    );
    await connection.confirmTransaction(txSignature);
    console.log("Transaction confirmed successfully!");

    onProgress?.(6);

    // Update metadata with mint address
    // Now using {public_key}_{token_key} naming pattern
    // Now using {public_key}_{token_key} naming pattern
    const updatedMetadataUrl = await updateMetadataWithMintAddress(
      metadataUrl,
      mintAddress,
      formData,
      imageUrl // Pass the actual image URL
    );

    const clusterParam =
      process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
        ? "?cluster=devnet"
        : "";

    return {
      mintAddress,
      metadataUrl: updatedMetadataUrl,
      imageUrl,
      explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
    };
  } catch (error) {
    console.error("Error in server-side update authority flow:", error);
    // Make sure to clean up Pinata files in case of an error
    await handleErrorWithCleanup(error);

    throw new Error(
      `Failed to process transaction: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}


// ===== src/services/token-creation/token-types.ts =====

// src/services/token-creation/token-types.ts
// Type definitions for token creation process

import { PublicKey } from "@solana/web3.js";

/**
 * Metadata parameters for token creation
 */
export interface TokenMetadataParams {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: TokenCreator[] | null;
  collection: TokenCollection | null;
  uses: any | null;
  isMutable: boolean;
}

/**
 * Creator information for token metadata
 */
export interface TokenCreator {
  address: PublicKey;
  verified: boolean;
  share: number;
}

/**
 * Collection information for token metadata
 */
export interface TokenCollection {
  key: string;
  verified: boolean;
}

/**
 * Parameters for server-side transaction signing
 */
export interface ServerSignParams {
  mintPrivateKey: string;
  metadataUrl: string;
  tokenName: string;
  tokenSymbol: string;
  tokenDecimals: number;
  tokenSupply: number;
  payerPublicKey: string;
  hasCreators: boolean;
  revokeUpdate: boolean;
  revokeMint: boolean;
  revokeFreeze: boolean;
  recentBlockhash: string;
  feeWalletPubkey?: string;
  feeAmountInLamports: number;
  includeFeeTx: boolean;
}

/**
 * Response from server-side transaction signing
 */
export interface ServerSignResponse {
  success: boolean;
  signedTransaction: string;
  updateAuthority: string;
  mintAddress: string;
  error?: string;
}

// ===== src/services/token-creation/metadata-serializer.ts =====

// src/services/token-creation/metadata-serializer.ts
// Handles serialization of token metadata for on-chain storage

import { PublicKey } from "@solana/web3.js";

/**
 * Serializes a UTF-8 string with u32-length prefix (LE)
 */
export function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/**
 * Metadata parameters for token creation
 */
interface TokenMetadataParams {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: TokenCreator[] | null;
  collection: TokenCollection | null;
  uses: any | null;
  isMutable: boolean;
}

/**
 * Creator information for token metadata
 */
interface TokenCreator {
  address: PublicKey;
  verified: boolean;
  share: number;
}

/**
 * Collection information for token metadata
 */
interface TokenCollection {
  key: string;
  verified: boolean;
}

/**
 * Serializes metadata for Metaplex createMetadataAccountV3 instruction
 */
export function serializeMetadataV3(data: TokenMetadataParams): Uint8Array {
  // Serialize name, symbol, and URI
  const nameBuffer = serializeString(data.name);
  const symbolBuffer = serializeString(data.symbol);
  const uriBuffer = serializeString(data.uri);
  
  // Serialize seller fee basis points (u16)
  const sellerFeeBasisPointsBuffer = Buffer.alloc(2);
  sellerFeeBasisPointsBuffer.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  // Serialize creators (Option<Vec<Creator>>)
  let creatorsBuffer;
  if (data.creators === null) {
    creatorsBuffer = Buffer.from([0]); // None
  } else {
    const creatorsVec = Buffer.concat(
      data.creators.map((creator) => {
        const address = creator.address.toBuffer();
        const verified = Buffer.from([creator.verified ? 1 : 0]);
        const share = Buffer.from([creator.share]);
        return Buffer.concat([address, verified, share]);
      })
    );

    const creatorsLength = Buffer.alloc(4);
    creatorsLength.writeUInt32LE(data.creators.length, 0);

    creatorsBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      creatorsLength,
      creatorsVec,
    ]);
  }

  // Serialize collection (Option<Collection>)
  let collectionBuffer;
  if (data.collection === null) {
    collectionBuffer = Buffer.from([0]); // None
  } else {
    collectionBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      new PublicKey(data.collection.key).toBuffer(),
      Buffer.from([data.collection.verified ? 1 : 0]),
    ]);
  }

  // Serialize uses (Option<Uses>) - not used so set to None
  const usesBuffer = Buffer.from([0]);

  // Serialize collection details (Option<CollectionDetails>) - not used so set to None
  const collectionDetailsBuffer = Buffer.from([0]);

  // Serialize isMutable
  const isMutableBuffer = Buffer.from([data.isMutable ? 1 : 0]);

  // Combine all serialized components
  return Buffer.concat([
    nameBuffer,
    symbolBuffer,
    uriBuffer,
    sellerFeeBasisPointsBuffer,
    creatorsBuffer,
    collectionBuffer,
    usesBuffer,
    collectionDetailsBuffer,
    isMutableBuffer,
  ]);
}

// ===== src/services/token-creation/client-side-creation.ts =====

// src/services/token-creation/client-side-creation.ts
// Handles client-side token creation flow (when revokeUpdate is false)

import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  TransactionInstruction,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  MINT_SIZE,
  createInitializeMintInstruction,
  getMinimumBalanceForRentExemptMint,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
} from "@solana/spl-token";
import type { WalletContextState } from "@solana/wallet-adapter-react";

import { FormDataType, TokenResult } from "@/types/token";
import { TOKEN_METADATA_PROGRAM_ID, FEE_RECIPIENT_WALLET } from "@/config";
import { serializeMetadataV3 } from "./metadata-serializer";
import { updateMetadataWithMintAddress } from "../ipfs-service";
import { handleErrorWithCleanup } from "../pinata-cleanup";

/**
 * Creates a token using client-side transaction flow
 * Used when revokeUpdate is false (no server-side update authority needed)
 */
export async function createTokenClientSide(
  walletAdapter: WalletContextState,
  connection: Connection,
  formData: FormDataType,
  metadataUrl: string,
  imageUrl: string,
  netFeeAmount: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction } = walletAdapter;

  // Validate that publicKey is not null before proceeding
  if (!publicKey) {
    throw new Error("Public key is null. Wallet must be connected.");
  }

  try {
    const mintKeypair = Keypair.generate();
    const rentExempt = await getMinimumBalanceForRentExemptMint(connection);

    const instructions: TransactionInstruction[] = [];
    const feeWalletPubkey = new PublicKey(FEE_RECIPIENT_WALLET);
    const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);

    // Add fee transfer instruction if needed
    if (feeAmountInLamports > 0) {
      instructions.push(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: feeWalletPubkey,
          lamports: feeAmountInLamports,
        })
      );
    } else {
      console.log("Net fee is zero or negative, skipping fee transfer");
    }

    // Create and initialize mint account
    instructions.push(
      SystemProgram.createAccount({
        fromPubkey: publicKey,
        newAccountPubkey: mintKeypair.publicKey,
        space: MINT_SIZE,
        lamports: rentExempt,
        programId: TOKEN_PROGRAM_ID,
      })
    );

    instructions.push(
      createInitializeMintInstruction(
        mintKeypair.publicKey,
        formData.decimals,
        publicKey,
        publicKey,
        TOKEN_PROGRAM_ID
      )
    );

    // Create associated token account and mint tokens
    const ata = await getAssociatedTokenAddress(
      mintKeypair.publicKey,
      publicKey
    );

    instructions.push(
      createAssociatedTokenAccountInstruction(
        publicKey,
        ata,
        publicKey,
        mintKeypair.publicKey
      )
    );

    const mintAmount =
      BigInt(formData.supply) * BigInt(10 ** formData.decimals);
    instructions.push(
      createMintToInstruction(mintKeypair.publicKey, ata, publicKey, mintAmount)
    );

    onProgress?.(4);

    // Create metadata
    const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        metadataProgramId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      metadataProgramId
    );

    // IMPORTANT FIX: Always include creators array with the user's wallet
    // This ensures the creator field is properly set in the Metaplex metadata
    const creators = [
      {
        address: publicKey,
        verified: true,
        share: 100,
      },
    ];

    // If custom creator info is enabled, we'll update the creator name in the URI metadata
    // but the on-chain Metaplex metadata should still have the actual wallet address

    instructions.push({
      programId: metadataProgramId,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
        { pubkey: publicKey, isSigner: true, isWritable: false }, // mint authority
        { pubkey: publicKey, isSigner: true, isWritable: false }, // payer
        { pubkey: publicKey, isSigner: false, isWritable: false }, // update authority
        {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false,
        },
      ],
      data: Buffer.concat([
        Buffer.from([33]), // createMetadataAccountV3 discriminator
        serializeMetadataV3({
          name: formData.name,
          symbol: formData.symbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators, // Always include creators array with user's wallet
          collection: null,
          uses: null,
          isMutable: false,
        }),
      ]),
    });

    onProgress?.(5);

    // Add authority revocation instructions if requested
    if (formData.revokeMint) {
      instructions.push(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          publicKey,
          AuthorityType.MintTokens,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    if (formData.revokeFreeze) {
      instructions.push(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          publicKey,
          AuthorityType.FreezeAccount,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    // Create and sign transaction
    const transaction = new Transaction();
    instructions.forEach((ix) => transaction.add(ix));
    transaction.feePayer = publicKey;
    transaction.recentBlockhash = (
      await connection.getLatestBlockhash()
    ).blockhash;
    transaction.partialSign(mintKeypair);

    console.log("Sending transaction to wallet for approval...");

    // Handle wallet rejection properly
    if (!signTransaction) {
      throw new Error("Wallet does not support transaction signing");
    }

    let signedTransaction;
    try {
      signedTransaction = await signTransaction(transaction);
    } catch (walletError) {
      console.error("Wallet signature rejected by user:", walletError);
      // Handle the error with cleanup
      await handleErrorWithCleanup(
        new Error("Transaction was canceled by the user")
      );
      throw new Error("Transaction was canceled by the user");
    }

    if (!signedTransaction) {
      // Handle the error with cleanup
      await handleErrorWithCleanup(new Error("Transaction signing failed"));
      throw new Error("Transaction signing failed");
    }

    // Send and confirm transaction
    const txSignature = await connection.sendRawTransaction(
      signedTransaction.serialize()
    );
    await connection.confirmTransaction(txSignature);

    const mintAddress = mintKeypair.publicKey.toString();
    onProgress?.(6);

    // Fix in createTokenClientSide function:

    // Update metadata with mint address - now using {public_key}_{token_key} format
    let finalMetadataUrl = metadataUrl;
    try {
      finalMetadataUrl = await updateMetadataWithMintAddress(
        metadataUrl,
        mintAddress,
        formData,
        imageUrl // Pass the actual image URL
      );
    } catch (updateError) {
      console.error("Error updating metadata (non-critical):", updateError);
    }

    const clusterParam =
      process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
        ? "?cluster=devnet"
        : "";

    return {
      mintAddress,
      metadataUrl: finalMetadataUrl,
      imageUrl,
      explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
    };
  } catch (error: unknown) {
    console.error("Transaction error:", error);
    // Make sure to clean up Pinata files in case of an error
    await handleErrorWithCleanup(error);

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to process transaction: ${errorMessage}`);
  }
}


// ===== src/services/token-creation/token-validation.ts =====

// src/services/token-creation/token-validation.ts
// Functions for validating token parameters

import { FormDataType } from "@/types/token";

/**
 * Validates all token creation parameters before submission
 * @returns Error message or null if valid
 */
export function validateTokenCreationParams(formData: FormDataType): string | null {
  // Validate basic token info
  if (!formData.logo) {
    return "Please upload a logo image";
  }
  
  if (!formData.name || formData.name.trim() === "") {
    return "Token name is required";
  }
  
  if (formData.name.length > 32) {
    return "Token name must be 32 characters or less";
  }
  
  if (!formData.symbol || formData.symbol.trim() === "") {
    return "Token symbol is required";
  }
  
  if (formData.symbol.length > 10) {
    return "Token symbol must be 10 characters or less";
  }
  
  if (!formData.description || formData.description.trim() === "") {
    return "Token description is required";
  }
  
  // Validate token parameters
  if (formData.decimals < 0 || formData.decimals > 9) {
    return "Decimals must be between 0 and 9";
  }
  
  if (formData.supply <= 0) {
    return "Supply must be greater than 0";
  }
  
  if (formData.supply > Number.MAX_SAFE_INTEGER) {
    return "Supply is too large";
  }
  
  // Validate social links if they're enabled
  if (formData.socialLinks) {
    // Optional URL validation
    if (formData.website && !isValidUrl(formData.website)) {
      return "Website URL is invalid";
    }
    
    if (formData.twitter && !isValidUrl(formData.twitter)) {
      return "Twitter URL is invalid";
    }
    
    if (formData.telegram && !isValidUrl(formData.telegram)) {
      return "Telegram URL is invalid";
    }
    
    if (formData.discord && !isValidUrl(formData.discord)) {
      return "Discord URL is invalid";
    }
  }
  
  return null;
}

/**
 * Validates an image file for token logo
 */
export function isValidTokenImage(file: File | null): boolean {
  if (!file) {
    return false;
  }
  
  // Check file type
  const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
  if (!validTypes.includes(file.type)) {
    return false;
  }
  
  // Check file size (max 5MB)
  const maxSize = 5 * 1024 * 1024; // 5MB
  if (file.size > maxSize) {
    return false;
  }
  
  return true;
}

/**
 * Simple URL validation
 */
function isValidUrl(urlString: string): boolean {
  try {
    const url = new URL(urlString);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch (e) {
    return false;
  }
}

// ===== src/services/fee-calculator.ts =====

// src/services/fee-calculator.ts
// Functions for calculating and formatting token creation fees

import { SOLANA_NETWORK_FEE } from "@/config";

/**
 * Options for fee calculation
 */
export interface FeeOptions {
  revokeMint: boolean;
  revokeFreeze: boolean;
  revokeUpdate: boolean;
  socialLinks: boolean;
  creatorInfo: boolean;
}

/**
 * Fee calculation constants
 */
export const FEE_CONSTANTS = {
  BASE_FEE: 0.1,        // Base fee for token creation
  AUTHORITY_FEE: 0.1,   // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MINIMUM_FEE: 0.1      // Minimum fee for any token creation
};

/**
 * Calculates the total fee based on selected options
 * @returns Fee amount in SOL
 */
export function calculateFee(options: FeeOptions): number {
  let fee = FEE_CONSTANTS.BASE_FEE;

  // Add fee for each enabled feature
  if (options.revokeMint) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.revokeFreeze) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.revokeUpdate) fee += FEE_CONSTANTS.AUTHORITY_FEE;
  if (options.socialLinks) fee += FEE_CONSTANTS.SOCIAL_LINKS_FEE;
  if (options.creatorInfo) fee += FEE_CONSTANTS.CREATOR_INFO_FEE;

  // Ensure minimum fee
  fee = Math.max(fee, FEE_CONSTANTS.MINIMUM_FEE);

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

/**
 * Calculates the net fee after deducting network costs
 * @returns Net fee amount in SOL that goes to the fee recipient
 */
export function calculateNetFee(totalFee: number): number {
  // Deduct the Solana network fee from the total
  const networkFee = SOLANA_NETWORK_FEE;
  return Math.max(totalFee - networkFee, 0);
}

/**
 * Format a fee amount for display
 * @returns Formatted fee string
 */
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

/**
 * Gets a breakdown of fees for display
 * @returns Object with fee breakdowns
 */
export function getFeeBreakdown(options: FeeOptions): {
  total: number;
  net: number;
  networkFee: number;
  components: { name: string; amount: number }[];
} {
  const total = calculateFee(options);
  const networkFee = SOLANA_NETWORK_FEE;
  const net = calculateNetFee(total);
  
  const components = [
    { name: "Base fee", amount: FEE_CONSTANTS.BASE_FEE }
  ];
  
  if (options.revokeMint) {
    components.push({ name: "Revoke mint authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.revokeFreeze) {
    components.push({ name: "Revoke freeze authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.revokeUpdate) {
    components.push({ name: "Revoke update authority", amount: FEE_CONSTANTS.AUTHORITY_FEE });
  }
  
  if (options.socialLinks) {
    components.push({ name: "Social links", amount: FEE_CONSTANTS.SOCIAL_LINKS_FEE });
  }
  
  if (options.creatorInfo) {
    components.push({ name: "Creator info", amount: FEE_CONSTANTS.CREATOR_INFO_FEE });
  }
  
  return {
    total,
    net,
    networkFee,
    components
  };
}

// ===== src/services/wallet-service.ts =====

// src/services/wallet-service.ts
import { WalletAdapter } from '@solana/wallet-adapter-base';
import { Connection, clusterApiUrl, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Get the Solana connection based on the configured network
export const getSolanaConnection = (): Connection => {
  const network = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
  return new Connection(clusterApiUrl(network), 'confirmed');
};

// Save the current wallet's public key to localStorage for reference
export const saveWalletPublicKey = (publicKey: string): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('walletPublicKey', publicKey);
    console.log(`Wallet public key saved: ${publicKey}`);
  }
};

// Get the saved wallet public key
export const getSavedWalletPublicKey = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('walletPublicKey');
  }
  return null;
};

// Check if wallet is properly connected
export const isWalletConnected = (wallet: any): boolean => {
  // Debug log to help diagnose issues
  console.log("Wallet connection check:", {
    walletExists: !!wallet,
    publicKeyExists: wallet ? !!wallet.publicKey : false,
    adapterExists: wallet ? !!wallet.adapter : false,
    adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false
  });
  
  // For some wallets, adapter.connected might not be reliable
  // Consider a wallet connected if it has a wallet object and a public key
  return !!wallet && !!wallet.publicKey;
};

// Get the wallet's SOL balance
export const getWalletBalance = async (publicKey: PublicKey): Promise<number> => {
  try {
    const connection = getSolanaConnection();
    const balance = await connection.getBalance(publicKey);
    console.log(`Wallet balance: ${balance / 1_000_000_000} SOL`);
    return balance / 1_000_000_000; // Convert lamports to SOL
  } catch (error) {
    console.error('Error getting wallet balance:', error);
    return 0;
  }
};

// Format the wallet address for display
export const formatWalletAddress = (address: string): string => {
  if (!address || address.length < 10) return address;
  return `${address.slice(0, 4)}...${address.slice(-4)}`;
};

// Get the Solana explorer URL for a transaction or address
export const getExplorerUrl = (addressOrSignature: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${addressOrSignature}${network}`;
};

