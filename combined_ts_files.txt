// ===== next-env.d.ts =====

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// ===== next.config.ts =====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


// ===== src/middleware.ts =====

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// This middleware ensures CORS headers are properly set for API routes
export function middleware(request: NextRequest) {
  // Only apply to /api routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    // Handle OPTIONS requests for CORS preflight
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        },
      });
    }

    // Add CORS headers to all responses
    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return response;
  }

  return NextResponse.next();
}

// Configure which routes the middleware applies to
export const config = {
  matcher: '/api/:path*',
};

// ===== src/types/env.d.ts =====

// src/types/env.d.ts

declare namespace NodeJS {
  interface ProcessEnv {
    // Solana Network settings
    NEXT_PUBLIC_SOLANA_NETWORK: "devnet" | "mainnet-beta";

    // Fee recipient wallet address
    NEXT_PUBLIC_FEE_WALLET: string;

    // Pinata IPFS settings
    NEXT_PUBLIC_PINATA_GATEWAY: string;
    PINATA_JWT: string;

    // Solana network fee
    NEXT_PUBLIC_SOLANA_NETWORK_FEE: string;

    REVOKE_UPDATE_PRIVATE_KEY: string;
  }
}


// ===== src/types/token.ts =====

// Update or create this in a shared location like src/types/token.ts

export interface FormDataType {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
    socialLinks: boolean;
    creatorInfo: boolean;
    creatorName: string; // Added for Creator's Info
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  }
  
  export interface TokenResult {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  }

// ===== src/app/guides/page.tsx =====

export default function Guides() {
    return (
      <div className="min-h-screen bg-[#0a0a0a]">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
          <h1 className="text-4xl font-bold text-center mb-10">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              Guides & Resources
            </span>
          </h1>
          
          <div className="space-y-12">
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">How to Create a Solana Token</h2>
              <div className="prose prose-invert max-w-none">
                <ol className="list-decimal pl-5 space-y-4">
                  <li>
                    <strong>Connect Your Wallet</strong>
                    <p className="text-gray-400">
                      Click the "Connect Wallet" button in the top right corner and connect your Phantom, Solflare, or other compatible Solana wallet.
                    </p>
                  </li>
                  <li>
                    <strong>Fill in Token Details</strong>
                    <p className="text-gray-400">
                      Enter your token's name, symbol, supply, and other details. Upload a logo image (1000x1000px recommended).
                    </p>
                  </li>
                  <li>
                    <strong>Configure Token Options</strong>
                    <p className="text-gray-400">
                      Choose whether to include social links and creator information. Select which authorities to revoke (recommended for investor trust).
                    </p>
                  </li>
                  <li>
                    <strong>Launch Your Token</strong>
                    <p className="text-gray-400">
                      Click "Launch Token" and approve the transaction in your wallet. Your token will be created on the Solana blockchain.
                    </p>
                  </li>
                  <li>
                    <strong>Create Liquidity</strong>
                    <p className="text-gray-400">
                      After creating your token, consider setting up a liquidity pool on Raydium or another Solana DEX to make your token tradable.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            
            <div className="bg-[#171717] rounded-xl p-6 shadow-lg">
              <h2 className="text-2xl font-semibold text-white mb-4">Token Authorities Explained</h2>
              <div className="prose prose-invert max-w-none">
                <p className="text-gray-400">
                  Solana tokens have three types of authorities that control different aspects of the token:
                </p>
                <ul className="list-disc pl-5 space-y-3 mt-4">
                  <li>
                    <strong>Mint Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to create (mint) new tokens. Revoking this authority creates a fixed supply token that cannot be inflated.
                    </p>
                  </li>
                  <li>
                    <strong>Freeze Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to freeze token accounts, preventing transfers. Revoking this ensures no one can freeze holders' tokens.
                    </p>
                  </li>
                  <li>
                    <strong>Update Authority</strong>
                    <p className="text-gray-400">
                      Controls the ability to modify token metadata (name, symbol, image, etc.). Revoking makes the token's metadata immutable.
                    </p>
                  </li>
                </ul>
                <p className="text-gray-400 mt-4">
                  For maximum credibility with your community, we recommend revoking all authorities.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

// ===== src/app/create-token/page.tsx =====

import TokenForm from '@/components/token/token-form';

export default function CreateToken() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <TokenForm />
    </div>
  );
}

// ===== src/app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Navbar from "@/components/layout/navbar";
import Footer from "@/components/layout/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SolMinter - Create Solana Tokens Easily",
  description: "Create, launch, and manage Solana tokens with ease. Your one-stop solution for Solana meme coin creation.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link 
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" 
          rel="stylesheet"
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0a0a0a] text-white`}
      >
        <Providers>
          <div className="min-h-screen flex flex-col">
            <Navbar />
            <main className="flex-grow">{children}</main>
            <Footer />
          </div>
        </Providers>
      </body>
    </html>
  );
}

// ===== src/app/api/upload-metadata/route.ts =====

// src/app/api/upload-metadata/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the metadata from the request body
    const { metadata, fileName } = await request.json();
    
    console.log("Received metadata:", metadata);
    console.log("Filename:", fileName || 'metadata.json');
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Prepare pinata options and metadata
      const options = {
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      };
      
      const pinataMetadata = {
        name: fileName || `${metadata.symbol}_metadata.json`,
        keyvalues: {
          app: "SolMinter",
          type: "token_metadata",
          symbol: metadata.symbol,
          timestamp: Date.now().toString()
        }
      };
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: JSON.stringify({
          pinataOptions: options,
          pinataMetadata: pinataMetadata,
          pinataContent: metadata
        })
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud'
    });
  } catch (error) {
    console.error('Error uploading metadata:', error);
    return NextResponse.json(
      { error: 'Failed to upload metadata' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/update-authority/route.ts =====

// src/app/api/update-authority/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Keypair } from '@solana/web3.js';

/**
 * API route that securely provides the public key of the update authority
 * This keeps the private key on the server side
 */
export async function GET(request: NextRequest) {
  try {
    // Get the private key from environment variables
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updateAuthorityPrivateKey) {
      console.error("REVOKE_UPDATE_PRIVATE_KEY is not set in environment variables");
      return NextResponse.json(
        { 
          success: false, 
          error: "Update authority not configured",
          message: "Server environment is not properly configured for update authority revocation."
        },
        { status: 500 }
      );
    }
    
    try {
      // Decode the base58-encoded private key to generate keypair
      const secretKey = bs58.decode(updateAuthorityPrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      
      // Return only the public key
      return NextResponse.json({
        success: true,
        updateAuthorityPublicKey: updateAuthorityKeypair.publicKey.toString()
      });
    } catch (error) {
      console.error("Error creating update authority keypair:", error);
      return NextResponse.json(
        { 
          success: false, 
          error: "Invalid update authority key format",
          message: "Server has an invalid private key format."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error accessing update authority:", error);
    return NextResponse.json(
      { 
        success: false, 
        error: "Server error", 
        message: "An unexpected error occurred while accessing the update authority."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/api/sign-transaction/route.ts =====

// src/app/api/sign-transaction/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import {
  Transaction,
  Keypair,
  PublicKey,
  SystemProgram,
  Connection,
  clusterApiUrl
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  createInitializeMintInstruction,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint
} from "@solana/spl-token";
import { TOKEN_METADATA_PROGRAM_ID, SOLANA_NETWORK } from '@/config';

/** Helper: serialize a UTF‑8 string with u32‑length prefix (LE) */
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/** Helper: serialize metadata for Metaplex createMetadataAccountV3 */
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: PublicKey; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  const nameBuff   = serializeString(data.name);
  const symbolBuff = serializeString(data.symbol);
  const uriBuff    = serializeString(data.uri);

  const feeBuff = Buffer.alloc(2);
  feeBuff.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  let creatorsBuff: Buffer;
  if (!data.creators) {
    creatorsBuff = Buffer.from([0]);
  } else {
    const vec = Buffer.concat(
      data.creators.map(c => Buffer.concat([
        c.address.toBuffer(),
        Buffer.from([c.verified ? 1 : 0]),
        Buffer.from([c.share])
      ]))
    );
    const len = Buffer.alloc(4);
    len.writeUInt32LE(data.creators.length, 0);
    creatorsBuff = Buffer.concat([Buffer.from([1]), len, vec]);
  }

  const collectionBuff = data.collection
    ? Buffer.concat([
        Buffer.from([1]),
        new PublicKey(data.collection.key).toBuffer(),
        Buffer.from([data.collection.verified ? 1 : 0])
      ])
    : Buffer.from([0]);

  const usesBuff              = Buffer.from([0]);
  const collectionDetailsBuff = Buffer.from([0]);
  const isMutableBuff         = Buffer.from([data.isMutable ? 1 : 0]);

  return Buffer.concat([
    nameBuff,
    symbolBuff,
    uriBuff,
    feeBuff,
    creatorsBuff,
    collectionBuff,
    usesBuff,
    collectionDetailsBuff,
    isMutableBuff,
  ]);
}

export async function POST(request: NextRequest) {
  try {
    const {
      mintPrivateKey,
      metadataUrl,
      tokenName,
      tokenSymbol,
      tokenDecimals,
      tokenSupply,
      payerPublicKey,
      hasCreators,
      revokeUpdate,
      revokeMint,
      revokeFreeze,
      recentBlockhash,
      feeWalletPubkey,
      feeAmountInLamports,
      includeFeeTx = false
    } = await request.json();

    // Validate required fields...
    if (!mintPrivateKey || !metadataUrl || !tokenName || !tokenSymbol || !payerPublicKey) {
      return NextResponse.json({ error: "Missing required transaction data" }, { status: 400 });
    }

    // Server‐side update authority key
    const updateAuthorityPrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    if (revokeUpdate && !updateAuthorityPrivateKey) {
      return NextResponse.json({ error: "Update authority not configured on server" }, { status: 500 });
    }

    const network    = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
    const connection = new Connection(clusterApiUrl(network));

    // Reconstruct the mint keypair
    const mintSecret  = Buffer.from(mintPrivateKey, 'base64');
    const mintKeypair = Keypair.fromSecretKey(new Uint8Array(mintSecret));

    // Choose update authority keypair
    let updateAuthorityKeypair: Keypair;
    if (revokeUpdate) {
      const serverSecret = bs58.decode(updateAuthorityPrivateKey!);
      updateAuthorityKeypair = Keypair.fromSecretKey(serverSecret);
    } else {
      updateAuthorityKeypair = mintKeypair;
    }

    const payer = new PublicKey(payerPublicKey);

    // Build the transaction
    const transaction = new Transaction();
    transaction.recentBlockhash = recentBlockhash;
    transaction.feePayer       = payer;

    // Optional fee transfer
    if (includeFeeTx && feeWalletPubkey && feeAmountInLamports > 0) {
      transaction.instructions.unshift(
        SystemProgram.transfer({
          fromPubkey: payer,
          toPubkey: new PublicKey(feeWalletPubkey),
          lamports: feeAmountInLamports,
        })
      );
    }

    // Rent‐exempt mint account creation & initialization
    const rentExempt = await getMinimumBalanceForRentExemptMint(connection);
    transaction.add(
      SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: mintKeypair.publicKey,
        space: MINT_SIZE,
        lamports: rentExempt,
        programId: TOKEN_PROGRAM_ID,
      })
    );
    transaction.add(
      createInitializeMintInstruction(
        mintKeypair.publicKey,
        tokenDecimals,
        payer,
        payer,
        TOKEN_PROGRAM_ID
      )
    );

    // Associated Token Account & minting
    const ata = await getAssociatedTokenAddress(mintKeypair.publicKey, payer);
    transaction.add(
      createAssociatedTokenAccountInstruction(
        payer,
        ata,
        payer,
        mintKeypair.publicKey
      )
    );
    const mintAmount = BigInt(tokenSupply) * BigInt(10 ** tokenDecimals);
    transaction.add(
      createMintToInstruction(
        mintKeypair.publicKey,
        ata,
        payer,
        mintAmount
      )
    );

    // Metadata PDA
    const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        metadataProgramId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      metadataProgramId
    );

    // **1.** Prepare creators array
    let creators = null;
    if (hasCreators) {
      creators = [
        {
          address: payer,
          verified: false,   // <- changed from `true` to `false`
          share: 100,
        },
      ];
    }

    // **2.** Create Metadata instruction
    transaction.add({
      programId: metadataProgramId,
      keys: [
        { pubkey: metadataPDA, isSigner: false, isWritable: true },
        { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
        { pubkey: payer, isSigner: true, isWritable: false },                // mint authority
        { pubkey: payer, isSigner: true, isWritable: false },                // payer
        { pubkey: updateAuthorityKeypair.publicKey, isSigner: true, isWritable: false }, // update authority
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data: Buffer.concat([
        Buffer.from([33]), // createMetadataAccountV3 discriminator
        serializeMetadataV3({
          name: tokenName,
          symbol: tokenSymbol,
          uri: metadataUrl,
          sellerFeeBasisPoints: 0,
          creators,
          collection: null,
          uses: null,
          isMutable: !revokeUpdate,
        }),
      ]),
    });

    // **3.** Optional authority revocations
    if (revokeMint) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.MintTokens,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }
    if (revokeFreeze) {
      transaction.add(
        createSetAuthorityInstruction(
          mintKeypair.publicKey,
          payer,
          AuthorityType.FreezeAccount,
          null,
          [],
          TOKEN_PROGRAM_ID
        )
      );
    }

    // **4.** Sign with server key if revoking update authority
    if (revokeUpdate) {
      console.log("Signing with server update authority:", updateAuthorityKeypair.publicKey.toString());
      transaction.partialSign(updateAuthorityKeypair);
    }

    // Always sign with the mint keypair
    console.log("Signing with mint keypair:", mintKeypair.publicKey.toString());
    transaction.partialSign(mintKeypair);

    // **5.** Serialize and return for wallet to sign & send
    const serialized = transaction.serialize({ requireAllSignatures: false });
    const b64 = Buffer.from(serialized).toString('base64');

    return NextResponse.json({
      success: true,
      signedTransaction: b64,
      updateAuthority: updateAuthorityKeypair.publicKey.toString(),
      mintAddress: mintKeypair.publicKey.toString(),
    });

  } catch (error) {
    console.error("Error in sign-transaction:", error);
    return NextResponse.json(
      { error: `Failed to sign transaction: ${error instanceof Error ? error.message : error}` },
      { status: 500 }
    );
  }
}


// ===== src/app/api/upload-image/route.ts =====

// src/app/api/upload-image/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    console.log("Received file:", file.name, "Size:", file.size, "Type:", file.type);
    
    // In a production environment, you would now upload to Pinata using their API
    // For demonstration purposes with the ENV variables you provided:
    
    // If you have a Pinata JWT token in your environment variables, you can use it
    const pinataJWT = process.env.PINATA_JWT;
    const pinataGateway = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'olive-ready-turkey-58.mypinata.cloud';
    
    if (pinataJWT) {
      // Create a FormData object to send to Pinata
      const pinataFormData = new FormData();
      pinataFormData.append('file', file);
      
      // Add pin options as metadata
      const pinOptions = JSON.stringify({
        cidVersion: 1,
        customPinPolicy: {
          regions: [
            {
              id: 'FRA1',
              desiredReplicationCount: 1
            },
            {
              id: 'NYC1',
              desiredReplicationCount: 1
            }
          ]
        }
      });
      pinataFormData.append('pinataOptions', pinOptions);
      
      // Add metadata
      const metadata = JSON.stringify({
        name: file.name,
        keyvalues: {
          app: "SolMinter",
          type: "token_image",
          timestamp: Date.now().toString()
        }
      });
      pinataFormData.append('pinataMetadata', metadata);
      
      // Send request to Pinata
      const pinataResponse = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${pinataJWT}`
        },
        body: pinataFormData
      });
      
      if (!pinataResponse.ok) {
        const errorDetails = await pinataResponse.json();
        console.error('Pinata upload error:', errorDetails);
        return NextResponse.json(
          { error: `Failed to upload to Pinata: ${errorDetails.error || pinataResponse.statusText}` },
          { status: 500 }
        );
      }
      
      const pinataResult = await pinataResponse.json();
      
      return NextResponse.json({ 
        success: true, 
        cid: pinataResult.IpfsHash,
        gateway: pinataGateway
      });
    }
    
    // Fallback to fake CID if no Pinata API key (for development only)
    const fakeCid = `bafybeie${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
    console.warn('Using fake CID because Pinata API credentials were not found');
    
    return NextResponse.json({ 
      success: true, 
      cid: fakeCid,
      gateway: pinataGateway || 'gateway.pinata.cloud'
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    return NextResponse.json(
      { error: 'Failed to upload image' },
      { status: 500 }
    );
  }
}

// ===== src/app/api/create-token/route.ts =====

// src/app/api/create-token/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bs58 from 'bs58';
import { Connection, Keypair, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// This API endpoint is for validating the environment is correctly set up
// We don't actually create tokens here - that happens client-side
// But we confirm the update authority keypair is valid
export async function GET(request: NextRequest) {
  try {
    // Check if the required environment variable is present
    const updatePrivateKey = process.env.REVOKE_UPDATE_PRIVATE_KEY;
    
    if (!updatePrivateKey) {
      return NextResponse.json(
        { 
          ok: false, 
          error: "Update authority private key is not configured",
          message: "The server is not properly configured for revoking update authority. Please check server configuration."
        },
        { status: 500 }
      );
    }
    
    // Try to create a keypair from the private key
    try {
      const secretKey = bs58.decode(updatePrivateKey);
      const updateAuthorityKeypair = Keypair.fromSecretKey(secretKey);
      const updateAuthorityPublicKey = updateAuthorityKeypair.publicKey.toString();
      
      // Return a redacted version of the public key for confirmation
      const redactedPublicKey = `${updateAuthorityPublicKey.substring(0, 4)}...${updateAuthorityPublicKey.substring(updateAuthorityPublicKey.length - 4)}`;
      
      return NextResponse.json({ 
        ok: true, 
        message: "Update authority configuration is valid", 
        updateAuthority: redactedPublicKey,
        network: SOLANA_NETWORK
      });
    } catch (error) {
      console.error("Error validating update authority keypair:", error);
      return NextResponse.json(
        { 
          ok: false, 
          error: "Invalid update authority key format",
          message: "The server has an incorrectly formatted update authority key."
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error in update authority validation:", error);
    return NextResponse.json(
      { 
        ok: false, 
        error: "Server error", 
        message: "An unexpected error occurred while validating the server configuration."
      },
      { status: 500 }
    );
  }
}

// ===== src/app/page.tsx =====

import Link from 'next/link';

export default function Home() {
  return (
    <div className="min-h-screen bg-[#0a0a0a]">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20">
        <div className="text-center">
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6">
            <span className="bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">
              SolMinter
            </span>
          </h1>
          <p className="text-xl md:text-2xl text-gray-400 mb-8 max-w-3xl mx-auto">
            Create, launch, and manage Solana tokens with ease. 
            Your one-stop solution for Solana meme coin creation.
          </p>
          
          <div className="flex flex-col sm:flex-row justify-center gap-4 mb-12">
            <Link href="/create-token" className="bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all">
              Create Token
            </Link>
            <Link href="/guides" className="bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all">
              Learn More
            </Link>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-purple-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Easy Token Creation</h2>
              <p className="text-gray-400">Create your Solana token with just a few clicks. No coding required.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-blue-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Secure & Trusted</h2>
              <p className="text-gray-400">Built on Solana for fast transactions and high security standards.</p>
            </div>
            
            <div className="feature-card bg-[#171717] p-6 rounded-xl shadow-lg">
              <div className="icon-circle w-16 h-16 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mb-4 mx-auto">
                <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
              </div>
              <h2 className="text-xl font-semibold text-white mb-2">Lightning Fast</h2>
              <p className="text-gray-400">Launch your token in seconds with minimal fees on the Solana blockchain.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};  

// ===== src/app/providers.tsx =====

'use client';

import { ReactNode, useEffect, useState } from 'react';
import dynamic from 'next/dynamic';

// Create a client-only wrapper component
const WalletConnectionProvider = ({ children }: { children: ReactNode }) => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return <>{children}</>;
};

// Dynamically import the wallet components with ssr: false
const ClientWalletProvider = dynamic(
  () => import('../components/wallet/wallet-provider-client').then(module => module.ClientWalletProvider),
  {
    ssr: false,
    loading: () => <WalletConnectionProvider><div>{/* Loading placeholder */}</div></WalletConnectionProvider>
  }
);

export function Providers({ children }: { children: ReactNode }) {
  return (
    <ClientWalletProvider>
      {children}
    </ClientWalletProvider>
  );
}

// ===== src/config/ipfs.ts =====

// src/config/ipfs.ts

/**
 * Configuration for IPFS and Pinata services
 */

// IPFS Gateway configuration
export const IPFS_CONFIG = {
    // Default gateway to use (fallback if environment variable is not set)
    DEFAULT_GATEWAY: 'gateway.pinata.cloud',
    
    // The gateway to use from environment variables or fallback
    GATEWAY: process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud',
    
    // Whether we have proper Pinata credentials (JWT token)
    HAS_PINATA_CREDENTIALS: !!process.env.PINATA_JWT,
    
    // Pinata API endpoints
    PINATA_API: {
      UPLOAD_FILE: 'https://api.pinata.cloud/pinning/pinFileToIPFS',
      UPLOAD_JSON: 'https://api.pinata.cloud/pinning/pinJSONToIPFS',
      REMOVE_PIN: 'https://api.pinata.cloud/pinning/unpin',
    },
    
    // Default pin policy for geographical redundancy
    DEFAULT_PIN_POLICY: {
      regions: [
        {
          id: 'FRA1',
          desiredReplicationCount: 1
        },
        {
          id: 'NYC1',
          desiredReplicationCount: 1
        }
      ]
    }
  };
  
  /**
   * Get the complete IPFS URL with gateway
   * @param cid The IPFS CID
   * @returns Full gateway URL
   */
  export function getIpfsUrl(cid: string): string {
    return `https://${IPFS_CONFIG.GATEWAY}/ipfs/${cid}`;
  }
  
  /**
   * Check if we have proper Pinata credentials
   */
  export function hasPinataCredentials(): boolean {
    return IPFS_CONFIG.HAS_PINATA_CREDENTIALS;
  }

// ===== src/config/index.ts =====

// src/config/index.ts

// Solana network configuration
export const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

// Fee recipient wallet - address that will receive token creation fees
export const FEE_RECIPIENT_WALLET = process.env.NEXT_PUBLIC_FEE_WALLET || '8oUmkz9VmF9upLxUg6qp6iaq5N4A86bUuo37SJvXvzWt';

// Solana network fee in SOL - this amount is subtracted from the total fee
export const SOLANA_NETWORK_FEE = parseFloat(process.env.NEXT_PUBLIC_SOLANA_NETWORK_FEE || '0.01862');

// IPFS/Pinata configuration
export const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud';
export const PINATA_API_KEY = process.env.NEXT_PUBLIC_PINATA_API_KEY;
export const PINATA_SECRET_KEY = process.env.NEXT_PUBLIC_PINATA_SECRET_KEY;

// Token creation fees (in SOL)
export const TOKEN_FEES = {
  BASE_FEE: 0.2,  // Base fee for token creation
  AUTHORITY_FEE: 0.1, // Fee per authority revoked
  SOCIAL_LINKS_FEE: 0.1, // Fee for adding social links
  CREATOR_INFO_FEE: 0.1, // Fee for custom creator info
  MAX_FEE: 0.3 // Maximum fee (capped for discount)
};

// Default token configuration
export const DEFAULT_TOKEN_CONFIG = {
  decimals: 9,
  supply: 1000000000, // 1 billion
  revokeMint: true,
  revokeFreeze: true,
  revokeUpdate: true
};

// Explorer URL generator
export const getExplorerUrl = (address: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK;
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${address}${network === 'devnet' ? '?cluster=devnet' : ''}`;
};

// Metaplex Token Metadata Program ID (constant across all Solana networks)
// UPDATED: This is the correct Metaplex Token Metadata Program ID
export const TOKEN_METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Program ID for the SPL Token Program
export const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';

// ===== src/utils/ipfs-utils.ts =====

// src/utils/ipfs-utils.ts

/**
 * Utility functions for working with IPFS and Pinata
 */

/**
 * Extracts the CID from an IPFS URL
 */
export function extractCidFromUrl(ipfsUrl: string): string | null {
    try {
      if (ipfsUrl.includes('/ipfs/')) {
        // Format: https://gateway.domain/ipfs/CID
        return ipfsUrl.split('/ipfs/')[1];
      } else if (ipfsUrl.startsWith('ipfs://')) {
        // Format: ipfs://CID
        return ipfsUrl.replace('ipfs://', '');
      }
      return null;
    } catch (error) {
      console.error('Error extracting CID from URL:', error);
      return null;
    }
  }
  
  /**
   * Converts an IPFS URL to use a specific gateway
   */
  export function convertToGatewayUrl(
    ipfsUrl: string, 
    gateway: string = process.env.NEXT_PUBLIC_PINATA_GATEWAY || 'gateway.pinata.cloud'
  ): string {
    const cid = extractCidFromUrl(ipfsUrl);
    if (!cid) return ipfsUrl; // Return original if we can't extract CID
    
    // Make sure gateway doesn't have protocol or trailing slash
    const cleanGateway = gateway.replace(/^https?:\/\//, '').replace(/\/$/, '');
    return `https://${cleanGateway}/ipfs/${cid}`;
  }
  
  /**
   * Logs IPFS operation details for debugging
   */
  export function logIpfsOperation(operation: string, details: any): void {
    console.log(`==== IPFS ${operation.toUpperCase()} ====`);
    console.table(details);
    console.log('==============================');
  }

// ===== src/utils/update-authority-utils.ts =====

// src/utils/update-authority-utils.ts

/**
 * Utility functions for handling update authority operations
 */

/**
 * Validates that the server is properly configured for update authority revocation
 * returns Promise resolving to true if configuration is valid, false otherwise
 */
export async function validateUpdateAuthorityConfig(): Promise<boolean> {
    try {
      const response = await fetch('/api/update-authority', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
  
      if (!response.ok) {
        console.error("Server configuration check failed:", await response.text());
        return false;
      }
  
      const data = await response.json();
      return data.success === true;
    } catch (error) {
      console.error("Error validating update authority configuration:", error);
      return false;
    }
  }
  
  /**
   * Checks the update authority configuration when the form loads or when
   * the user toggles the revokeUpdate option
   * @param enabled Whether revoke update is enabled
   * @param onWarning Callback for showing a warning to the user
   */
  export async function checkUpdateAuthorityStatus(
    enabled: boolean,
    onWarning: (message: string) => void
  ): Promise<void> {
    // Only check if the feature is enabled
    if (enabled) {
      const isValid = await validateUpdateAuthorityConfig();
      
      if (!isValid) {
        onWarning(
          "Warning: The server is not properly configured for revoking update authority. " +
          "This feature might not work correctly. Please contact support."
        );
      } else {
        // Clear any previous warnings if valid
        onWarning("");
      }
    }
  }
  
  /**
   * Gets the update authority public key from the server
   * @returns Promise resolving to the update authority public key
   */
  export async function getUpdateAuthorityPublicKey(): Promise<string | null> {
    try {
      const response = await fetch('/api/update-authority');
      
      if (!response.ok) {
        console.error("Failed to get update authority:", await response.text());
        return null;
      }
      
      const data = await response.json();
      
      if (!data.success || !data.updateAuthorityPublicKey) {
        console.error("Invalid response from update authority endpoint:", data);
        return null;
      }
      
      return data.updateAuthorityPublicKey;
    } catch (error) {
      console.error("Error getting update authority public key:", error);
      return null;
    }
  }

// ===== src/utils/wallet-debug.ts =====

// src/utils/wallet-debug.ts

/**
 * Helper function to debug wallet connection status
 */
export function debugWallet(wallet: any) {
    const connection = {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      publicKeyValue: wallet && wallet.publicKey ? wallet.publicKey.toString() : 'none',
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false,
      walletName: wallet?.adapter?.name || 'unknown'
    };
    
    console.log("===== WALLET DEBUG INFO =====");
    console.table(connection);
    console.log("=============================");
    
    return connection;
  }
  
  /**
   * Helper function to debug wallet adapter capabilities
   */
  export function debugWalletCapabilities(wallet: any) {
    if (!wallet || !wallet.adapter) {
      console.log("No wallet adapter found");
      return;
    }
    
    const adapter = wallet.adapter;
    
    const capabilities = {
      name: adapter.name,
      icon: !!adapter.icon,
      connected: !!adapter.connected,
      publicKey: !!adapter.publicKey,
      connecting: !!adapter.connecting,
      ready: !!adapter.ready,
      supportedTransactionVersions: adapter.supportedTransactionVersions ? 
        Array.from(adapter.supportedTransactionVersions) : [],
      hasConnect: typeof adapter.connect === 'function',
      hasDisconnect: typeof adapter.disconnect === 'function',
      hasSignTransaction: typeof adapter.signTransaction === 'function',
      hasSignAllTransactions: typeof adapter.signAllTransactions === 'function',
      hasSignMessage: typeof adapter.signMessage === 'function',
      hasSendTransaction: typeof adapter.sendTransaction === 'function',
    };
    
    console.log("===== WALLET CAPABILITIES =====");
    console.table(capabilities);
    console.log("===============================");
    
    return capabilities;
  }

// ===== src/utils/error-utils.ts =====

// src/utils/error-utils.ts

/**
 * Formats Solana errors into user-friendly messages
 */
export function formatSolanaError(error: any): string {
    // If it's already a string, just return it
    if (typeof error === 'string') return error;
    
    // Extract error message from Error object
    const errorMessage = error.message || 'Unknown error occurred';
    
    // Handle specific Solana error messages
    if (errorMessage.includes('0x1')) {
      return 'Insufficient funds for transaction. Please make sure you have enough SOL to cover the fees.';
    }
    
    if (errorMessage.includes('Blockhash not found')) {
      return 'Network congestion detected. Please try again in a few moments.';
    }
    
    if (errorMessage.includes('Transaction simulation failed')) {
      return 'Transaction simulation failed. This could be due to network congestion or insufficient SOL.';
    }
    
    if (errorMessage.includes('User rejected')) {
      return 'Transaction was rejected by wallet. You must approve the transaction to continue.';
    }
    
      // Handle wallet connection errors
    if (errorMessage.includes('wallet disconnected') || errorMessage.includes('wallet not connected')) {
      return 'Wallet disconnected. Please reconnect your wallet and try again.';
    }
    
    if (errorMessage.includes('timeout')) {
      return 'Transaction timed out. The Solana network might be congested, please try again.';
    }
    
    // Handle metadata errors
    if (errorMessage.includes('metadata')) {
      return 'Error with token metadata. Please ensure your token information is valid.';
    }
    
    // Handle Pinata/IPFS errors
    if (errorMessage.includes('Pinata') || errorMessage.includes('IPFS')) {
      return 'Error uploading to IPFS. Please try again or check if your image file is valid.';
    }
  
    // Fall back to the original error message
    return errorMessage;
  }
  
  /**
   * Logs detailed error information
   */
  export function logError(error: any, context: string): void {
    console.error(`Error in ${context}:`, error);
    
    // Log additional information if available
    if (error.code) {
      console.error(`Error code: ${error.code}`);
    }
    
    if (error.stack) {
      console.error(`Stack trace: ${error.stack}`);
    }
    
    // For Solana-specific errors
    if (error.logs) {
      console.error('Solana logs:', error.logs);
    }
  }
  
  /**
   * Creates a user-friendly error message for validation errors
   */
  export function getValidationErrorMessage(field: string, message: string): string {
    return `${field}: ${message}`;
  }
  
  /**
   * Checks common token validation rules
   */
  export function validateTokenData(data: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
  }): string | null {
    if (!data.name || data.name.trim() === '') {
      return 'Token name is required';
    }
    
    if (data.name.length > 32) {
      return 'Token name must be 32 characters or less';
    }
    
    if (!data.symbol || data.symbol.trim() === '') {
      return 'Token symbol is required';
    }
    
    if (data.symbol.length > 10) {
      return 'Token symbol must be 10 characters or less';
    }
    
    if (data.decimals < 0 || data.decimals > 18) {
      return 'Decimals must be between 0 and 18';
    }
    
    if (data.supply <= 0) {
      return 'Supply must be greater than 0';
    }
    
    if (data.supply > Number.MAX_SAFE_INTEGER) {
      return 'Supply is too large';
    }
    
    return null;
  }

// ===== src/utils/token-utils.ts =====

// src/utils/token-utils.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length < 2 || symbol.length > 10) {
      return false;
    }
    
    // Most token symbols are uppercase alphanumeric
    const validSymbolRegex = /^[A-Z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Formats a wallet address for display 
   */
  export function formatWalletAddress(address: string): string {
    if (!address || address.length < 10) return address;
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  }
  
  /**
   * Generates a token explorer URL
   */
  export function getTokenExplorerUrl(tokenAddress: string, network: string = 'devnet'): string {
    return `https://explorer.solana.com/address/${tokenAddress}${network === 'devnet' ? '?cluster=devnet' : ''}`;
  }

// ===== src/utils/token-validation.ts =====

// src/utils/token-validation.ts

/**
 * Validates a token name
 */
export function isValidTokenName(name: string): boolean {
    // Check if name is present
    if (!name || name.trim() === '') {
      return false;
    }
    
    // Check length (Solana metadata has a reasonable limit)
    if (name.length > 32) {
      return false;
    }
    
    // Check for invalid characters - allow more flexibility than the original
    const validNameRegex = /^[a-zA-Z0-9\s_\-\.]+$/;
    if (!validNameRegex.test(name)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token symbol
   */
  export function isValidTokenSymbol(symbol: string): boolean {
    // Check if symbol is present
    if (!symbol || symbol.trim() === '') {
      return false;
    }
    
    // Check length (usually 2-10 characters for token symbols)
    if (symbol.length > 10) {
      return false;
    }
    
    // Allow more flexibility in symbol format
    const validSymbolRegex = /^[A-Za-z0-9]+$/;
    if (!validSymbolRegex.test(symbol)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token description
   */
  export function isValidTokenDescription(description: string): boolean {
    // Description should exist
    if (!description || description.trim() === '') {
      return false;
    }
    
    // Reasonable length limit
    if (description.length > 1000) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates a token supply amount
   */
  export function isValidTokenSupply(supply: number): boolean {
    // Supply must be positive
    if (supply <= 0) {
      return false;
    }
    
    // Check for reasonable limits - allow bigger supply than original
    if (supply > Number.MAX_SAFE_INTEGER) {
      return false;
    }
    
    // Must be a whole number
    if (!Number.isInteger(supply)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Validates token decimals
   */
  export function isValidTokenDecimals(decimals: number): boolean {
    // Decimals must be in the valid range for Solana tokens
    return Number.isInteger(decimals) && decimals >= 0 && decimals <= 9;
  }
  
  /**
   * Validates an image file for token logo
   */
  export function isValidTokenImage(file: File | null): boolean {
    if (!file) {
      return false;
    }
    
    // Check file type
    const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!validTypes.includes(file.type)) {
      return false;
    }
    
    // Check file size (max 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Formats a number with commas for display
   */
  export function formatNumberWithCommas(number: number): string {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  /**
   * Validates the entire token form data
   * @returns string error message or null if valid
   */
  export function validateTokenForm(formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  }): string | null {
    if (!isValidTokenName(formData.name)) {
      return "Token name is required and must be up to 32 alphanumeric characters";
    }
    
    if (!isValidTokenSymbol(formData.symbol)) {
      return "Token symbol is required and must be 2-10 alphanumeric characters";
    }
    
    if (!isValidTokenDescription(formData.description)) {
      return "Description is required and must be less than 1000 characters";
    }
    
    if (!isValidTokenDecimals(formData.decimals)) {
      return "Decimals must be a whole number between 0 and 9";
    }
    
    if (!isValidTokenSupply(formData.supply)) {
      return "Supply must be a positive whole number";
    }
    
    if (!isValidTokenImage(formData.logo)) {
      return "Logo image is required (PNG or JPG, max 5MB)";
    }
    
    return null;
  }

// ===== src/components/token/token-form-options.tsx =====

'use client';

import React from 'react';
import SocialLinksForm from './social-links-form';

interface TokenFormOptionsProps {
  formData: {
    socialLinks: boolean;
    creatorInfo: boolean;
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
}

export default function TokenFormOptions({
  formData,
  setFormData,
  handleInputChange
}: TokenFormOptionsProps) {
  // Toggle function that also updates the input checkbox
  const toggleOption = (option: 'socialLinks' | 'creatorInfo') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev, 
      [option]: !prev[option]
    }));
    
    // Also simulate changing the checkbox by dispatching an event
    const checkbox = document.getElementById(option) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[option];
      const event = new Event('change', { bubbles: true });
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="creatorInfo" 
                type="checkbox" 
                name="creatorInfo"
                checked={formData.creatorInfo}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.creatorInfo ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('creatorInfo')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.creatorInfo ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Creator's Info (Optional)</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Change the information of the creator in the metadata. By default, it is SolMinter.
        </div>
      </div>

      <div className="toggle-section mb-4">
        <div className="toggle-section-header flex justify-between items-center mb-2">
          <div className="toggle-header-left flex items-center">
            <div className="toggle-wrapper mr-3">
              <input 
                id="socialLinks" 
                type="checkbox" 
                name="socialLinks"
                checked={formData.socialLinks}
                onChange={handleInputChange}
                className="hidden"
              />
              <div 
                className={`toggle w-12 h-6 rounded-full p-1 cursor-pointer ${formData.socialLinks ? 'bg-purple-600' : 'bg-gray-700'}`}
                onClick={() => toggleOption('socialLinks')}
              >
                <div className={`toggle-marker h-4 w-4 bg-white rounded-full transform transition-transform ${formData.socialLinks ? 'translate-x-6' : ''}`}></div>
              </div>
            </div>
            <div className="toggle-label text-gray-300">Add Social Links & Tags</div>
          </div>
          <div className="toggle-cost text-purple-500">+0.1 SOL</div>
        </div>
        <div className="toggle-section-description text-xs text-gray-500">
          Add links to your token metadata.
        </div>
      </div>
      
      {formData.socialLinks && (
        <SocialLinksForm formData={formData} handleInputChange={handleInputChange} />
      )}
    </div>
  );
}

// ===== src/components/token/token-form.tsx =====

"use client"

import { useState, useCallback, useEffect } from "react"
import { useWallet, useConnection } from "@solana/wallet-adapter-react"
import {
  createTokenWithMetadata,
  TokenResult,
} from "@/services/token-service"
import { calculateFee, formatFee } from "@/services/fee-service"
import TokenCreationSuccess from "./token-creation-success"
import Loading from "../ui/loading"
import TokenFormBasic from "./token-form-basic"
import TokenFormOptions from "./token-form-options"
import TokenFormAuthorities from "./token-form-authorities"
import TokenFormCreator from "./token-form-creator"
import { FormDataType } from "@/types/token"
import { SOLANA_NETWORK_FEE } from "@/config"

// Enhanced steps with more detail on IPFS operations
const STEPS = [
  "Uploading token image to IPFS…",
  "Creating token metadata…",
  "Processing transaction…",
  "Creating mint & token account…",
  "Adding on‐chain metadata…",
  "Configuring token authorities…",
  "Updating metadata with mint address…",
]

export default function TokenForm() {
  const walletAdapter = useWallet()
  const { connection } = useConnection()

  const [formData, setFormData] = useState<FormDataType>({
    name: "",
    symbol: "",
    decimals: 9,
    supply: 1_000_000_000,
    description: "",
    logo: null,
    revokeMint: true,
    revokeFreeze: true,
    revokeUpdate: true,
    socialLinks: false,
    creatorInfo: false,
    creatorName: "SolMinter", // Default creator name
    website: "",
    twitter: "",
    telegram: "",
    discord: "",
  })

  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [progressStep, setProgressStep] = useState(0)
  const [tokenResult, setTokenResult] = useState<TokenResult | null>(null)
  const [totalFee, setTotalFee] = useState<number>(0.4) // Initial fee calculation with all defaults (0.1 base + 0.3 for all authorities)
  const [formSubmitAttempted, setFormSubmitAttempted] = useState(false) // Track form submission attempts

  // Calculate fee whenever relevant form options change
  useEffect(() => {
    const fee = calculateFee({
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    console.log("Calculated fee:", fee, "with options:", {
      revokeMint: formData.revokeMint,
      revokeFreeze: formData.revokeFreeze,
      revokeUpdate: formData.revokeUpdate,
      socialLinks: formData.socialLinks,
      creatorInfo: formData.creatorInfo,
    })
    setTotalFee(fee)
  }, [
    formData.revokeMint,
    formData.revokeFreeze,
    formData.revokeUpdate,
    formData.socialLinks,
    formData.creatorInfo,
  ])

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value, type } = e.target as HTMLInputElement
    const checked = type === 'checkbox' ? (e.target as HTMLInputElement).checked : undefined
    
    console.log(`Input changed: ${name} = ${type === 'checkbox' ? checked : value}`)
    
    setFormData((prev) => ({
      ...prev,
      [name]:
        type === "checkbox"
          ? checked
          : type === "number"
          ? parseInt(value)
          : value,
    }))
  }

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFormData((prev) => ({ ...prev, logo: e.target.files![0] }))
    }
  }

  // Function to validate form data before submission
  const validateForm = (): string | null => {
    if (!walletAdapter.connected) {
      return "Please connect your wallet first";
    }
    if (!formData.logo) {
      return "Please upload a logo image";
    }
    if (!formData.name || formData.name.trim() === '') {
      return "Token name is required";
    }
    if (!formData.symbol || formData.symbol.trim() === '') {
      return "Token symbol is required";
    }
    if (!formData.description || formData.description.trim() === '') {
      return "Token description is required";
    }
    return null;
  };

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      
      // Mark that a submission attempt was made
      setFormSubmitAttempted(true)
      
      // Clear previous errors
      setError(null)
      
      // Validate form
      const validationError = validateForm();
      if (validationError) {
        setError(validationError);
        return;
      }

      try {
        setIsSubmitting(true)
        setProgressStep(0)

        const result = await createTokenWithMetadata(
          walletAdapter,
          formData,
          totalFee, // Pass the calculated total fee
          (step) => setProgressStep(step)
        )
        setTokenResult(result)
      } catch (err: any) {
        console.error("Token creation error:", err)
        setError(err.message || "Unknown error occurred during token creation")
      } finally {
        setIsSubmitting(false)
      }
    },
    [walletAdapter, formData, totalFee]
  )

  const buttonDisabled = !walletAdapter.connected || isSubmitting;

  if (tokenResult) {
    return <TokenCreationSuccess result={tokenResult} />
  }

  if (isSubmitting) {
    return (
      <Loading
        message="Creating your token..."
        steps={STEPS}
        currentStepIndex={progressStep}
      />
    )
  }

  // Calculate net fee after Solana network fee
  const netFee = Math.max(totalFee - SOLANA_NETWORK_FEE, 0);

  return (
    <form
      onSubmit={handleSubmit}
      className="max-w-3xl mx-auto space-y-6 p-6 bg-[#171717] rounded-xl"
    >
      {error && (
        <div className="text-red-400 bg-red-800/30 p-3 rounded mb-4">{error}</div>
      )}

      <TokenFormBasic
        formData={formData}
        handleInputChange={handleInputChange}
        handleFileChange={handleFileChange}
        formSubmitted={formSubmitAttempted}
      />

      <TokenFormOptions
        formData={formData}
        setFormData={setFormData}
        handleInputChange={handleInputChange}
      />

      {formData.creatorInfo && (
        <TokenFormCreator
          formData={formData}
          handleInputChange={handleInputChange}
        />
      )}

      <TokenFormAuthorities
        formData={formData}
        setFormData={setFormData}
      />

      {/* Display dynamic feature‐fee total */}
      <div className="flex justify-between items-center text-gray-300">
        <span>Total fee:</span>
        <span className="text-purple-500 font-semibold">
          {formatFee(totalFee)}
        </span>
      </div>
      <div className="text-xs text-gray-500 flex justify-between">
        <span>(Includes Solana network fee: {formatFee(SOLANA_NETWORK_FEE)})</span>
        <span>Net fee: {formatFee(netFee)}</span>
      </div>

      <button
        type="submit"
        disabled={buttonDisabled}
        className={`w-full py-3 rounded-full text-white font-medium transition cursor-pointer ${
          !buttonDisabled
            ? "bg-gradient-to-r from-purple-600 to-blue-500 hover:opacity-90"
            : "bg-gray-600 cursor-not-allowed"
        }`}
      >
        {walletAdapter.connected ? "Launch Token" : "Connect Wallet"}
      </button>
    </form>
  )
}

// ===== src/components/token/token-creation-success.tsx =====

'use client';

import Link from 'next/link';
import React, { useEffect, useState } from 'react';
import { extractCidFromUrl } from '@/utils/ipfs-utils';

interface TokenCreationSuccessProps {
  result: {
    mintAddress: string;
    metadataUrl: string;
    imageUrl: string;
    explorerUrl: string;
  };
}

interface TokenMetadata {
  name: string;
  symbol: string;
  description?: string;
  image?: string;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  tokenInfo?: {
    totalSupply?: number;
    decimals?: number;
  };
}

export default function TokenCreationSuccess({ result }: TokenCreationSuccessProps) {
  const [metadata, setMetadata] = useState<TokenMetadata | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch metadata to display additional token info
  useEffect(() => {
    async function fetchMetadata() {
      try {
        setLoading(true);
        const response = await fetch(result.metadataUrl);
        if (response.ok) {
          const data = await response.json();
          setMetadata(data);
        }
      } catch (error) {
        console.error("Error fetching metadata:", error);
      } finally {
        setLoading(false);
      }
    }

    if (result.metadataUrl) {
      fetchMetadata();
    }
  }, [result.metadataUrl]);

  // Extract relevant information from result and metadata
  const cid = extractCidFromUrl(result.metadataUrl);
  const networkParam = result.explorerUrl.includes("?cluster=devnet") ? "devnet" : "mainnet-beta";
  
  return (
    <div className="max-w-3xl mx-auto py-12 px-4">
      <div className="bg-[#171717] rounded-xl p-8 shadow-lg border border-green-500 border-opacity-30">
        <div className="text-center mb-6">
          <div className="w-20 h-20 bg-green-500 bg-opacity-20 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-10 h-10 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </div>
          
          <h1 className="text-3xl font-bold text-white mb-2">Token Created Successfully!</h1>
          <p className="text-gray-400 text-lg">Your Solana token has been created and is ready to use.</p>
        </div>
        
        <div className="token-info bg-[#222] rounded-lg p-5 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="token-image flex items-center justify-center">
              <img 
                src={result.imageUrl} 
                alt="Token Logo" 
                className="w-32 h-32 rounded-full border-4 border-gray-700"
              />
            </div>
            
            <div className="token-details">
              {metadata && (
                <div className="mb-4">
                  <div className="text-gray-500 text-sm">Token Name / Symbol</div>
                  <div className="text-white text-xl mt-1">
                    {metadata.name} <span className="text-gray-400">({metadata.symbol})</span>
                  </div>
                </div>
              )}
              
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Token Address</div>
                <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
                  {result.mintAddress}
                </div>
              </div>
              
              <div className="mb-4">
                <div className="text-gray-500 text-sm">Network</div>
                <div className="text-white mt-1 flex items-center">
                  <span className={networkParam === "devnet" ? "text-yellow-500" : "text-blue-500"}>
                    {networkParam === "devnet" ? "Devnet" : "Mainnet"}
                  </span>
                  {networkParam === "devnet" && (
                    <span className="ml-2 px-2 py-0.5 text-xs bg-yellow-900 text-yellow-300 rounded-full">
                      Testnet
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>
          
          {metadata && metadata.description && (
            <div className="mt-4">
              <div className="text-gray-500 text-sm mb-1">Description</div>
              <div className="text-gray-300 bg-[#333] p-3 rounded text-sm">{metadata.description}</div>
            </div>
          )}
          
          <div className="mt-4">
            <div className="text-gray-500 text-sm">Metadata URL</div>
            <div className="font-mono text-white text-sm bg-[#333] p-2 rounded mt-1 overflow-x-auto">
              {result.metadataUrl}
            </div>
            <div className="text-xs text-gray-500 mt-1">IPFS CID: {cid}</div>
          </div>
          
          {metadata && metadata.tokenInfo && (
            <div className="flex flex-wrap gap-4 mt-4">
              {metadata.tokenInfo.totalSupply && (
                <div>
                  <div className="text-gray-500 text-sm">Total Supply</div>
                  <div className="text-white font-semibold">
                    {metadata.tokenInfo.totalSupply.toLocaleString()}
                  </div>
                </div>
              )}
              
              {metadata.tokenInfo.decimals !== undefined && (
                <div>
                  <div className="text-gray-500 text-sm">Decimals</div>
                  <div className="text-white font-semibold">{metadata.tokenInfo.decimals}</div>
                </div>
              )}
            </div>
          )}
        </div>
        
        {/* Social Links Section */}
        {metadata && (metadata.website || metadata.twitter || metadata.telegram || metadata.discord) && (
          <div className="social-links bg-[#222] rounded-lg p-5 mb-6">
            <h3 className="text-lg font-medium text-white mb-3">Social Links</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {metadata.website && (
                <a 
                  href={metadata.website} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-purple-400 hover:text-purple-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                  </svg>
                  Website
                </a>
              )}
              
              {metadata.twitter && (
                <a 
                  href={metadata.twitter} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-blue-400 hover:text-blue-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
                  </svg>
                  Twitter
                </a>
              )}
              
              {metadata.telegram && (
                <a 
                  href={metadata.telegram} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-blue-500 hover:text-blue-400"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                  </svg>
                  Telegram
                </a>
              )}
              
              {metadata.discord && (
                <a 
                  href={metadata.discord} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="flex items-center text-indigo-400 hover:text-indigo-300"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                  </svg>
                  Discord
                </a>
              )}
            </div>
          </div>
        )}
        
        <div className="next-steps space-y-4 mb-8">
          <h2 className="text-xl font-semibold text-white">Next Steps</h2>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">Create Liquidity</h3>
            <p className="text-gray-400 mb-2">Create a liquidity pool on a DEX like Raydium to make your token tradable.</p>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              Go to Raydium
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
          
          <div className="step bg-[#222] p-4 rounded-lg">
            <h3 className="text-lg font-medium text-white mb-2">View on Explorer</h3>
            <p className="text-gray-400 mb-2">Check your token on the Solana blockchain explorer.</p>
            <a 
              href={result.explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-500 hover:text-purple-400 inline-flex items-center"
            >
              View on Explorer
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
              </svg>
            </a>
          </div>
        </div>
        
        <div className="buttons flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4">
          <Link 
            href="/"
            className="btn bg-gradient-to-r from-purple-600 to-blue-500 text-white font-medium py-3 px-8 rounded-full hover:shadow-lg transition-all text-center"
          >
            Back to Home
          </Link>
          
          <Link 
            href="/create-token"
            className="btn bg-transparent border border-purple-500 text-purple-500 font-medium py-3 px-8 rounded-full hover:bg-purple-500 hover:text-white hover:shadow-lg transition-all text-center"
          >
            Create Another Token
          </Link>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-creator.tsx =====

'use client';

import React from 'react';

interface TokenFormCreatorProps {
  formData: {
    creatorName: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function TokenFormCreator({ 
  formData, 
  handleInputChange 
}: TokenFormCreatorProps) {
  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Creator Information</div>
      
      <div className="bg-[#1e1e1e] rounded-lg p-4">
        <div className="form-field mb-4">
          <label className="field-label block text-gray-300 mb-2">Creator Name</label>
          <input 
            placeholder="Enter creator name" 
            className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
            type="text" 
            name="creatorName"
            value={formData.creatorName}
            onChange={handleInputChange}
          />
          <span className="field-constraint text-xs text-gray-500 mt-1 block">
            This name will appear as the creator in token metadata
          </span>
        </div>
      </div>
      
      <div className="text-xs text-gray-500 mt-2">
        Customize the creator information instead of using the default SolMinter.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-authorities.tsx =====

'use client';

import React, { useEffect, useState } from 'react';
import { checkUpdateAuthorityStatus } from '@/utils/update-authority-utils';

interface TokenFormAuthoritiesProps {
  formData: {
    revokeMint: boolean;
    revokeFreeze: boolean;
    revokeUpdate: boolean;
  };
  setFormData: React.Dispatch<React.SetStateAction<any>>;
}

export default function TokenFormAuthorities({
  formData,
  setFormData
}: TokenFormAuthoritiesProps) {
  const [updateAuthorityWarning, setUpdateAuthorityWarning] = useState<string>("");
  const [isCheckingConfig, setIsCheckingConfig] = useState<boolean>(false);

  // Check update authority configuration on initial load and when toggled
  useEffect(() => {
    async function checkConfig() {
      if (formData.revokeUpdate) {
        setIsCheckingConfig(true);
        await checkUpdateAuthorityStatus(
          formData.revokeUpdate, 
          (message) => setUpdateAuthorityWarning(message)
        );
        setIsCheckingConfig(false);
      } else {
        setUpdateAuthorityWarning("");
      }
    }
    
    checkConfig();
  }, [formData.revokeUpdate]);

  // Handle checkbox click with proper event simulation
  const handleCheckboxClick = (field: 'revokeMint' | 'revokeFreeze' | 'revokeUpdate') => {
    // Update the formData state
    setFormData((prev: any) => ({
      ...prev,
      [field]: !prev[field]
    }));
    
    // Find the related hidden checkbox and simulate a change event
    const checkbox = document.getElementById(field) as HTMLInputElement;
    if (checkbox) {
      checkbox.checked = !formData[field];
      // Create a proper change event
      const event = new Event('change', { bubbles: true });
      
      // Add properties to the event object using Object.defineProperty
      Object.defineProperty(event, 'target', {
        writable: false,
        value: {
          name: field,
          type: 'checkbox',
          checked: !formData[field]
        }
      });
      
      checkbox.dispatchEvent(event);
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-section-title text-xl text-white mb-4">Revoke Authorities (Investor's Booster)</div>
      
      <div className="form-section-authorities space-y-4">
        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Freeze</div>
              <input 
                id="revokeFreeze" 
                type="checkbox" 
                name="revokeFreeze"
                checked={formData.revokeFreeze}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeFreeze: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeFreeze ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeFreeze')}
              >
                {formData.revokeFreeze && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to freeze holders' token accounts anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Mint</div>
              <input 
                id="revokeMint" 
                type="checkbox" 
                name="revokeMint"
                checked={formData.revokeMint}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeMint: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeMint ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeMint')}
              >
                {formData.revokeMint && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to create more tokens anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
        </div>

        <div className="form-checkbox-field">
          <div className="form-checkbox-header flex justify-between items-center mb-1">
            <div className="flex items-center">
              <div className="form-checkbox-label text-gray-300 mr-3">Revoke Update</div>
              <input 
                id="revokeUpdate" 
                type="checkbox" 
                name="revokeUpdate"
                checked={formData.revokeUpdate}
                onChange={(e) => {
                  setFormData((prev: any) => ({
                    ...prev,
                    revokeUpdate: e.target.checked
                  }));
                }}
                className="hidden" // Keep hidden but track state
              />
              <div 
                className={`checkbox w-5 h-5 border ${formData.revokeUpdate ? 'bg-purple-600 border-purple-600' : 'bg-transparent border-gray-600'} rounded flex items-center justify-center cursor-pointer`}
                onClick={() => handleCheckboxClick('revokeUpdate')}
              >
                {formData.revokeUpdate && (
                  <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
                  </svg>
                )}
              </div>
            </div>
          </div>
          <div className="form-checkbox-description text-xs text-gray-500">
            No one will be able to modify token metadata anymore
          </div>
          <div className="form-checkbox-cost text-xs text-purple-500 mt-1">+0.1 SOL</div>
          
          {/* Display warning if there's an issue with update authority configuration */}
          {updateAuthorityWarning && (
            <div className="mt-2 text-xs text-amber-500 bg-amber-950/40 p-2 rounded">
              <div className="flex items-center">
                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                {updateAuthorityWarning}
              </div>
            </div>
          )}
          
          {/* Show loading spinner when checking server configuration */}
          {isCheckingConfig && (
            <div className="mt-2 text-xs text-blue-500 flex items-center">
              <svg className="animate-spin h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Checking server configuration...
            </div>
          )}
        </div>
      </div>
      
      <div className="form-section-description text-xs text-gray-500 mt-4">
        Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.
      </div>
    </div>
  );
}

// ===== src/components/token/social-links-form.tsx =====

'use client';

import React from 'react';

interface SocialLinksFormProps {
  formData: {
    website: string;
    twitter: string;
    telegram: string;
    discord: string;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

export default function SocialLinksForm({ formData, handleInputChange }: SocialLinksFormProps) {
  return (
    <div className="social-links-form bg-[#1e1e1e] rounded-lg p-4 mt-4">
      <h3 className="text-white text-lg mb-4">Social Links</h3>
      
      <div className="space-y-4">
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Website URL</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
              </svg>
            </span>
            <input 
              placeholder="https://your-website.com" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="website"
              value={formData.website}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Twitter</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://x.com/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="twitter"
              value={formData.twitter}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Telegram</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
            </span>
            <input 
              placeholder="https://t.me/yourtokenname" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="telegram"
              value={formData.telegram}
              onChange={handleInputChange}
            />
          </div>
        </div>
        
        <div className="form-field">
          <label className="field-label block text-gray-300 mb-2">Discord</label>
          <div className="relative">
            <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
            </span>
            <input 
              placeholder="https://discord.gg/yourinvite" 
              className="field-input w-full bg-[#222] border border-gray-700 rounded-lg py-3 pl-10 pr-3 text-white" 
              type="text" 
              name="discord"
              value={formData.discord}
              onChange={handleInputChange}
            />
          </div>
        </div>
      </div>
      
      <div className="mt-4 text-xs text-gray-500">
        Adding social links helps your community find and connect with your project. All fields are optional.
      </div>
    </div>
  );
}

// ===== src/components/token/token-form-basic.tsx =====

'use client';

import React, { useRef } from 'react';

interface TokenFormBasicProps {
  formData: {
    name: string;
    symbol: string;
    decimals: number;
    supply: number;
    description: string;
    logo: File | null;
  };
  handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  handleFileChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  formSubmitted?: boolean; // New prop to track if form was submitted
}

export default function TokenFormBasic({
  formData,
  handleInputChange,
  handleFileChange,
  formSubmitted = false // Default to false
}: TokenFormBasicProps) {
  // Create a ref for the file input
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Function to trigger file input click
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="form-section mb-8">
      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Name *</label>
        <input 
          placeholder="Ex: Moon Coin" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Max 32 characters in your name</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Token Symbol *</label>
        <input 
          placeholder="Ex: MOON" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="text" 
          name="symbol"
          value={formData.symbol}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Decimals *</label>
        <input 
          placeholder="Ex: 9" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="decimals"
          value={formData.decimals}
          onChange={handleInputChange}
          min="0"
          max="18"
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">Change the number of decimals for your token</span>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Supply *</label>
        <input 
          placeholder="Ex: 1000000000" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white" 
          type="number" 
          name="supply"
          value={formData.supply}
          onChange={handleInputChange}
          required
        />
        <span className="field-constraint text-xs text-gray-500 mt-1 block">The initial number of available tokens that will be created in your wallet</span>
      </div>

      <div className="logo-wrapper grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
        <div className="logo-box">
          <span className="label-text block text-gray-300 mb-2">Logo *</span>
          <div 
            className="img-input-wrapper border-2 border-dashed border-gray-700 rounded-lg p-6 text-center cursor-pointer hover:border-purple-500 transition-colors" 
            onClick={triggerFileInput}
          >
            <span className="material-symbols-rounded text-3xl mb-2 text-gray-400 block">upload</span>
            <span className="text-1 block text-gray-300 mb-1">Drag and drop here to upload</span>
            <div className="text-2 text-xs text-gray-500">.png, .jpg 1000x1000 px</div>
            <input 
              ref={fileInputRef}
              accept=".png, .jpg, .jpeg" 
              className="form-img hidden" 
              type="file"
              onChange={handleFileChange}
              // Remove required from hidden input
            />
          </div>
          <span className="field-constraint text-xs text-gray-500 mt-1 block">Add logo for your token</span>
          {formSubmitted && !formData.logo && (
            <span className="text-red-400 text-xs mt-1 block">
              Logo image is required
            </span>
          )}
        </div>
        
        <div className="logo-preview flex items-center justify-center">
          {formData.logo ? (
            <img 
              src={URL.createObjectURL(formData.logo)} 
              alt="Token Logo Preview" 
              className="max-h-40 rounded-lg border border-gray-700"
            />
          ) : (
            <div className="text-gray-500 text-sm">Logo preview will appear here</div>
          )}
        </div>
      </div>

      <div className="form-field mb-4">
        <label className="field-label block text-gray-300 mb-2">Description *</label>
        <textarea 
          placeholder="Here you can describe your token" 
          className="field-input w-full bg-[#222] border border-gray-700 rounded-lg p-3 text-white h-24" 
          name="description"
          value={formData.description}
          onChange={handleInputChange}
          required
        />
      </div>
    </div>
  );
}

// ===== src/components/ui/loading.tsx =====

// src/components/ui/loading.tsx

'use client'

import React from 'react'

interface LoadingProps {
  message?: string
  steps?: string[]
  /** If provided, controls which step is active; disables auto‐advance */
  currentStepIndex?: number
}

export default function Loading({
  message = 'Loading...',
  steps = [],
  currentStepIndex,
}: LoadingProps) {
  const stepIndex = currentStepIndex != null ? currentStepIndex : 0

  return (
    <div className="flex flex-col items-center justify-center p-8">
      <div className="relative w-16 h-16 mb-6">
        <div className="absolute inset-0 rounded-full border-4 border-purple-500 border-opacity-30"></div>
        <div className="absolute inset-0 rounded-full border-4 border-transparent border-t-purple-500 animate-spin"></div>
      </div>

      <div className="text-white text-lg mb-6">{message}</div>

      <ul className="w-full max-w-md space-y-3">
        {steps.map((step, idx) => {
          const isDone = idx < stepIndex
          const isActive = idx === stepIndex

          return (
            <li
              key={idx}
              className={`flex items-center text-sm ${
                isDone
                  ? 'text-white'
                  : isActive
                  ? 'text-white'
                  : 'text-gray-500'
              }`}
            >
              {isDone ? (
                <span className="w-6 h-6 mr-3 flex items-center justify-center bg-green-500 rounded-full text-white">
                  ✓
                </span>
              ) : isActive ? (
                <span className="w-6 h-6 mr-3 flex items-center justify-center border-2 border-purple-500 rounded-full">
                  <span className="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></span>
                </span>
              ) : (
                <span className="w-6 h-6 mr-3 flex items-center justify-center border-2 border-gray-600 rounded-full"></span>
              )}
              <span>{step}</span>
            </li>
          )
        })}
      </ul>
    </div>
  )
}


// ===== src/components/layout/navbar.tsx =====

'use client';

import Link from 'next/link';
import WalletButton from '../wallet/wallet-button';

export default function Navbar() {
  return (
    <div className="nav-container bg-[#111] border-b border-gray-800 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <Link href="/" className="logo-container flex items-center">
            <div className="logo-img">
              <span className="text-2xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <nav className="main-nav hidden md:flex space-x-6">
            <Link href="/" className="nav-link text-gray-300 hover:text-white transition-colors">
              Home
            </Link>
            <Link href="/create-token" className="nav-link text-gray-300 hover:text-white transition-colors">
              Create Token
            </Link>
            <a 
              href="https://raydium.io/liquidity/create-pool" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Liquidity Pool
            </a>
            <a 
              href="https://raydium.io/swap" 
              className="nav-link text-gray-300 hover:text-white transition-colors"
              rel="noopener noreferrer" 
              target="_blank"
            >
              Manage Liquidity
            </a>
            <Link href="/guides" className="nav-link text-gray-300 hover:text-white transition-colors">
              Guides
            </Link>
          </nav>
          
          <div className="wallet-dropdown">
            <WalletButton />
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/layout/footer.tsx =====

'use client';

import Link from 'next/link';

export default function Footer() {
  return (
    <div className="footer-container bg-[#111] border-t border-gray-800 py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <Link href="/" className="logo-container mb-4 md:mb-0">
            <div className="logo-img">
              <span className="text-xl font-bold bg-gradient-to-r from-purple-500 to-blue-500 bg-clip-text text-transparent">SolMinter</span>
            </div>
          </Link>
          
          <div className="bottom-bar flex flex-col md:flex-row items-center">
            <div className="copyright-bar text-gray-500 text-sm mb-2 md:mb-0">
              <span>© SolMinter 2025</span>
            </div>
            
            <div className="policies-bar flex ml-0 md:ml-6">
              <Link href="/terms" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Terms of Service
              </Link>
              <span className="separator mx-2 text-gray-600">|</span>
              <Link href="/privacy" className="policy-link text-gray-500 hover:text-white text-sm transition-colors">
                Privacy Policy
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// ===== src/components/wallet/wallet-button.tsx =====

'use client';

import { useCallback, useEffect, useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { formatWalletAddress, getWalletBalance, isWalletConnected } from '@/services/wallet-service';
import { debugWallet, debugWalletCapabilities } from '@/utils/wallet-debug';
import '@/styles/wallet-button.css';

export default function WalletButton() {
  const { publicKey, connected, connecting, disconnecting, wallet } = useWallet();
  const [mounted, setMounted] = useState(false);
  const [balance, setBalance] = useState<number | null>(null);
  
  // Load balance when connected
  const loadBalance = useCallback(async () => {
    if (connected && publicKey) {
      try {
        const sol = await getWalletBalance(publicKey);
        setBalance(sol);
      } catch (error) {
        console.error('Error fetching balance:', error);
      }
    } else {
      setBalance(null);
    }
  }, [connected, publicKey]);

  // Only show the component after mounting to prevent hydration errors
  useEffect(() => {
    setMounted(true);
  }, []);

  // Fetch balance when connected
  useEffect(() => {
    if (connected && publicKey) {
      loadBalance();
    }
  }, [connected, publicKey, loadBalance]);

  // Format public key for display
  const getFormattedAddress = () => {
    if (!publicKey) return '';
    return formatWalletAddress(publicKey.toString());
  };

  // Add some logging for debugging connection issues
  useEffect(() => {
    if (connecting) {
      console.log('Wallet connecting...');
    } else if (disconnecting) {
      console.log('Wallet disconnecting...');
    } else if (connected) {
      console.log('Wallet connected:', getFormattedAddress());
      // Add additional debugging
      debugWallet(wallet);
      debugWalletCapabilities(wallet);
    }
  }, [connecting, disconnecting, connected, publicKey, wallet]);
  
  if (!mounted) {
    // Return a placeholder with the same dimensions to prevent layout shift
    return <div className="wallet-button-placeholder h-10 w-32"></div>;
  }
  
  return (
    <div className="wallet-button relative">
      <WalletMultiButton className="wallet-display hover:bg-opacity-90 transition-all" />
      
      {connected && balance !== null && (
        <div className="wallet-balance absolute -bottom-6 right-0 text-xs text-gray-400 bg-[#171717] px-2 py-1 rounded">
          {balance.toFixed(2)} SOL
        </div>
      )}
    </div>
  );
}

// ===== src/components/wallet/wallet-provider.tsx =====

'use client';

import { FC, ReactNode, useMemo } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';

// Default styles that can be overridden by your app
import '@solana/wallet-adapter-react-ui/styles.css';

interface WalletContextProviderProps {
  children: ReactNode;
}

export const WalletContextProvider: FC<WalletContextProviderProps> = ({ children }) => {
  // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.
  const network = WalletAdapterNetwork.Devnet;

  // You can also provide a custom RPC endpoint.
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Only include Phantom wallet adapter to minimize dependency issues
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
    ],
    [network]
  );

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};

// ===== src/components/wallet/wallet-provider-client.tsx =====

'use client';

import { ReactNode, useEffect, useMemo, useState } from 'react';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-phantom';
import { SolflareWalletAdapter } from '@solana/wallet-adapter-solflare';

import { LedgerWalletAdapter } from '@solana/wallet-adapter-ledger';
// Removed the TorusWalletAdapter as it's causing dependency issues
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface ClientWalletProviderProps {
  children: ReactNode;
}

export function ClientWalletProvider({ children }: ClientWalletProviderProps) {
  // Track component mounting state to prevent hydration issues
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  // Set the network from environment variables
  const networkEnv = SOLANA_NETWORK || 'devnet';
  const network = networkEnv === 'mainnet-beta' 
    ? WalletAdapterNetwork.Mainnet
    : WalletAdapterNetwork.Devnet;

  // Set up the RPC endpoint
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);

  // Add a more comprehensive list of wallet adapters (except Torus which causes issues)
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),

      new LedgerWalletAdapter()
    ],
    [network]
  );

  // Only render the provider once the component is mounted to avoid hydration errors
  if (!mounted) return null;

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect={false}>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

// ===== src/services/ipfs-service.ts =====

// src/services/ipfs-service.ts

/**
 * Service for handling IPFS uploads via Pinata
 */

import { FormDataType } from "@/types/token";

// Helper function to generate a unique file name based on token details + timestamp
function generateUniqueFileName(name: string, symbol: string): string {
  const timestamp = Date.now();
  const sanitizedName = name.replace(/[^a-z0-9]/gi, '').toLowerCase();
  const sanitizedSymbol = symbol.replace(/[^a-z0-9]/gi, '').toLowerCase();
  return `${sanitizedSymbol}_${sanitizedName}_${timestamp}`;
}

/**
 * Uploads an image file to IPFS via Pinata
 * @returns IPFS URL for the uploaded image
 */
export async function uploadImageToIPFS(file: File, tokenName: string, tokenSymbol: string): Promise<string> {
  try {
    // Generate a unique filename based on token symbol and name
    const uniqueFileName = generateUniqueFileName(tokenName, tokenSymbol);
    const fileExtension = file.name.split('.').pop() || 'png';
    const newFileName = `${uniqueFileName}.${fileExtension}`;
    
    // Create a new file with the unique name
    const uniqueFile = new File([file], newFileName, { type: file.type });
    
    // Create FormData to send to the API
    const formData = new FormData();
    formData.append('file', uniqueFile);
    
    // Add the unique filename as metadata
    formData.append('fileName', newFileName);
    
    console.log(`Uploading image as: ${newFileName}`);
    
    const res = await fetch('/api/upload-image', {
      method: 'POST',
      body: formData,
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(`Image upload failed: ${errorData.error || res.statusText}`);
    }

    const { cid, gateway } = await res.json();
    const imageUrl = `https://${gateway}/ipfs/${cid}`;
    
    console.log(`Image uploaded successfully: ${imageUrl}`);
    return imageUrl;
  } catch (error) {
    console.error("Error uploading image to IPFS:", error);
    throw error;
  }
}

export interface MetadataPayload {
  name: string;
  symbol: string;
  description: string;
  image: string;
  mint?: string; // Optional mint address (added after token creation)
  creator?: string;
  website?: string;
  twitter?: string;
  telegram?: string;
  discord?: string;
  // Additional fields from your non-Next.js implementation
  showName?: boolean;
  tokenInfo?: {
    chain: string;
    totalSupply: number;
    circulatingSupply: number;
    decimals: number;
  };
  createdOn?: string;
}

/**
 * Uploads token metadata to IPFS via Pinata
 * @returns IPFS URL for the uploaded metadata
 */
export async function uploadMetadataToIPFS(payload: MetadataPayload): Promise<string> {
  try {
    // Generate a unique filename for the metadata
    const uniqueFileName = generateUniqueFileName(payload.name, payload.symbol);
    
    // Construct the complete metadata object similar to your non-Next.js version
    const metadata: any = {
      // Core token information
      name: payload.name,
      symbol: payload.symbol,
      description: payload.description,
      image: payload.image,
      
      // Display preference
      showName: true,
      
      // Token information
      tokenInfo: {
        chain: "Solana",
        totalSupply: payload.tokenInfo?.totalSupply || 0,
        circulatingSupply: payload.tokenInfo?.circulatingSupply || 0,
        decimals: payload.tokenInfo?.decimals || 9
      },
      
      // Add mint address if available (could be added later)
      ...(payload.mint && { mint: payload.mint }),
      
      // Add creator if provided
      ...(payload.creator && { creator: payload.creator }),
      
      // Add social links if provided
      ...(payload.website && { website: payload.website }),
      ...(payload.twitter && { twitter: payload.twitter }),
      ...(payload.telegram && { telegram: payload.telegram }),
      ...(payload.discord && { discord: payload.discord }),
      
      // Origin
      createdOn: "SolMinter"
    };

    console.log(`Uploading metadata for: ${payload.name} (${payload.symbol})`);
    
    const res = await fetch('/api/upload-metadata', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metadata,
        fileName: `${uniqueFileName}.json`
      }),
    });

    if (!res.ok) {
      const errorData = await res.json();
      throw new Error(`Metadata upload failed: ${errorData.error || res.statusText}`);
    }

    const { cid, gateway } = await res.json();
    const metadataUrl = `https://${gateway}/ipfs/${cid}`;
    
    console.log(`Metadata uploaded successfully: ${metadataUrl}`);
    return metadataUrl;
  } catch (error) {
    console.error("Error uploading metadata to IPFS:", error);
    throw error;
  }
}

/**
 * Update token metadata with mint address after token creation
 * @returns IPFS URL for the updated metadata
 */
export async function updateMetadataWithMintAddress(
  originalMetadataUrl: string, 
  mintAddress: string, 
  formData: FormDataType
): Promise<string> {
  try {
    // Create updated metadata payload with mint address
    const payload: MetadataPayload = {
      name: formData.name,
      symbol: formData.symbol,
      description: formData.description,
      image: originalMetadataUrl.split('/ipfs/')[0] + '/ipfs/' + originalMetadataUrl.split('/ipfs/')[1],
      mint: mintAddress,
      creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
      tokenInfo: {
        chain: "Solana",
        totalSupply: formData.supply,
        circulatingSupply: formData.supply,
        decimals: formData.decimals
      }
    };
    
    // Add social links if enabled
    if (formData.socialLinks) {
      payload.website = formData.website || undefined;
      payload.twitter = formData.twitter || undefined;
      payload.telegram = formData.telegram || undefined;
      payload.discord = formData.discord || undefined;
    }
    
    // Upload the updated metadata
    return await uploadMetadataToIPFS(payload);
  } catch (error) {
    console.error("Error updating metadata with mint address:", error);
    throw error;
  }
}

// ===== src/services/token-service.ts =====

// src/services/token-service.ts

import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  TransactionInstruction,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  MINT_SIZE,
  createInitializeMintInstruction,
  getMinimumBalanceForRentExemptMint,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType,
} from "@solana/spl-token";
import type { WalletContextState } from "@solana/wallet-adapter-react";

import { getSolanaConnection } from "./wallet-service";
import {
  uploadImageToIPFS,
  uploadMetadataToIPFS,
  updateMetadataWithMintAddress,
  MetadataPayload,
} from "./ipfs-service";
import {
  TOKEN_METADATA_PROGRAM_ID,
  FEE_RECIPIENT_WALLET,
  SOLANA_NETWORK_FEE,
} from "@/config";
import { FormDataType } from "@/types/token";

/** What we return once done */
export interface TokenResult {
  mintAddress: string;
  metadataUrl: string;
  imageUrl: string;
  explorerUrl: string;
}

/** Helper: serialize a UTF‑8 string with u32‑length prefix (LE) */
function serializeString(value: string): Uint8Array {
  const buffer = Buffer.from(value, "utf8");
  const length = Buffer.alloc(4);
  length.writeUInt32LE(buffer.length, 0);
  return Buffer.concat([length, buffer]);
}

/**
 * Helper function that correctly serializes metadata for the
 * Metaplex createMetadataAccountV3 instruction
 */
function serializeMetadataV3(data: {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: { address: PublicKey; verified: boolean; share: number }[] | null;
  collection: { key: string; verified: boolean } | null;
  uses: any | null;
  isMutable: boolean;
}): Uint8Array {
  // Name
  const nameBuffer = serializeString(data.name);
  // Symbol
  const symbolBuffer = serializeString(data.symbol);
  // URI
  const uriBuffer = serializeString(data.uri);
  // Seller fee basis points (u16)
  const sellerFeeBasisPointsBuffer = Buffer.alloc(2);
  sellerFeeBasisPointsBuffer.writeUInt16LE(data.sellerFeeBasisPoints, 0);

  // Creators (Option<Vec<Creator>>)
  let creatorsBuffer;
  if (data.creators === null) {
    creatorsBuffer = Buffer.from([0]); // None
  } else {
    const creatorsVec = Buffer.concat(
      data.creators.map((creator) => {
        const address = creator.address.toBuffer();
        const verified = Buffer.from([creator.verified ? 1 : 0]);
        const share = Buffer.from([creator.share]);
        return Buffer.concat([address, verified, share]);
      })
    );

    const creatorsLength = Buffer.alloc(4);
    creatorsLength.writeUInt32LE(data.creators.length, 0);

    creatorsBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      creatorsLength,
      creatorsVec,
    ]);
  }

  // Collection (Option<Collection>)
  let collectionBuffer;
  if (data.collection === null) {
    collectionBuffer = Buffer.from([0]); // None
  } else {
    collectionBuffer = Buffer.concat([
      Buffer.from([1]), // Some
      new PublicKey(data.collection.key).toBuffer(),
      Buffer.from([data.collection.verified ? 1 : 0]),
    ]);
  }

  // Uses (Option<Uses>)
  let usesBuffer;
  if (data.uses === null) {
    usesBuffer = Buffer.from([0]); // None
  } else {
    usesBuffer = Buffer.from([0]); // None
  }

  // Collection Details (Option<CollectionDetails>)
  const collectionDetailsBuffer = Buffer.from([0]);

  // isMutable
  const isMutableBuffer = Buffer.from([data.isMutable ? 1 : 0]);

  return Buffer.concat([
    nameBuffer,
    symbolBuffer,
    uriBuffer,
    sellerFeeBasisPointsBuffer,
    creatorsBuffer,
    collectionBuffer,
    usesBuffer,
    collectionDetailsBuffer,
    isMutableBuffer,
  ]);
}

/**
 * Orchestrates token creation with a single transaction
 * Network fees are deducted from the fee recipient amount, so the user pays EXACTLY the displayed fee
 */
export async function createTokenWithMetadata(
  walletAdapter: WalletContextState,
  formData: FormDataType,
  totalFee: number,
  onProgress?: (step: number) => void
): Promise<TokenResult> {
  const { publicKey, signTransaction, connected } = walletAdapter;
  if (!connected || !publicKey) {
    throw new Error("Wallet not connected. Please connect your wallet first.");
  }
  const connection: Connection = getSolanaConnection();

  // Validate inputs
  if (!formData.logo) {
    throw new Error("Please upload a logo image");
  }
  if (!formData.name || formData.name.trim() === "") {
    throw new Error("Token name is required");
  }
  if (!formData.symbol || formData.symbol.trim() === "") {
    throw new Error("Token symbol is required");
  }
  if (!formData.description || formData.description.trim() === "") {
    throw new Error("Token description is required");
  }

  // Ensure minimum fee
  const minimumFeeInSOL = 0.1;
  if (totalFee < minimumFeeInSOL) {
    console.warn(
      `Fee is too low (${totalFee}), using minimum fee of ${minimumFeeInSOL} SOL`
    );
    totalFee = minimumFeeInSOL;
  }

  // Calculate the net fee after subtracting the Solana network fee
  const networkFee = SOLANA_NETWORK_FEE;
  const netFeeAmount = Math.max(totalFee - networkFee, 0);

  console.log("Creating token with displayed fee:", totalFee, "SOL");
  console.log("Solana network fee:", networkFee, "SOL");
  console.log("Net fee to fee recipient:", netFeeAmount, "SOL");
  console.log("Token options:", {
    revokeMint: formData.revokeMint,
    revokeFreeze: formData.revokeFreeze,
    revokeUpdate: formData.revokeUpdate,
    socialLinks: formData.socialLinks,
    creatorInfo: formData.creatorInfo,
  });

  // STEP 0: IPFS image with unique name
  onProgress?.(0);
  const imageUrl = await uploadImageToIPFS(
    formData.logo,
    formData.name,
    formData.symbol
  );

  // STEP 1: IPFS metadata JSON
  onProgress?.(1);

  const metadataPayload: MetadataPayload = {
    name: formData.name,
    symbol: formData.symbol,
    description: formData.description,
    image: imageUrl,
    creator: formData.creatorInfo ? formData.creatorName : "SolMinter",
    showName: true,
    tokenInfo: {
      chain: "Solana",
      totalSupply: formData.supply,
      circulatingSupply: formData.supply,
      decimals: formData.decimals,
    },
    createdOn: "SolMinter",
    ...(formData.socialLinks && {
      website: formData.website,
      twitter: formData.twitter,
      telegram: formData.telegram,
      discord: formData.discord,
    }),
  };

  const metadataUrl = await uploadMetadataToIPFS(metadataPayload);

  // STEP 2: Prepare transaction
  onProgress?.(2);

  const mintKeypair = Keypair.generate();
  const rentExempt = await getMinimumBalanceForRentExemptMint(connection);

  // Check whether to use server-side update authority (only when revoking update)
  const useServerUpdateAuthority = formData.revokeUpdate;

  if (useServerUpdateAuthority) {
    // ─── Server‑side signing branch ────────────────────────────────────────────────────────────────
    try {
      const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);
      const mintPrivateKey = Buffer.from(mintKeypair.secretKey).toString(
        "base64"
      );
      const { blockhash } = await connection.getLatestBlockhash();

      const response = await fetch("/api/sign-transaction", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          mintPrivateKey,
          metadataUrl,
          tokenName: formData.name,
          tokenSymbol: formData.symbol,
          tokenDecimals: formData.decimals,
          tokenSupply: formData.supply,
          payerPublicKey: publicKey.toString(),
          hasCreators: formData.creatorInfo,
          revokeUpdate: formData.revokeUpdate,
          revokeMint: formData.revokeMint,
          revokeFreeze: formData.revokeFreeze,
          recentBlockhash: blockhash,
          feeWalletPubkey: FEE_RECIPIENT_WALLET,
          feeAmountInLamports,
          includeFeeTx: netFeeAmount > 0,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          errorData.error || "Failed to sign transaction on server"
        );
      }

      const { signedTransaction, mintAddress } = await response.json();
      const transaction = Transaction.from(
        Buffer.from(signedTransaction, "base64")
      );

      console.log(
        "Transaction constructed and signed by server for update authority"
      );

      onProgress?.(3);

      // Properly handle wallet rejection here
      let walletSignedTransaction;
      try {
        walletSignedTransaction = await signTransaction!(transaction);
      } catch (walletError) {
        console.error("Wallet signature rejected by user:", walletError);
        throw new Error("Transaction was canceled by the user");
      }

      if (!walletSignedTransaction) {
        throw new Error("Transaction signing failed");
      }

      // Now that we have a properly signed transaction, send it
      const txSignature = await connection.sendRawTransaction(
        walletSignedTransaction.serialize()
      );
      await connection.confirmTransaction(txSignature);

      console.log("Transaction confirmed successfully!");
      onProgress?.(6);

      const updatedMetadataUrl = await updateMetadataWithMintAddress(
        metadataUrl,
        mintAddress,
        formData
      );
      const clusterParam =
        process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
          ? "?cluster=devnet"
          : "";

      return {
        mintAddress,
        metadataUrl: updatedMetadataUrl,
        imageUrl,
        explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
      };
    } catch (error) {
      console.error("Error in server-side update authority flow:", error);
      throw new Error(
        `Failed to process transaction: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  } else {
    // ─── Client‑side flow branch ───────────────────────────────────────────────────────────────────
    try {
      const instructions: TransactionInstruction[] = [];
      const feeWalletPubkey = new PublicKey(FEE_RECIPIENT_WALLET);
      const feeAmountInLamports = Math.floor(netFeeAmount * LAMPORTS_PER_SOL);

      if (feeAmountInLamports > 0) {
        instructions.push(
          SystemProgram.transfer({
            fromPubkey: publicKey,
            toPubkey: feeWalletPubkey,
            lamports: feeAmountInLamports,
          })
        );
      } else {
        console.log("Net fee is zero or negative, skipping fee transfer");
      }

      instructions.push(
        SystemProgram.createAccount({
          fromPubkey: publicKey,
          newAccountPubkey: mintKeypair.publicKey,
          space: MINT_SIZE,
          lamports: rentExempt,
          programId: TOKEN_PROGRAM_ID,
        })
      );

      instructions.push(
        createInitializeMintInstruction(
          mintKeypair.publicKey,
          formData.decimals,
          publicKey,
          publicKey,
          TOKEN_PROGRAM_ID
        )
      );

      const ata = await getAssociatedTokenAddress(
        mintKeypair.publicKey,
        publicKey
      );
      instructions.push(
        createAssociatedTokenAccountInstruction(
          publicKey,
          ata,
          publicKey,
          mintKeypair.publicKey
        )
      );

      const mintAmount =
        BigInt(formData.supply) * BigInt(10 ** formData.decimals);
      instructions.push(
        createMintToInstruction(
          mintKeypair.publicKey,
          ata,
          publicKey,
          mintAmount
        )
      );

      onProgress?.(4);

      const metadataProgramId = new PublicKey(TOKEN_METADATA_PROGRAM_ID);
      const [metadataPDA] = PublicKey.findProgramAddressSync(
        [
          Buffer.from("metadata"),
          metadataProgramId.toBuffer(),
          mintKeypair.publicKey.toBuffer(),
        ],
        metadataProgramId
      );

      let creators = null;
      if (formData.creatorInfo) {
        creators = [
          {
            address: publicKey,
            verified: true,
            share: 100,
          },
        ];
      }

      instructions.push({
        programId: metadataProgramId,
        keys: [
          { pubkey: metadataPDA, isSigner: false, isWritable: true },
          { pubkey: mintKeypair.publicKey, isSigner: false, isWritable: false },
          { pubkey: publicKey, isSigner: true, isWritable: false }, // mint authority
          { pubkey: publicKey, isSigner: true, isWritable: false }, // payer
          { pubkey: publicKey, isSigner: false, isWritable: false }, // update authority
          {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false,
          },
        ],
        data: Buffer.concat([
          Buffer.from([33]), // createMetadataAccountV3 discriminator
          serializeMetadataV3({
            name: formData.name,
            symbol: formData.symbol,
            uri: metadataUrl,
            sellerFeeBasisPoints: 0,
            creators,
            collection: null,
            uses: null,
            isMutable: false, // immutable when revokeUpdate is off
          }),
        ]),
      });

      onProgress?.(5);
      if (formData.revokeMint) {
        instructions.push(
          createSetAuthorityInstruction(
            mintKeypair.publicKey,
            publicKey,
            AuthorityType.MintTokens,
            null,
            [],
            TOKEN_PROGRAM_ID
          )
        );
      }
      if (formData.revokeFreeze) {
        instructions.push(
          createSetAuthorityInstruction(
            mintKeypair.publicKey,
            publicKey,
            AuthorityType.FreezeAccount,
            null,
            [],
            TOKEN_PROGRAM_ID
          )
        );
      }

      const transaction = new Transaction();
      instructions.forEach((ix) => transaction.add(ix));
      transaction.feePayer = publicKey;
      transaction.recentBlockhash = (
        await connection.getLatestBlockhash()
      ).blockhash;
      transaction.partialSign(mintKeypair);

      console.log("Sending transaction to wallet for approval...");
      const signedTransaction = await signTransaction!(transaction);
      const txSignature = await connection.sendRawTransaction(
        signedTransaction.serialize()
      );
      await connection.confirmTransaction(txSignature);

      const mintAddress = mintKeypair.publicKey.toString();
      onProgress?.(6);
      let finalMetadataUrl = metadataUrl;
      try {
        finalMetadataUrl = await updateMetadataWithMintAddress(
          metadataUrl,
          mintAddress,
          formData
        );
      } catch (updateError) {
        console.error("Error updating metadata (non-critical):", updateError);
      }

      const clusterParam =
        process.env.NEXT_PUBLIC_SOLANA_NETWORK === "devnet"
          ? "?cluster=devnet"
          : "";
      return {
        mintAddress,
        metadataUrl: finalMetadataUrl,
        imageUrl,
        explorerUrl: `https://explorer.solana.com/address/${mintAddress}${clusterParam}`,
      };
    } catch (error: unknown) {
      console.error("Transaction error:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to process transaction: ${errorMessage}`);
    }
  }
}


// ===== src/services/fee-service.ts =====

// src/services/fee-service.ts

export interface FeeOptions {
  revokeMint: boolean
  revokeFreeze: boolean
  revokeUpdate: boolean
  socialLinks: boolean
  creatorInfo: boolean
}

// Base fee plus optional feature fees
export function calculateFee(options: FeeOptions): number {
  let fee = 0.1; // Base fee for token creation - corrected to 0.1

  // Add fee for each enabled feature
  if (options.revokeMint)    fee += 0.1;
  if (options.revokeFreeze)  fee += 0.1;
  if (options.revokeUpdate)  fee += 0.1;
  if (options.socialLinks)   fee += 0.1;
  if (options.creatorInfo)   fee += 0.1;

  // Return the total fee amount rounded to 2 decimal places
  return Math.round(fee * 100) / 100;
}

// Format the fee for display
export function formatFee(fee: number): string {
  return `${fee.toFixed(2)} SOL`;
}

// ===== src/services/wallet-service.ts =====

// src/services/wallet-service.ts
import { WalletAdapter } from '@solana/wallet-adapter-base';
import { Connection, clusterApiUrl, PublicKey } from '@solana/web3.js';
import { SOLANA_NETWORK } from '@/config';

// Get the Solana connection based on the configured network
export const getSolanaConnection = (): Connection => {
  const network = SOLANA_NETWORK === 'mainnet-beta' ? 'mainnet-beta' : 'devnet';
  return new Connection(clusterApiUrl(network), 'confirmed');
};

// Check if wallet is properly connected
export const isWalletConnected = (wallet: any): boolean => {
    // Debug log to help diagnose issues
    console.log("Wallet connection check:", {
      walletExists: !!wallet,
      publicKeyExists: wallet ? !!wallet.publicKey : false,
      adapterExists: wallet ? !!wallet.adapter : false,
      adapterConnected: wallet?.adapter ? !!wallet.adapter.connected : false
    });
    
    // For some wallets, adapter.connected might not be reliable
    // Consider a wallet connected if it has a wallet object and a public key
    return !!wallet && !!wallet.publicKey;
  };

// Get the wallet's SOL balance
export const getWalletBalance = async (publicKey: PublicKey): Promise<number> => {
  try {
    const connection = getSolanaConnection();
    const balance = await connection.getBalance(publicKey);
    console.log(`Wallet balance: ${balance / 1_000_000_000} SOL`);
    return balance / 1_000_000_000; // Convert lamports to SOL
  } catch (error) {
    console.error('Error getting wallet balance:', error);
    return 0;
  }
};

// Format the wallet address for display
export const formatWalletAddress = (address: string): string => {
  if (!address || address.length < 10) return address;
  return `${address.slice(0, 4)}...${address.slice(-4)}`;
};

// Get the Solana explorer URL for a transaction or address
export const getExplorerUrl = (addressOrSignature: string, isTransaction = false): string => {
  const network = SOLANA_NETWORK === 'devnet' ? '?cluster=devnet' : '';
  const type = isTransaction ? 'tx' : 'address';
  return `https://explorer.solana.com/${type}/${addressOrSignature}${network}`;
};

